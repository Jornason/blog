<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><!-- redirect to https by default if we already have weather data--><script>if (document.cookie.search("weatherData") == -1 && window.location.protocol != "http:"){
  window.location.protocol = "http";
}
if (("taoalpha.me" == window.location.host) && (window.location.protocol != "https:") && document.cookie.search("weatherData") != -1) {
  window.location.protocol = "https";
}</script><title> OJ Word Search Problems | TaoAlpha's Blog</title><meta name="description" content="Here is my new blog based on hexo."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:image" content="http://taoalpha.me/images/newblog.jpg"><meta property="og:description" content="TaoAlpha's hexo Blog"><meta property="og:type" content="website"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"></head><body class="blogpost"><aside class="home-menu"><nav class="home-icon-con upside"></nav><a href="/blog/" class="home-menu-icon brand active">涛</a><a href="/blog/tipme" class="home-menu-icon"><i class="fa fa-1x fa-gratipay"></i></a><a href="javascript:$('.searchbox').focus().css('border', '4px dashed #666');setTimeout(function(){$('.searchbox').focus().css('border', 'none').css('border-bottom', '1px solid #ccc')},1000);" class="home-menu-icon"><i class="fa fa-1x fa-search"></i></a><a href="/blog/puzzle" class="home-menu-icon"><i class="fa fa-1x fa-puzzle-piece"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact"><a href="https://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="https://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="https://taoalpha.me" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="https://douban.com/people/129154019" target="something"><img src="https://img3.doubanio.com/favicon.ico" alt="douban"></a></div><nav class="home-icon-con downside"><a href="#contribution" class="home-menu-icon makecontribution"><i class="fa fa-pencil fa-1x"></i></a><a id="togglemusic" href="javascript:;" class="home-menu-icon"><i class="fa fa-music fa-1x"></i></a></nav><div id="musicbar"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="40" src=""></iframe></div></aside><div id="contribution" class="hide"><span class="close"></span><input id="sender_mail" type="email" placeholder="Give me your email"><textarea id="contributionContent" name="contribution" cols="30" rows="10" placeholder="Thanks for your contribution!  Now tell me what you want to say: feedback ? advice ? contributions ? Whatever you want ^_^.  I will look at it as soon as I receive it and reply you asap.  "></textarea><input id="sendToMe" type="submit"></div><div class="stars"></div><div class="twinkling"></div><article id="content"><div id="progressbar"><span class="bg"></span><span class="text"></span></div><section class="entry"><h1 class="entry-title"><a href="http://taoalpha.me/blog/2016/01/20/oj-oj-word-search-problems/" title="OJ Word Search Problems">OJ Word Search Problems</a></h1><div class="meta-top"><a href="https://taoalpha.me"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2016-01-20</span><span class="wordage">11254字</span><span class="readspeed">33 分钟读完</span></div><h2 id="79-_Word_Search"><a href="#79-_Word_Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<p>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="external">79. Word Search</a></cite></footer></blockquote>
<p>Tags: Array, Backtracking, Medium</p>
<h3 id="Answers"><a href="#Answers" class="headerlink" title="Answers"></a>Answers</h3><h4 id="DFS_and_hashtable"><a href="#DFS_and_hashtable" class="headerlink" title="DFS and hashtable"></a>DFS and hashtable</h4><p>The first idea hit my head is using dfs, so here is my exit condition:</p>
<ul>
<li>index out of bound;</li>
<li>visited elements(stored in a hashtable);</li>
<li>prefix not fit with target;</li>
</ul>
<p>True condition:</p>
<ul>
<li>String match.</li>
</ul>
<p>So I got my code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @param &#123;string&#125; word</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i , j, mapper = &#123;&#125;;   <span class="comment">// all visited elements will be marked as true within mapper</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="comment">// start with the first same letter</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(board,i,j,<span class="string">''</span>,word,mapper))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = (board,x,y,comb,word,mapper) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(comb == word)&#123;</span><br><span class="line">    <span class="comment">// true condition</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mapper[x+<span class="string">"-"</span>+y] || word.length &lt; comb.length || word.indexOf(comb) !== <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// exit condition 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &gt;= board.length || x &lt; <span class="number">0</span> || y &gt;= board[x].length || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// exit condition 2, out of bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  mapper[x+<span class="string">"-"</span>+y] = <span class="literal">true</span>;  <span class="comment">// mark current elements as visited</span></span><br><span class="line">  comb += board[x][y]</span><br><span class="line">  <span class="keyword">if</span>(dfs(board,x+<span class="number">1</span>,y,comb,word,mapper) || dfs(board,x,y+<span class="number">1</span>,comb,word,mapper) || dfs(board,x,y-<span class="number">1</span>,comb,word,mapper) || dfs(board,x-<span class="number">1</span>,y,comb,word,mapper))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    mapper[x+<span class="string">"-"</span>+y] = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// recover the element for following loop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can pass with this. But it will be slow as 404ms.</p>
<h4 id="DFS_Optimization"><a href="#DFS_Optimization" class="headerlink" title="DFS Optimization"></a>DFS Optimization</h4><p>I look at my code again, and find that since I can compare the first letter, why not just compare the current letter for each dfs. So I move it into the dfs and simplify my code with new exit and true condition:</p>
<p>True condition:</p>
<ul>
<li>All letters match;</li>
</ul>
<p>Exit condition:</p>
<ul>
<li>Letter not match;</li>
<li>index out of bound;</li>
<li>visited elements;</li>
</ul>
<p>And also, we don’t need to store the visited elements, we can just change it and then put the origin one back after the loop;</p>
<p>So finally we got this:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @param &#123;string&#125; word</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i , j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(dfs(board,i,j,word,<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = (board,x,y,word,step) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(step == word.length)&#123;</span><br><span class="line">    <span class="comment">// all letters match, we got our word</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &gt;= board.length || x &lt; <span class="number">0</span> || y &gt;= board[x].length || y -<span class="number">1</span>&lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// exit condition 1 - out of bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(board[x][y] == <span class="string">"\0"</span> || board[x][y] !== word[step])&#123;</span><br><span class="line">    <span class="comment">// exit condition 2 - visited or not same letter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> temp  = board[x][y];</span><br><span class="line">  board[x][y] = <span class="string">"\0"</span>;   <span class="comment">// change the visited elements to something else </span></span><br><span class="line">  <span class="keyword">if</span>(dfs(board,x+<span class="number">1</span>,y,word,step+<span class="number">1</span>) || dfs(board,x,y+<span class="number">1</span>,word,step+<span class="number">1</span>) || dfs(board,x,y-<span class="number">1</span>,word,step+<span class="number">1</span>) || dfs(board,x-<span class="number">1</span>,y,word,step+<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    board[x][y] = temp;   <span class="comment">// put the origin letter back</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now with the new code, we can hit the 168 ms.</p>
<h2 id="212-_Word_Search_II"><a href="#212-_Word_Search_II" class="headerlink" title="212. Word Search II"></a>212. Word Search II</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,<br>Given words = [“oath”,”pea”,”eat”,”rain”] and board =</p>
<p>[<br>  [‘o’,’a’,’a’,’n’],<br>  [‘e’,’t’,’a’,’e’],<br>  [‘i’,’h’,’k’,’r’],<br>  [‘i’,’f’,’l’,’v’]<br>]<br>Return [“eat”,”oath”].<br>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="external">212. Word Search II</a></cite></footer></blockquote>
<p>Tags: Trie, Backtracking, Hard</p>
<h3 id="Answers-1"><a href="#Answers-1" class="headerlink" title="Answers"></a>Answers</h3><h4 id="Trie_with_classic_way"><a href="#Trie_with_classic_way" class="headerlink" title="Trie with classic way"></a>Trie with classic way</h4><p>Since this question is based on the previous one, we can just borrow our previous code here. And if you just loop through all words, it will be TLE. So you have to do pruning to stop the dfs as soon as possible.</p>
<p>According to the hint, we can use Trie to help us stop the dfs earlier, here I just use some code I wrote for another problem. As before, lets list the exit condition and succesful conditions for this problem:</p>
<p>Exit conditions:</p>
<ul>
<li>Out of bound;</li>
<li>Visited;</li>
<li>Prefix never show up in our Trie(which was built with all input words);</li>
</ul>
<p>True conditon:</p>
<ul>
<li>Words is in our Trie;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Trie implementation in JavaScript</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TrieNode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// # of words end here </span></span><br><span class="line">  <span class="keyword">this</span>.wordsCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">// # of words will match the prefix</span></span><br><span class="line">  <span class="keyword">this</span>.prefixMatches = <span class="number">0</span></span><br><span class="line">  <span class="comment">// all the node belong to this node</span></span><br><span class="line">  <span class="keyword">this</span>.children = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Trie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Trie.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// if not a word, return</span></span><br><span class="line">  <span class="keyword">if</span>(word.length &lt;=<span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">this</span>.root</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="comment">// loop every character of the word and update associate node</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;word.length)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node.children.hasOwnProperty(word[i]))&#123;</span><br><span class="line">    node.children[word[i]] = <span class="keyword">new</span> TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  node = node.children[word[i]] </span><br><span class="line">  <span class="keyword">if</span>(i == word.length-<span class="number">1</span>)&#123;</span><br><span class="line">    node.wordsCount ++</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    node.prefixMatches ++</span><br><span class="line">  &#125;</span><br><span class="line">  i ++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Trie.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// if not a word, return</span></span><br><span class="line">  <span class="keyword">if</span>(prefix.length &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">this</span>.root</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="comment">// loop every character of the word and find whether there is any match</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;prefix.length)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node.children.hasOwnProperty(prefix[i]))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  node = node.children[prefix[i]] </span><br><span class="line">  <span class="keyword">if</span>(i == prefix.length-<span class="number">1</span> &amp;&amp; (node.prefixMatches !== <span class="number">0</span> || node.wordsCount !== <span class="number">0</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  i ++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; </span><br><span class="line">Trie.prototype.search = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// if not a word, return</span></span><br><span class="line">  <span class="keyword">if</span>(word.length &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">this</span>.root</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="comment">// loop every character of the word and find whether there is any match</span></span><br><span class="line">  <span class="keyword">while</span>(i&lt;word.length)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node.children.hasOwnProperty(word[i]))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  node = node.children[word[i]] </span><br><span class="line">  <span class="keyword">if</span>(i == word.length-<span class="number">1</span> &amp;&amp; node.wordsCount === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  i ++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @param &#123;string[]&#125; words</span><br><span class="line"> * @return &#123;string[]&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> findWords = <span class="function"><span class="keyword">function</span>(<span class="params">board, words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i,j, trie = <span class="keyword">new</span> Trie(),output = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; words.length;i++)&#123;</span><br><span class="line">    trie.insert(words[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">      dfs(board,i,j,<span class="number">0</span>,<span class="string">''</span>,trie,output)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  output.forEach( (v) =&gt; &#123;res.push(v)&#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @param &#123;string&#125; word</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = (board,x,y,str,trie,output) =&gt;&#123;</span><br><span class="line">  <span class="comment">// the code is pretty much same with previous word search I, but store the fit words into output asap</span></span><br><span class="line">  <span class="keyword">if</span>(x &gt;= board.length || x &lt; <span class="number">0</span> || y &gt;= board[x].length || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// exit condition 1 - out of bound </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(board[x][y] == <span class="string">"\0"</span>)&#123;</span><br><span class="line">    <span class="comment">// exit condition 2 - visited</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  str += board[x][y];</span><br><span class="line">  <span class="comment">// exit condition 2 - not in our trie tree</span></span><br><span class="line">  <span class="keyword">if</span>(!trie.startsWith(str))&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// match condition</span></span><br><span class="line">  <span class="keyword">if</span>(trie.search(str))&#123;output.add(str)&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> temp  = board[x][y];</span><br><span class="line">  board[x][y] = <span class="string">"\0"</span>;</span><br><span class="line">  dfs(board,x+<span class="number">1</span>,y,str,trie,output)</span><br><span class="line">  dfs(board,x,y+<span class="number">1</span>,str,trie,output)</span><br><span class="line">  dfs(board,x,y-<span class="number">1</span>,str,trie,output)</span><br><span class="line">  dfs(board,x-<span class="number">1</span>,y,str,trie,output)</span><br><span class="line">  board[x][y] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime: 868 ms</p>
<p>This is so slow… that I even can not appear in the rumtime distribution of javascript….</p>
<h4 id="Modified_Trie"><a href="#Modified_Trie" class="headerlink" title="Modified Trie"></a>Modified Trie</h4><p>According to this post: <a href="https://leetcode.com/discuss/77851/java-15ms-easiest-solution-100-00%25" target="_blank" rel="external">Java 15ms easiest solution</a>. We actually don’t need the entire tree structure, we can modify the structure to speed up our answer for this problem.</p>
<p>Here is the code in JS:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;character[][]&#125; board</span><br><span class="line"> * @param &#123;string[]&#125; words</span><br><span class="line"> * @return &#123;string[]&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> findWords = <span class="function"><span class="keyword">function</span>(<span class="params">board, words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i,j,output=[], root = buildTrie(words);   <span class="comment">// build the Trie with input words</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;board[i].length;j++)&#123;</span><br><span class="line">      dfs(board, i, j, root, output);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TrieNode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.next = [];  <span class="comment">// store next letter from 0 - 25 &lt;= a - z</span></span><br><span class="line">  <span class="keyword">this</span>.word = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildTrie = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, root = <span class="keyword">new</span> TrieNode(),j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> node = root;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;words[i].length;j++)&#123;</span><br><span class="line">      <span class="keyword">var</span> idx = words[i][j].charCodeAt(<span class="number">0</span>) - <span class="number">97</span>;   <span class="comment">// hash index of the letter, all letters are lowercase</span></span><br><span class="line">      <span class="keyword">if</span>(!node.next[idx])&#123;</span><br><span class="line">        node.next[idx] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[idx];  <span class="comment">// move the node to the end</span></span><br><span class="line">    &#125;</span><br><span class="line">    node.word = words[i];  <span class="comment">// store the word in the end node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs = (board,i,j,node,output) =&gt;&#123;</span><br><span class="line">  <span class="keyword">var</span> idx = board[i][j].charCodeAt(<span class="number">0</span>) - <span class="number">97</span>;  <span class="comment">// compute the hash index</span></span><br><span class="line">  <span class="keyword">if</span>(board[i][j] == <span class="string">'#'</span> || !node.next[idx]) <span class="keyword">return</span>;  <span class="comment">// exit condition: visited or not in Trie</span></span><br><span class="line">  node = node.next[idx];</span><br><span class="line">  <span class="keyword">if</span>(node.word != <span class="string">""</span>)&#123;</span><br><span class="line">    <span class="comment">// successful condition</span></span><br><span class="line">    output.push(node.word);</span><br><span class="line">    node.word = <span class="string">""</span>;  <span class="comment">// this is to remove the duplicates - genius!!</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// same as before, backtracking</span></span><br><span class="line">  <span class="keyword">var</span> temp = board[i][j];</span><br><span class="line">  board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">  <span class="keyword">if</span>(i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j ,node, output); </span><br><span class="line">  <span class="keyword">if</span>(j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, node, output);</span><br><span class="line">  <span class="keyword">if</span>(i &lt; board.length - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, node, output); </span><br><span class="line">  <span class="keyword">if</span>(j &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, node, output); </span><br><span class="line">  board[i][j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime: 204 ms</p>
<p>And I beat 100% of js submissions… Compared to previous answer.. it is unbelievable fast…</p>
<h3 id="BTW"><a href="#BTW" class="headerlink" title="BTW"></a>BTW</h3><p>Have you ever heard about the Word-Clock ? It is a beautiful clock using words represent the time instead of the finger and hands… It is gorgeous!!! Why I mention it ? Don’t you feel it is very similiar to what we did in this post ? Word search?</p>
<p>I will try to make a web version of this beautiful watch by using all these words search algorithms :)</p>
<aside class="tipme special"><a href="/blog/tipme" class="tipme">If you like my work, buy me a soda or send me a book ! ^_^</a></aside></section><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><div class="relatedposts sidenav"><h2>Related Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/02/13/oj-oj-gas-station/">OJ Gas station</a></li><li><a href="http://taoalpha.me/blog/2016/01/31/oj-oj-parentheses-problems/">OJ Parentheses Problems 1</a></li><li><a href="http://taoalpha.me/blog/2016/01/30/oj-oj-calculator-problems/">OJ Calculator Problems</a></li><li><a href="http://taoalpha.me/blog/2016/01/26/oj-oj-remove-duplicate-letters/">OJ Remove Duplicate Letters</a></li><li><a href="http://taoalpha.me/blog/2016/01/25/oj-oj-ugly-number-problems/">OJ Ugly Number Problems</a></li></ul></div><aside class="sidenav"><div class="recentposts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/02/13/oj-oj-gas-station/">OJ Gas station</a></li><li><a href="http://taoalpha.me/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/">JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</a></li><li><a href="http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/">Sorting Algorithm in JavaScript - Quicksort and Heap Sort</a></li><li><a href="http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-numbers-1/">OJ LeetCode Numbers 1</a></li></ul></div></aside><div class="comments"><div data-thread-key="2016/01/20/oj-oj-word-search-problems/" data-title="OJ Word Search Problems" data-url="http://taoalpha.me/blog/2016/01/20/oj-oj-word-search-problems/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"taoalpha"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>