<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Sorting Algorithm in JavaScript - Quicksort and Heap Sort | TaoAlpha's Blog</title><meta name="description" content="Here is my new blog based on hexo."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:image" content="http://taoalpha.me/images/newblog.jpg"><meta property="og:description" content="TaoAlpha's hexo Blog"><meta property="og:type" content="website"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"></head><body class="blogpost"><aside class="home-menu"><nav class="home-icon-con upside"></nav><a href="/blog/" class="home-menu-icon brand active">涛</a><a href="/blog/tipme" class="home-menu-icon"><i class="fa fa-1x fa-gratipay"></i></a><a href="javascript:$('.searchbox').focus().css('border', '4px dashed #666');setTimeout(function(){$('.searchbox').focus().css('border', 'none').css('border-bottom', '1px solid #ccc')},1000);" class="home-menu-icon"><i class="fa fa-1x fa-search"></i></a><a href="/blog/puzzle" class="home-menu-icon"><i class="fa fa-1x fa-puzzle-piece"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact"><a href="http://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="http://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="http://taoalpha.me" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="http://douban.com/people/129154019" target="something"><img src="http://img3.douban.com/favicon.ico" alt="douban"></a></div><nav class="home-icon-con downside"><a href="#contribution" class="home-menu-icon makecontribution"><i class="fa fa-pencil fa-1x"></i></a><a id="togglemusic" href="javascript:;" class="home-menu-icon"><i class="fa fa-music fa-1x"></i></a></nav><div id="musicbar"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="40" src=""></iframe></div></aside><div id="contribution" class="hide"><span class="close"></span><input id="sender_mail" type="email" placeholder="Give me your email"><textarea id="contributionContent" name="contribution" cols="30" rows="10" placeholder="Thanks for your contribution!  Now tell me what you want to say: feedback ? advice ? contributions ? Whatever you want ^_^.  I will look at it as soon as I receive it and reply you asap.  "></textarea><input id="sendToMe" type="submit"></div><article id="content"><div id="progressbar"><span class="bg"></span><span class="text"></span></div><section class="entry"><h1 class="entry-title"><a href="http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/" title="Sorting Algorithm in JavaScript - Quicksort and Heap Sort">Sorting Algorithm in JavaScript - Quicksort and Heap Sort</a></h1><div class="meta-top"><a href="http://taoalpha.me"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2016-01-19</span><span class="wordage">6522字</span><span class="readspeed">19 分钟读完</span></div><p>Last time we have finished the four different sorting algorithms including : <a href="http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-1/">insertion sort and selection sort</a>, <a href="http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-2/">bubble sort and merge sort</a>.</p>
<p>Now let’s continue playing with another one or two.</p>
<h2 id="Median_Sort_and_Quicksort"><a href="#Median_Sort_and_Quicksort" class="headerlink" title="Median Sort and Quicksort"></a>Median Sort and Quicksort</h2><h3 id="Median_Sort"><a href="#Median_Sort" class="headerlink" title="Median Sort"></a>Median Sort</h3><p>Similiar with merge sort, we still use divide and conquer, the basic approach for many problems, but what if we use some statistical information about the array that need to be sorted? Like the median of the array.</p>
<p>If we know the median, we can sort the array into 2 distinct subarrays of about half the size: left with all elements smaller than the median, and right with all elements bigger or equal to median. And we keep doing this for all subarrays, finally we will get a sorted array.</p>
<p>That gives us the MEDIAN SORT.</p>
<h3 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h3><p>Median sort is a nice start, but it still has one problem: how to find the the median of an array? Before we atually put our efforts on solving this problem, we should consider about another problem: how about we use some other attributes instead of median? Our purpose is divide the array into two parts, we don’t need them to be the same size. By thinking this way, we may consider choose any value in the array and use this value as a separator and divide the array into subarrays.</p>
<p>This is quicksort, and the value we choose as a separator is called pivot.</p>
<p>Now let’s show the code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = (list,left,right) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> idx;</span><br><span class="line">  <span class="keyword">if</span>(list.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// left and right  must be number, default value :  0 and list.length - 1</span></span><br><span class="line">  left = (left^<span class="number">0</span>) !== left ? <span class="number">0</span> : left</span><br><span class="line">  right = (right^<span class="number">0</span>) !== right ? list.length-<span class="number">1</span> : right</span><br><span class="line"></span><br><span class="line">  <span class="comment">// divide the array from left to right into two subarrays</span></span><br><span class="line">  <span class="comment">// return the index of the separator</span></span><br><span class="line">  idx = partition(list,left,right) </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(left &lt; idx - <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// keep doing quicksort on left subarray until it can not be separated again</span></span><br><span class="line">    quickSort(list,left,idx - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(idx &lt; right)&#123;</span><br><span class="line">    <span class="comment">// keep doing quicksort on right subarray until it can not be separated again</span></span><br><span class="line">    quickSort(list,idx,right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> partition = (list,begin,end) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> pivot = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(tail-head+<span class="number">1</span>)+head), <span class="comment">// random pivot index </span></span><br><span class="line">      pivot_value = list[pivot]; <span class="comment">// pivot value</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// divide into two subarrays using the pivot value with two pointers</span></span><br><span class="line">  <span class="keyword">while</span>(begin &lt;= end)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// skip all 'good' ones in right</span></span><br><span class="line">    <span class="keyword">while</span>(list[end]&gt;pivot_value)&#123;</span><br><span class="line">      end --</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip all 'good' ones in left </span></span><br><span class="line">    <span class="keyword">while</span>(list[begin]&lt;pivot_value)&#123;</span><br><span class="line">      begin ++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap the 'bad' pairs to make them 'good'</span></span><br><span class="line">    <span class="keyword">if</span>(begin &lt;= end)&#123;</span><br><span class="line">      swap(list,begin,end)</span><br><span class="line">      begin ++</span><br><span class="line">      end --</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the separator line</span></span><br><span class="line">  <span class="keyword">return</span> begin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap function</span></span><br><span class="line"><span class="keyword">var</span> swap = (list,first,second) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = list[first]</span><br><span class="line">  list[first] = list[second]</span><br><span class="line">  list[second] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With all comments, the code should be easy to understand.</p>
<p>Quicksort is famous and popular for its speed especially after linux start using it as the default sorting algorithm. Normally, if we know nothing about the distribution of our array and speed is the most important reason you consider about, then use quicksort.</p>
<p>In above example, we choose the pivot randomly. Normally, its good enough for using. But actually there are a lot of strategies and researches on how to choose a good pivot. Like always choose the first or last or middle, or use median, median-of-k…etc But normally, using randomly pivot will give you an average O(nlogn). If you want to learn more about these strategies, just google it :)</p>
<h2 id="Heap_Sort"><a href="#Heap_Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>Before we go to the concept and code, we should know what is a heap:</p>
<blockquote><p>a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.</p>
<p>In a max heap, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.</p>
<footer><strong>WikiPedia</strong><cite><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="external">Heap (data structure) - wikipedia</a></cite></footer></blockquote>
<p>Got any inspirations ? Think this way: Max heap =&gt; the head of the heap is the max of the array. This is true for any max heap, so we remove the max and rebuild a heap with rest elements, we get the second largest… Yeah, you got it ?! :)</p>
<p>Now what we need to do is using array represent the heap which is pretty much a array tree:</p>
<p>for any element with index - idx:</p>
<ul>
<li>left child : idx*2 + 1</li>
<li>right child: idx*2 + 2</li>
</ul>
<p>Show me the code !!!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapSort - here we use max heap</span></span><br><span class="line"><span class="keyword">var</span> heapSort = (list) =&gt; &#123;</span><br><span class="line">  buildHeap(list);  <span class="comment">// now we have the max value</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = list.length-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="comment">// always put max value to the end of the current heap</span></span><br><span class="line">    <span class="comment">// so the end of the array will always be sorted and gradually expanded to the entire array</span></span><br><span class="line">    swap(list,<span class="number">0</span>,i); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// since we change the head of the heap</span></span><br><span class="line">    <span class="comment">// so we need redo the heap to get the new max of the heap</span></span><br><span class="line">    heapify(list,<span class="number">0</span>,i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line">buildHeap(list)&#123;</span><br><span class="line">  <span class="comment">// start from the second last level of the tree which is the parent of the last element</span></span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = mid;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="comment">// make sure every node of the tree is heapify</span></span><br><span class="line">    heapify(list,i,list.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">heapify(list,idx,len)&#123;</span><br><span class="line">  <span class="comment">// len means the number of elements current heap has</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> left = <span class="number">2</span>*idx + <span class="number">1</span>,</span><br><span class="line">      right = <span class="number">2</span>*idx + <span class="number">2</span>,</span><br><span class="line">      largest;  <span class="comment">// temp value to store the index of largest element of this tree unit</span></span><br><span class="line"></span><br><span class="line">  largest = left &lt; len &amp;&amp; list[left] &gt; list[idx] ? left: idx;</span><br><span class="line">  largest = right &lt; len &amp;&amp; list[right] &gt; list[len] ? right : largest;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we have a new largest, swap it and redo heapify to make sure entire heap is correct</span></span><br><span class="line">  <span class="keyword">if</span>(largest !== idx)&#123;</span><br><span class="line">    swap(list,largest,idx)</span><br><span class="line">    heapify(list,largest,len)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// swap function - same as before</span></span><br></pre></td></tr></table></figure>
<p>Heap Sort is really fast, sometimes it is even faster than quicksort since it will guarantee the O(nlogn) even in the worst case. But normally in average case, the quicksort is a little faster.</p>
<h2 id="BTW"><a href="#BTW" class="headerlink" title="BTW"></a>BTW</h2><p>I believe I still have 2 posts for this serie, one will talk about the radix, and the other will be the counting and bucket sort. See ya.</p>
<aside class="tipme special"><a href="/blog/tipme" class="tipme">If you like my work, buy me a soda or send me a book ! ^_^</a></aside></section><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><aside class="sidenav series"><h2>In Serie: Sorting Algorithm in JavaScript<i class="fa fa-arrow-down expand"></i><i class="collapse fa fa-arrow-up"></i></h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/" data-id='null'>JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</a></li><li><a href="http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/" data-id='null' class="current">Sorting Algorithm in JavaScript - Quicksort and Heap Sort</a></li><li><a href="http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-1/" data-id='null'>Sorting Algorithm in JavaScript - Insertion Sort and Selection Sort</a></li><li><a href="http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-2/" data-id='null'>Sorting Algorithm in JavaScript - Bubble Sort and Merge Sort</a></li></ul></aside><div class="relatedposts sidenav"><h2>Related Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/01/11/tech-es6-quiz-with-answer/">ES6 Quiz With Answer</a></li><li><a href="http://taoalpha.me/blog/2015/12/07/tech-my-first-cli-tool-with-nodejs/">First CLI tool with NodeJS</a></li><li><a href="http://taoalpha.me/blog/2015/11/19/tech-preventDefault-and-stopPropagation-in-JS/">preventDefault and stopPropagation in JS</a></li><li><a href="http://taoalpha.me/blog/2015/11/11/tech-use-strict-in-js/">Strict Mode in JavaScript</a></li><li><a href="http://taoalpha.me/blog/2015/11/06/tech-es6-general-summary/">ES6 General Summary</a></li></ul></div><aside class="sidenav"><div class="recentposts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/01/23/tech-feedpusher-pre-release/">FeedPusher Pre-Alpha-Release</a></li><li><a href="http://taoalpha.me/blog/2016/01/13/oj-oj-leetcode-nsum/">OJ LeetCode NSum Problem</a></li><li><a href="http://taoalpha.me/blog/2016/01/12/tech-dynamic-scheduling-crawler-for-feedpusher/">Dynamic scheduling crawler for FeedPusher</a></li><li><a href="http://taoalpha.me/blog/2016/01/11/tech-es6-quiz-with-answer/">ES6 Quiz With Answer</a></li><li><a href="http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/">Scalable and Modular Architecture for CSS</a></li></ul></div></aside><div class="comments"><div data-thread-key="2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/" data-title="Sorting Algorithm in JavaScript - Quicksort and Heap Sort" data-url="http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"taoalpha"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>