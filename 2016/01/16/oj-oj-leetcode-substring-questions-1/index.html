<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OJ LeetCode Substring Questions 1 | TaoAlpha's Blog</title><meta name="description" content="Here is my new blog based on hexo."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:image" content="http://taoalpha.me/images/newblog.jpg"><meta property="og:description" content="TaoAlpha's hexo Blog"><meta property="og:type" content="website"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"></head><body class="blogpost"><aside class="home-menu"><nav class="home-icon-con upside"></nav><a href="/blog/" class="home-menu-icon brand active">涛</a><a href="/blog/tipme" class="home-menu-icon"><i class="fa fa-1x fa-gratipay"></i></a><a href="javascript:$('.searchbox').focus().css('border', '4px dashed #666');setTimeout(function(){$('.searchbox').focus().css('border', 'none').css('border-bottom', '1px solid #ccc')},1000);" class="home-menu-icon"><i class="fa fa-1x fa-search"></i></a><a href="/blog/puzzle" class="home-menu-icon"><i class="fa fa-1x fa-puzzle-piece"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact"><a href="http://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="http://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="http://taoalpha.me" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="http://douban.com/people/129154019" target="something"><img src="http://img3.douban.com/favicon.ico" alt="douban"></a></div><nav class="home-icon-con downside"><a href="#contribution" class="home-menu-icon makecontribution"><i class="fa fa-pencil fa-1x"></i></a><a id="togglemusic" href="javascript:;" class="home-menu-icon"><i class="fa fa-music fa-1x"></i></a></nav><div id="musicbar"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="40" src=""></iframe></div></aside><div id="contribution" class="hide"><span class="close"></span><input id="sender_mail" type="email" placeholder="Give me your email"><textarea id="contributionContent" name="contribution" cols="30" rows="10" placeholder="Thanks for your contribution!  Now tell me what you want to say: feedback ? advice ? contributions ? Whatever you want ^_^.  I will look at it as soon as I receive it and reply you asap.  "></textarea><input id="sendToMe" type="submit"></div><article id="content"><div id="progressbar"><span class="bg"></span><span class="text"></span></div><section class="entry"><h1 class="entry-title"><a href="http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-substring-questions-1/" title="OJ LeetCode Substring Questions 1">OJ LeetCode Substring Questions 1</a></h1><div class="meta-top"><a href="http://taoalpha.me"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2016-01-16</span><span class="wordage">6804字</span><span class="readspeed">20 分钟读完</span></div><h2 id="3-_Longest_Substring_Without_Repeating_Characters"><a href="#3-_Longest_Substring_Without_Repeating_Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">3. Longest Substring Without Repeating Characters</a></cite></footer></blockquote>
<p>Tags: Medium, String, Two Pointers, Hash Table</p>
<h3 id="Answers"><a href="#Answers" class="headerlink" title="Answers"></a>Answers</h3><h4 id="Hash_Table"><a href="#Hash_Table" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>At first, my idea is use a hashmap as a view window to tract all the letters of current substring, and everytime we found the repeated one, we just move the loop pointer to the last position of this repeated character, and continue looping to the end. But apparently it will cost much more than O(n) for the average case. So then I thought I don’t need the move the loop pointer back, just need a new pointer to indicate the start of the substring, and if I do that, I couldn’t empty the view window which is the hashmap since I will lose tract of the elements between the <code>start and i</code>, so I keep all elements in the hashmap, just make sure every valid repeated character is appeared after the current <code>start</code> pointer.</p>
<p>Here is the code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.length &lt;=<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">var</span> view = &#123;&#125;, <span class="comment">// store the current substring</span></span><br><span class="line">      max = <span class="number">0</span>, <span class="comment">// store the max length</span></span><br><span class="line">      start = <span class="number">0</span> <span class="comment">// store the start of the current substring</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(view[s[i]] &amp;&amp; view[s[i]] &gt; start)&#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max,i-start)</span><br><span class="line">      <span class="comment">// now we have a repeated element appeared in current substring</span></span><br><span class="line">      start = view[s[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    view[s[i]] = i+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// in case no repeated element in this string</span></span><br><span class="line">  max = <span class="built_in">Math</span>.max(max,i-start)</span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 376 ms</p>
<h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>This method is borrow from the discussion <a href="https://leetcode.com/discuss/13336/shortest-o-n-dp-solution-with-explanations" target="_blank" rel="external">shortest O(n) DP solution with explanations</a>. More concise!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Solution (DP, O(n)):</span><br><span class="line"> * </span><br><span class="line"> * Assume L[i] = s[m...i], denotes the longest substring without repeating</span><br><span class="line"> * characters that ends up at s[i], and we keep a hashmap for every</span><br><span class="line"> * characters between m ... i, while storing &lt;character, index&gt; in the</span><br><span class="line"> * hashmap.</span><br><span class="line"> * We know that each character will appear only once.</span><br><span class="line"> * Then to find s[i+1]:</span><br><span class="line"> * 1) if s[i+1] does not appear in hashmap</span><br><span class="line"> *    we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1]</span><br><span class="line"> * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k</span><br><span class="line"> *    let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update</span><br><span class="line"> *    entry in hashmap to mark the latest occurency of s[i+1].</span><br><span class="line"> * </span><br><span class="line"> * Since we scan the string for only once, and the 'm' will also move from</span><br><span class="line"> * beginning to end for at most once. Overall complexity is O(n).</span><br><span class="line"> *</span><br><span class="line"> * If characters are all in ASCII, we could use array to mimic hashmap.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> charIndex = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> longest = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    m = <span class="built_in">Math</span>.max((<span class="keyword">typeof</span> charIndex[s[i]] === <span class="string">"undefined"</span> ? -<span class="number">1</span>:charIndex[s[i]]) + <span class="number">1</span>, m);    <span class="comment">// automatically takes care of -1 case</span></span><br><span class="line">    charIndex[s[i]] = i;</span><br><span class="line">    longest = <span class="built_in">Math</span>.max(longest, i - m + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime: 376</p>
<h2 id="5-_Longest_Palindromic_Substring"><a href="#5-_Longest_Palindromic_Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="external">5. Longest Palindromic Substring</a></cite></footer></blockquote>
<p>Tags: Medium, String</p>
<h3 id="Answers-1"><a href="#Answers-1" class="headerlink" title="Answers"></a>Answers</h3><h4 id="two_pointers"><a href="#two_pointers" class="headerlink" title="two pointers"></a>two pointers</h4><p>We need to take advantage of the features of the palindrom: xxx|xxx which is start from the separator, it is symetric.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> s</span><br><span class="line">  <span class="keyword">var</span> start = <span class="number">0</span>,end = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;s.length;)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length - i &lt;= (end-start+<span class="number">1</span>)/<span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">// if the number of elements left is less than half of length of current longest palindrome, then we can break safely</span></span><br><span class="line">    <span class="keyword">var</span> left = i, right = i; <span class="comment">// left is from separator to left; vice versa for right</span></span><br><span class="line">    <span class="comment">// skil the duplicate number, set all duplicate numbers as the separator of the palindrom since duplicate numbers definitely are palindrom </span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length - <span class="number">1</span> &amp;&amp; s[right] == s[right+<span class="number">1</span>]) right ++ ;</span><br><span class="line">    <span class="comment">// update the i to the right next to right, no need to loop the duplicate number</span></span><br><span class="line">    i = right + <span class="number">1</span></span><br><span class="line">    <span class="comment">// now expand the left and right, try to enlarge the palindrom</span></span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length - <span class="number">1</span> &amp;&amp; left &gt;<span class="number">0</span> &amp;&amp; s[left-<span class="number">1</span>] == s[right+<span class="number">1</span>])&#123;</span><br><span class="line">      <span class="comment">// be careful about the condition in there: use &lt; and &gt; because maybe have 'bbb', so the s[left-1] and s[right+1] both are undefined, and they are equal...</span></span><br><span class="line">      left --</span><br><span class="line">      right ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update the longest if it is</span></span><br><span class="line">    <span class="keyword">if</span>((right - left +<span class="number">1</span>) &gt; (end - start))&#123;</span><br><span class="line">      start = left</span><br><span class="line">      end = right + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.slice(start,end)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runtime: 164 ms</p>
<h4 id="Brute_Force_Check"><a href="#Brute_Force_Check" class="headerlink" title="Brute Force Check"></a>Brute Force Check</h4><p>Basic idea is loop over entire string, and everytime we loop to a new character, we check whether it would produce new palindrome of (current length + 1) or (current length + 2). From <a href="https://leetcode.com/discuss/52814/ac-relatively-short-and-very-clear-java-solution" target="_blank" rel="external">this post</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">  <span class="keyword">var</span> subs = <span class="string">''</span>, currentLength = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isPalindrome(s,i-currentLength-<span class="number">1</span>,i))&#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      subs = s.slice(i-currentLength-<span class="number">1</span>,i+<span class="number">1</span>)</span><br><span class="line">      currentLength += <span class="number">2</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isPalindrome(s,i-currentLength,i))&#123;</span><br><span class="line">      subs = s.slice(i-currentLength,i+<span class="number">1</span>)</span><br><span class="line">      currentLength += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isPalindrome(s,begin,end) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(begin&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[begin++] !== s[end--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime: 188 ms</p>
<p>And the detail explanations:</p>
<blockquote>
<p>Example: “xxxbcbxxxxxa”, (x is random character, not all x are equal) now we are dealing with the last character ‘a’. The current longest palindrome is “bcb” with length 3.</p>
<ol>
<li>check “xxxxa” so if it is palindrome we could get a new palindrome of length 5.</li>
<li>check “xxxa” so if it is palindrome we could get a new palindrome of length 4.</li>
<li>do NOT check “xxa” or any shorter string since the length of the new string is no bigger than current longest length.</li>
<li>do NOT check “xxxxxa” or any longer string because if “xxxxxa” is palindrome then “xxxx” got  from cutting off the head and tail is also palindrom. It has length &gt; 3 which is impossible.’</li>
</ol>
</blockquote>
<p>Really smart!!!</p>
<aside class="tipme special"><a href="/blog/tipme" class="tipme">If you like my work, buy me a soda or send me a book ! ^_^</a></aside></section><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><div class="relatedposts sidenav"><h2>Related Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-numbers-1/">OJ LeetCode Numbers 1</a></li><li><a href="http://taoalpha.me/blog/2016/01/13/oj-oj-leetcode-nsum/">OJ LeetCode NSum Problem</a></li><li><a href="http://taoalpha.me/blog/2016/01/06/oj-oj-leetcode-sort-3/">OJ LeetCode Sort 3</a></li><li><a href="http://taoalpha.me/blog/2016/01/05/oj-oj-leetcode-sort-2/">OJ LeetCode Sort 2</a></li><li><a href="http://taoalpha.me/blog/2016/01/04/oj-oj-leetcode-sort-1/">OJ LeetCode Sort 1</a></li></ul></div><aside class="sidenav"><div class="recentposts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/">JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</a></li><li><a href="http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/">Scalable and Modular Architecture for CSS</a></li><li><a href="http://taoalpha.me/blog/2016/01/09/read-javascript-coding-style/">JavaScript Coding Style</a></li><li><a href="http://taoalpha.me/blog/2016/01/06/oj-oj-leetcode-sort-3/">OJ LeetCode Sort 3</a></li><li><a href="http://taoalpha.me/blog/2016/01/05/oj-oj-leetcode-sort-2/">OJ LeetCode Sort 2</a></li></ul></div></aside><div class="comments"><div data-thread-key="2016/01/16/oj-oj-leetcode-substring-questions-1/" data-title="OJ LeetCode Substring Questions 1" data-url="http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-substring-questions-1/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"taoalpha"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>