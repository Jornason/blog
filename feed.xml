<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TaoAlpha's Blog</title><link>http://taoalpha.me/blog</link><pubDate>2016-01-19T02:20:35.999Z</pubDate><description></description><language>en</language><generator>hexo</generator><item> <title>Sorting Algorithm in JavaScript - Quicksort and Heap Sort</title><link>http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2016-01-19T05:33:27.000Z</pubDate><description>Last time we have finished the four different sorting algorithms including : insertion sort and selection sort, bubble sort and merge sort.
Now let’s continue playing with another one or two.
Median Sort and QuicksortMedian SortSimiliar with merge sort, we still use divide and conquer, the basic approach for many problems, but what if we use some statistical information about the array that need to be sorted? Like the median of the array.
If we know the median, we can sort the array into 2 distinct subarrays of about half the size: left with all elements smaller than the median, and right with all elements bigger or equal to median. And we keep doing this for all subarrays, finally we will get a sorted array.
That gives us the MEDIAN SORT.
QuicksortMedian sort is a nice start, but it still has one problem: how to find the the median of an array? Before we atually put our efforts on solving this problem, we should consider about another problem: how about we use some other attributes instead of median? Our purpose is divide the array into two parts, we don’t need them to be the same size. By thinking this way, we may consider choose any value in the array and use this value as a separator and divide the array into subarrays.
This is quicksort, and the value we choose as a separator is called pivot.
Now let’s show the code:
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var quickSort = (list,left,right) =&amp;gt; &amp;#123;  var idx;  if(list.length &amp;lt;= 1)&amp;#123;    return list  &amp;#125;  // left and right  must be number, default value :  0 and list.length - 1  left = (left^0) !== left ? 0 : left  right = (right^0) !== right ? list.length-1 : right  // divide the array from left to right into two subarrays  // return the index of the separator  idx = partition(list,left,right)   if(left &amp;lt; idx - 1)&amp;#123;    // keep doing quicksort on left subarray until it can not be separated again    quickSort(list,left,idx - 1)  &amp;#125;  if(idx &amp;lt; right)&amp;#123;    // keep doing quicksort on right subarray until it can not be separated again    quickSort(list,idx,right)  &amp;#125;  return list&amp;#125;var partition = (list,begin,end) =&amp;gt; &amp;#123;  var pivot = Math.floor(Math.random()*(tail-head+1)+head), // random pivot index       pivot_value = list[pivot]; // pivot value  // divide into two subarrays using the pivot value with two pointers  while(begin &amp;lt;= end)&amp;#123;        // skip all 'good' ones in right    while(list[end]&amp;gt;pivot_value)&amp;#123;      end --    &amp;#125;    // skip all 'good' ones in left     while(list[begin]&amp;lt;pivot_value)&amp;#123;      begin ++    &amp;#125;    // swap the 'bad' pairs to make them 'good'    if(begin &amp;lt;= end)&amp;#123;      swap(list,begin,end)      begin ++      end --    &amp;#125;  &amp;#125;  // return the separator line  return begin&amp;#125;// swap functionvar swap = (list,first,second) =&amp;gt; &amp;#123;  var temp = list[first]  list[first] = list[second]  list[second] = temp&amp;#125;
With all comments, the code should be easy to understand.
Quicksort is famous and popular for its speed especially after linux start using it as the default sorting algorithm. Normally, if we know nothing about the distribution of our array and speed is the most important reason you consider about, then use quicksort.
In above example, we choose the pivot randomly. Normally, its good enough for using. But actually there are a lot of strategies and researches on how to choose a good pivot. Like always choose the first or last or middle, or use median, median-of-k…etc But normally, using randomly pivot will give you an average O(nlogn). If you want to learn more about these strategies, just google it :)
Heap SortBefore we go to the concept and code, we should know what is a heap:
a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.
In a max heap, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.
WikiPediaHeap (data structure) - wikipedia
Got any inspirations ? Think this way: Max heap =&amp;gt; the head of the heap is the max of the array. This is true for any max heap, so we remove the max and rebuild a heap with rest elements, we get the second largest… Yeah, you got it ?! :)
Now what we need to do is using array represent the heap which is pretty much a array tree:
for any element with index - idx:

left child : idx*2 + 1
right child: idx*2 + 2

Show me the code !!!
123456789101112131415161718192021222324252627282930313233343536373839// heapSort - here we use max heapvar heapSort = (list) =&amp;gt; &amp;#123;  buildHeap(list);  // now we have the max value  for(var i = list.length-1;i&amp;gt;=1;i--)&amp;#123;    // always put max value to the end of the current heap    // so the end of the array will always be sorted and gradually expanded to the entire array    swap(list,0,i);     // since we change the head of the heap    // so we need redo the heap to get the new max of the heap    heapify(list,0,i);   &amp;#125;  return list&amp;#125;buildHeap(list)&amp;#123;  // start from the second last level of the tree which is the parent of the last element  var mid = Math.floor(list.length / 2) - 1;  for(var i = mid;i&amp;gt;=0;i--)&amp;#123;    // make sure every node of the tree is heapify    heapify(list,i,list.length)  &amp;#125;&amp;#125;heapify(list,idx,len)&amp;#123;  // len means the number of elements current heap has  var left = 2*idx + 1,      right = 2*idx + 2,      largest;  // temp value to store the index of largest element of this tree unit  largest = left &amp;lt; len &amp;amp;&amp;amp; list[left] &amp;gt; list[idx] ? left: idx;  largest = right &amp;lt; len &amp;amp;&amp;amp; list[right] &amp;gt; list[len] ? right : largest;  // if we have a new largest, swap it and redo heapify to make sure entire heap is correct  if(largest !== idx)&amp;#123;    swap(list,largest,idx)    heapify(list,largest,len)  &amp;#125;&amp;#125;// swap function - same as before
Heap Sort is really fast, sometimes it is even faster than quicksort since it will guarantee the O(nlogn) even in the worst case. But normally in average case, the quicksort is a little faster.
BTWI believe I still have 2 posts for this series, one will talk about the radix, and the other will be the counting and bucket sort. See ya.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Insertion Sort and Selection Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-1/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2015-10-29T05:00:00.000Z</pubDate><description>Sorting AlgorithmAs the most important and fundamental algorithm, sorting algorithm is always the best start to learn algorithm.
Among all the different sorting algorithms, we have 10 algorithms which are used a lot in practice, and I will introduce all these ten algorithms one by one. 
Today we will talk about: Selection Sort and Insertion Sort.
Selection SortSelection Sort is one of the most fundamental sort algorithms you would learn from any book about algorithm. The method and theory based on is really easy and clear:

input: a list of numbers need to be sorted
procedures:
create a new list to save the sorted elements
select the minimum element from the input list and push it into the new list, and remove it from the input list
repeat the second step until we don’t have any more elements in input list


output: the list you created to save the sorted elements

Easy, huh ? Let’s calculate the cost: the average time complexity would be n^2/2 which would be O(n^2), since we need check the input list n times with n/2 elements to check every time; and since we are using a new list to save the output, it would be O(n) space.
Can we optimize it ? Yes and no. For time complexity, we can not do any optimization since it is the theory that selection sort is using, we have nothing to do with that. But for space complexity, we can do something.
We can actually do the sort in-place which means we can sort the list within the list and return the same list as the input except it is sorted.
In order to do that, we can change the procedures to:

input: a list of numbers need to be sorted
procedures:
start from the first element, we loop over the list from it to the end of the list and select the minimum element from the input list and swap it with it(start element);
repeat it until we reach the last element of the input list(now the start element and the end element would all be the last element)


output: the input list 

By doing this way, we just need two spaces, one is used to save the index of the minimum element, another is used during the swap to save the one of the value that need to be swapped later. The space complexity would be O(1).
1234567891011121314function selectionSort(list)&amp;#123;    for(var i = 0; i &amp;lt; list.length; i++)&amp;#123;      var min = i      for(var j = i+1;j&amp;lt;list.length; j++)&amp;#123;        if(list[min]&amp;gt;list[j])&amp;#123;          min = j        &amp;#125;      &amp;#125;      var temp = list[i]      list[i] = list[min]      list[min] = temp    &amp;#125;    return list  &amp;#125;
Selection Sort is easy but not efficient, since it always costs O(n^2) even your input list is sorted when you pass it in.
Insertion SortNow we come to insertion sort which would a little more efficient than selection sort.
The theory is: consider the left part of the input list as sorted, and insert the new element into the proper position, since if one element always means it is sorted, so we always can do that by starting from the second element.
The procedures:

start from the second element(if you don’t have second element, you are done);
compare every element in the left(sorted part), if it is greater than your start element, shift it to the right by 1, if it is less than your start element, insert your start element before it;
repeat until the end of the list;

Time Complexity: O(n) in the best case(the list is sorted already), O(n^2) in the worst case, on average, it would be similiar to selection sort with O(n^2).
Space Complexity: O(1)
Lets implement it into real code:
1234567891011121314function insertionSort(list)&amp;#123;  for(var i = 1; i &amp;lt; list.length;i++)&amp;#123;    var temp = list[i]    var j = i    while(j&amp;gt;0 &amp;amp;&amp;amp; list[j-1]&amp;gt;temp)&amp;#123;      list[j] = list[j-1]      j--    &amp;#125;    list[j] = temp    // use shift instead of swap can reduce the cost of writing -- nearly 50%    // if you use swap, it will slower than selectionSort  &amp;#125;  return list&amp;#125;
Some people may be used to achieve insertion sort by using the swap too. You can, you just need compare and swap it with previous one until it reaches the right position. But the cost would be high since you will double your writes with swap.

I actually calculate the time cost in javascript, most of time, if you use swap, your insertion sort would be slower than selection sort.

Special NoteIn general, insertion sort would be faster than selection sort if you implement it in right way. But in some special cases, you may find selection sort is faster.
The different between selection sort and insertion sort:

selection sort reads the list a lot(n  (n+1) / 2, n is the length of the list) but only writes into the list a few times(= 2  (the length of your list));
insertion sort reads the list a lot too, but fewer than the selection sort(the worst case would be same with selection, best case would be equal to the length of the list), and meantime, it will write into the list much more times than selection sort(nearly the same with reading times);

So if it costs much more on reading instead of writing, you may consider choosing selection sort instead of insertion sort.
SummaryThat’s all I think you should know about selection sort and insertion sort. Next post I will discuss about bubble sort and merge sort with you. See ya!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Bubble Sort and Merge Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-2/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2015-10-29T08:00:00.000Z</pubDate><description>IntroductionBubble sort is really cool but not so useful, it seems that you will never use it… But merge sort is really cool since it is really fast.
Bubble SortSo what is bubble sort, according to wikipedia:

Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. 

The whole process of sorting is like the bigger element “bubble” to the end of the list.

Input: A list of numbers with random order
Procedures:
Start from the head of the list, and compare every two adjacent numbers and swap them if they are in wrong order;
Record whether you did any swaps or not, if no, your list has been sorted, otherwise, you need to step 1 again;


Output: A sorted list

If you like, you can do a small optimization to the procedures above: since every iteration we will make sure the bigger element will “bubble” to the end of the list, so everytime we don’t need to check the last elements(they are already in ordered), and we will reduce the length for each iteration.
Here is a nice gif from wikipedia: 
The time complexity for bubble sort would be : O(n^2) for worst case, O(n) for best case, and O(n^2) on average.
The space complexity for bubble sort would be O(1) since we only need one space used to do the swap.
Now lets do the code:
1234567891011121314151617181920// bubbleSortfunction bubbleSort(list)&amp;#123;  var swapped  var len = list.length  do&amp;#123;    swapped = false    for(var j = 0;j&amp;lt; len-1;j++)&amp;#123;      reads += 2      if(list[j]&amp;gt;list[j+1])&amp;#123;        this.swap(list,j,j+1)        swapped = true        writes += 2      &amp;#125;    &amp;#125;    len = len - 1    // since everytime we will move the largest element to the end of the list, we can reduce the number of iteration without considering the last element every iteration  &amp;#125;while(swapped)  return list&amp;#125;
Merge SortNow we met all three different kinds of sorting, all of them have a O(n^2) of time complexity on average.
Lets do something faster: Merge Sort.
Imagine you separate your list into several really small lists with only one element or zero element in each of them. Then you merge every two small lists into one sorted list, and keep doing it repeatly.(it’s easy because you are merging two sorted lists)
The whole procedures will be:

Split the list recursively;
Merge the small lists until you merge them all;

Since we always split by half, the number of small lists we will have would be log(n), and the total cost would be close to (n / 2 * log(n)) on average(since we have at least 1 element list to merge with zero one, at most n/2 elements list to merge with n/2 elements). So the time complexity would be O(nlog(n)) all the time, and the space complexity would be O(n) since we will save origin input list with n small lists.
1234567891011121314151617181920// mergeSortfunction mergeSort(list)&amp;#123;  if(list.length &amp;lt;= 1) return list  var mid = Math.floor(list.length / 2)  return merge(mergeSort(list.slice(0,mid)),mergeSort(list.slice(mid)))&amp;#125;function merge(left,right)&amp;#123;  var nl = []  var il = 0, ir = 0  while(il&amp;lt;left.length &amp;amp;&amp;amp; ir&amp;lt;right.length)&amp;#123;    if(left[il] &amp;lt; right[ir])&amp;#123;      nl.push(left[il++])    &amp;#125;else&amp;#123;      nl.push(right[ir++])    &amp;#125;    // don't use shift because shift will actually cause a lot I/Os   &amp;#125;  nl = nl.concat(left.slice(il)).concat(right.slice(ir))  return nl&amp;#125;
SummaryMerge sort is kind useful, and if we don’t have quick sort which I will talk about next post, it would be a really good choice to do sorting. And even we have quick sort, merge sort still exists in many languages as part of their default sorting algorithm.
And also there are several optimizations for merge sort, if you are interested in, you can search it on google.
That’s all for today. Good night!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Substring Questions 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-substring-questions-1/</link><category>OJ</category><tag>LeetCode,Substring</tag><pubDate>2016-01-16T06:52:31.000Z</pubDate><description>3. Longest Substring Without Repeating CharactersQuestionGiven a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.
LeetCode3. Longest Substring Without Repeating Characters
Tags: Medium, String, Two Pointers, Hash Table
AnswersHash TableAt first, my idea is use a hashmap as a view window to tract all the letters of current substring, and everytime we found the repeated one, we just move the loop pointer to the last position of this repeated character, and continue looping to the end. But apparently it will cost much more than O(n) for the average case. So then I thought I don’t need the move the loop pointer back, just need a new pointer to indicate the start of the substring, and if I do that, I couldn’t empty the view window which is the hashmap since I will lose tract of the elements between the start and i, so I keep all elements in the hashmap, just make sure every valid repeated character is appeared after the current start pointer.
Here is the code:
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  if(s.length &amp;lt;=0)&amp;#123;return 0&amp;#125;  var view = &amp;#123;&amp;#125;, // store the current substring      max = 0, // store the max length      start = 0 // store the start of the current substring  for(var i = 0;i&amp;lt;s.length;i++)&amp;#123;    if(view[s[i]] &amp;amp;&amp;amp; view[s[i]] &amp;gt; start)&amp;#123;      max = Math.max(max,i-start)      // now we have a repeated element appeared in current substring      start = view[s[i]]    &amp;#125;    view[s[i]] = i+1  &amp;#125;  // in case no repeated element in this string  max = Math.max(max,i-start)  return max&amp;#125;;
Runtime: 376 ms
DPThis method is borrow from the discussion shortest O(n) DP solution with explanations. More concise!
12345678910111213141516171819202122232425262728293031323334353637/** * Solution (DP, O(n)): *  * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &amp;lt;character, index&amp;gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap *    we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k *    let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update *    entry in hashmap to mark the latest occurency of s[i+1]. *  * Since we scan the string for only once, and the 'm' will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. *//** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  var charIndex = &amp;#123;&amp;#125;  var longest = 0, m = 0;  for (var i = 0; i &amp;lt; s.length; i++) &amp;#123;    m = Math.max((typeof charIndex[s[i]] === &quot;undefined&quot; ? -1:charIndex[s[i]]) + 1, m);    // automatically takes care of -1 case    charIndex[s[i]] = i;    longest = Math.max(longest, i - m + 1);  &amp;#125;  return longest;&amp;#125;
Runtime: 376
5. Longest Palindromic SubstringQuestionGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
LeetCode5. Longest Palindromic Substring
Tags: Medium, String
Answerstwo pointersWe need to take advantage of the features of the palindrom: xxx|xxx which is start from the separator, it is symetric.
12345678910111213141516171819202122232425262728/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s  var start = 0,end = 1;  for(var i = 0;i&amp;lt;s.length;)&amp;#123;    if(s.length - i &amp;lt;= (end-start+1)/2) break; // if the number of elements left is less than half of length of current longest palindrome, then we can break safely    var left = i, right = i; // left is from separator to left; vice versa for right    // skil the duplicate number, set all duplicate numbers as the separator of the palindrom since duplicate numbers definitely are palindrom     while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; s[right] == s[right+1]) right ++ ;    // update the i to the right next to right, no need to loop the duplicate number    i = right + 1    // now expand the left and right, try to enlarge the palindrom    while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; left &amp;gt;0 &amp;amp;&amp;amp; s[left-1] == s[right+1])&amp;#123;      // be careful about the condition in there: use &amp;lt; and &amp;gt; because maybe have 'bbb', so the s[left-1] and s[right+1] both are undefined, and they are equal...      left --      right ++    &amp;#125;    // update the longest if it is    if((right - left +1) &amp;gt; (end - start))&amp;#123;      start = left      end = right + 1    &amp;#125;  &amp;#125;  return s.slice(start,end)&amp;#125;;
Runtime: 164 ms
Brute Force CheckBasic idea is loop over entire string, and everytime we loop to a new character, we check whether it would produce new palindrome of (current length + 1) or (current length + 2). From this post
123456789101112131415161718192021222324252627/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s;  var subs = '', currentLength = 1;  for(var i = 1;i&amp;lt;s.length;i++)&amp;#123;    if(isPalindrome(s,i-currentLength-1,i))&amp;#123;      //       subs = s.slice(i-currentLength-1,i+1)      currentLength += 2    &amp;#125;else if(isPalindrome(s,i-currentLength,i))&amp;#123;      subs = s.slice(i-currentLength,i+1)      currentLength += 1    &amp;#125;  &amp;#125;  return subs&amp;#125;var isPalindrome(s,begin,end) =&amp;gt; &amp;#123;  if(begin&amp;lt;0) return false;  while(begin &amp;lt; end)&amp;#123;    if(s[begin++] !== s[end--]) return false;  &amp;#125;  return true&amp;#125;
Runtime: 188 ms
And the detail explanations:

Example: “xxxbcbxxxxxa”, (x is random character, not all x are equal) now we are dealing with the last character ‘a’. The current longest palindrome is “bcb” with length 3.

check “xxxxa” so if it is palindrome we could get a new palindrome of length 5.
check “xxxa” so if it is palindrome we could get a new palindrome of length 4.
do NOT check “xxa” or any shorter string since the length of the new string is no bigger than current longest length.
do NOT check “xxxxxa” or any longer string because if “xxxxxa” is palindrome then “xxxx” got  from cutting off the head and tail is also palindrom. It has length &amp;gt; 3 which is impossible.’


Really smart!!!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Numbers 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-numbers-1/</link><category>OJ</category><tag>LeetCode,Numbers</tag><pubDate>2016-01-17T02:22:20.000Z</pubDate><description>2. Add Two NumbersQuestionYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)Output: 7 -&amp;gt; 0 -&amp;gt; 8
LeetCode2. Add Two Numbers
Tags: Medium, Linked List, Math
AnswersCommon parts firstThe idea is to add the common parts first and store the carry number produced every round a addition.
Then deal with the remain, just be careful about the carry.
Then if we still have a carry number, create a new node and add it to our result.
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; l1 * @param &amp;#123;ListNode&amp;#125; l2 * @return &amp;#123;ListNode&amp;#125; */var addTwoNumbers = function(l1, l2) &amp;#123;  var head = new ListNode(-1),      cur = head,      carry = 0;  while(l1 &amp;amp;&amp;amp; l2)&amp;#123;    var nodeVal = l1.val + l2.val + carry,node = new ListNode(0);    if(nodeVal &amp;gt;= 10)&amp;#123;      carry = 1      node.val = nodeVal % 10    &amp;#125;else&amp;#123;      carry = 0      node.val = nodeVal    &amp;#125;    cur.next = node    cur = node    l1 = l1.next    l2 = l2.next  &amp;#125;  // deal with the remain  var remain = l1 || l2  while(remain)&amp;#123;    if(remain.val + carry &amp;gt;= 10)&amp;#123;      remain.val = (remain.val + carry) % 10      carry = 1    &amp;#125;else&amp;#123;      remain.val += carry      carry = 0    &amp;#125;    cur.next = remain    cur = cur.next    remain = remain.next  &amp;#125;  // if no remain  if(carry&amp;gt;0)&amp;#123;      var temp = new ListNode(carry)      cur.next = temp  &amp;#125;  return head.next&amp;#125;;
Runtime : 304ms
All in one loopActually you can find that the main logic of our two while loops are the same, we can combine them:
123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; l1 * @param &amp;#123;ListNode&amp;#125; l2 * @return &amp;#123;ListNode&amp;#125; */var addTwoNumbers = function(l1, l2) &amp;#123;  var head = new ListNode(-1),      cur = head,      carry = 0;  while(l1 || l2)&amp;#123;    var l1val = (l1 &amp;amp;&amp;amp; l1.val) || 0    var l2val = (l2 &amp;amp;&amp;amp; l2.val) || 0    var nodeVal = l1val + l2val + carry,node = new ListNode(0);    if(nodeVal &amp;gt;= 10)&amp;#123;      carry = 1      node.val = nodeVal % 10    &amp;#125;else&amp;#123;      carry = 0      node.val = nodeVal    &amp;#125;    cur.next = node    cur = node    l1 = (l1 &amp;amp;&amp;amp; l1.next) || null    l2 = (l2 &amp;amp;&amp;amp; l2.next) || null  &amp;#125;  // if no remain  if(carry&amp;gt;0)&amp;#123;      var temp = new ListNode(carry)      cur.next = temp  &amp;#125;  return head.next&amp;#125;;
Runtime: 320ms
The two methods should be at the same time complexity.
9. Palindrome NumberQuestionDetermine whether an integer is a palindrome. Do this without extra space.
LeetCode9. Palindrome Number
Tags: Easy,Math
AnswersCan not understand what without extra space means… but we can figure out some O(1) space methods…
Head and Tail Comparator1234567891011121314/** * @param &amp;#123;number&amp;#125; x * @return &amp;#123;boolean&amp;#125; */var isPalindrome = function(x) &amp;#123;  if(x&amp;lt;0)&amp;#123;return false&amp;#125;  var numDigits = Math.floor(Math.log10(x)) + 1,i = 1;  while(i&amp;lt;=numDigits/2)&amp;#123;    if( (Math.floor(x % Math.pow(10,numDigits - i+1) / Math.pow(10,numDigits-i))) !=         (Math.floor(x % Math.pow(10,i) / Math.pow(10,i-1))) )&amp;#123; return false &amp;#125;    i += 1  &amp;#125;  return true&amp;#125;;
Runtime: 768 ms
MathIt is not a pure math problem, but if you know math well, you can figure out some way like this:

reduce the x into half
store the reduced half into another number
compair the two

12345678910111213/** * @param &amp;#123;number&amp;#125; x * @return &amp;#123;boolean&amp;#125; */var isPalindrome = function(x) &amp;#123;  if(x&amp;lt;0 || (x !== 0 &amp;amp;&amp;amp; x % 10 == 0)) return false;  var rev = 0; // reverse  while(x&amp;gt;rev)&amp;#123;    rev = rev * 10 + x % 10    x = Math.floor(x / 10)  &amp;#125;  return (x == rev || x == Math.floor(rev/10))&amp;#125;
Runtime: 684 ms
17. Letter Combinations of a Phone NumberQuestionGiven a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below.Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want.
LeetCode17. Letter Combinations of a Phone Number
Tags: Medium, String, Backtracking
AnswersDFS - recursion123456789101112131415161718192021222324/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  // mapper that store all number-letters  var output = []  helper(digits,[],output,mapper)  return output&amp;#125;var helper = (digits,result,output,mapper) =&amp;gt; &amp;#123;  if(digits.length == 0)&amp;#123;    output.push(result.join(''));    return  &amp;#125;  for(var i = 0;i&amp;lt;mapper[digits[0]].length;i++)&amp;#123;    result.push(mapper[digits[0]][i])    helper(digits.slice(1),result,output,mapper)    result.pop()  &amp;#125;&amp;#125;
Runtime: 152 ms
DFS - iteratorSame as before, just use iterator instead of recursion
1234567891011121314151617181920/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  var output = [&quot;&quot;]  for(var i = 0;i&amp;lt;digits.length;i++)&amp;#123;    var x = digits[i]    var temp = []    for(var j = 0;j&amp;lt;mapper[x].length;j++)&amp;#123;      for(var t = 0;t&amp;lt;output.length;t++)&amp;#123;        temp.push(output[t]+mapper[x][j])      &amp;#125;    &amp;#125;    output = temp  &amp;#125;  return output&amp;#125;
Runtime: 156 ms
That’s weird… iterator should be faster than recursion… maybe just so few test cases can not test the real difference between these two …
BFS - iteratorIf we consider previous one as a DFS method, then we can use BFS solve it too. Basic idea is the length of each the combination in our final output should be equal to the length of digits. And for every iteration, we use a new digit, and we also need to add every letters this digit represents to every existed combinations we have.
For example: ‘23’
initial =&amp;gt; [‘’]‘2’ =&amp;gt; [‘a’,’b’,’c’]// now add each element of ‘def’ to each of these three string‘3’ =&amp;gt; [‘cd’,’ce’,’cf’,’bd’,’be’,’bf’,’ad’,’ae’,’af’]
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  var output = [&quot;&quot;]  for(var i = 0;i&amp;lt;digits.length;i++)&amp;#123;    var x = digits[i]    while(output[output.length-1].length == i)&amp;#123;      // the length of every combination in the output should be equal to the the number of digits we used      var t = output.pop()      for(var j = 0;j&amp;lt;mapper[x].length;j++)&amp;#123;        output.unshift(t+mapper[x][j])        // need to use unshift since we need add the new letter to every existed element in the output      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
Runtime: 140 ms
That’s it ^_^
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Blur on Background</title><link>http://taoalpha.me/blog/2015/12/31/tech-blur-on-background/</link><category>tech</category><tag>Blur,CSS3</tag><pubDate>2015-12-31T08:09:10.000Z</pubDate><description>Today I finally made my first angularJS app which is a simple todo app connected with my First nodejs cli tool: baby. They share the same data set, so you can think it as the UI for baby todo part (I will build the UI for other nice features, one by one).
I really like the interface of the Papaly, especially the speed dial dashboard !! So I also use a large image and the crystal blur block on my design, here I just want to share something with you :)
BlurBlur is quite popular in Web Design, you can see them all the time. But how we do that from the point of coding part ? Before CSS3 introduced the filter, people just modify the images manually and make them blur before actually use them in the design, and now we have CSS3, we can just use filter.
We all know make a image blur is pretty simple, but how we make part of image blur, and even more, how we make part of image blur be dynamic ? This is what I gonna talk about today :)
Without CSS3Let’s do it old fashion first. You want create a box within which all background image should be blur, and also the box may move to any place or even can be moved by users. How to do that? Quite simple, we can use two images, one is normal, the other is blur one. 
Then what you should know is background-attachment which adds the magic.
12345678910111213141516171819202122232425262728293031323334353637383940/* background-attachment can specify the position of the background image * fixed : the background is fixed with regard to the viewport, so it won't move with the element * background-attachment: fixed; * background-size:100%; * keep size 100% to fit the viewprot */html,body&amp;#123;  width:100%;  height:100%;  margin:0px;&amp;#125;.imgBlur&amp;#123;  width:100%;  height:100%;  margin:auto;  background-image:url(&quot;http://www166.lunapic.com/editor/premade/o-blur.gif&quot;);// image without blur  background-size:100%;&amp;#125;div.blurBox&amp;#123;  width:50%;  margin:auto;  height:200px;  color:white;  padding:30px;  text-align:center;  display:table;&amp;#125;div.blurBox.withoutcss3&amp;#123;  background-attachment:fixed;  background-size:100%;  background-image:url(http://www166.lunapic.com/editor/premade/blur.gif);// image with blur   display:none;&amp;#125;.blurBox span&amp;#123;  display:table-cell;  vertical-align:middle;&amp;#125;
With CSS3With CSS3, we don’t need the second image, we can just use blur.
123456789101112131415161718192021/* z-index is to make sure the content of the box won't be blur */div.blurBox.withcss3&amp;#123;  z-index:1;&amp;#125;div.blurBox.withcss3:before&amp;#123;  width:100%;  display:block;  content:&quot; &quot;;  height:100%;  background-image:url(http://www166.lunapic.com/editor/premade/o-blur.gif);  // now we don't need blur image  background-attachment:fixed;  // still need this since we need use the blur on the image  position: absolute;  background-size:100%;   -webkit-filter: blur(3px);  filter:blur(3px);  z-index:-1;&amp;#125;
Here is the demo I made with codepen:
See the Pen LGbajd by taoalpha (@taoalpha) on CodePen.


Advance SkillsPretty cool ha! Combine with before and after and other cool stuffs,  you can achieve a lot amazing effects, even this one : Depth of field effect with SVG filters
See the Pen Depth of field effect with SVG filters by Vaughan Curd (@vcurd) on CodePen.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Add a reading progressbar to your blog</title><link>http://taoalpha.me/blog/2016/01/16/tech-add-a-reading-progressbar-to-your-blog/</link><category>tech</category><tag>JS,progressbar</tag><pubDate>2016-01-16T21:37:42.000Z</pubDate><description>Yesterday, I added airbnb blog to my subscriptions, and found an interesting feature on this blog: when you scroll down, there will be a progressbar on the top of the page showing the progress of your reading on this post. So I just added it to my blog :)
Actually the logic is pretty simple, you calculate the distance you have scroll down, and then divided by the height of your post area, fixed with some margins and offset, added some styles and html, you will get your own reading progressbar :) I don’t know whether airbnb using this method or not since I didn’t look their code…
1234567891011121314151617181920212223// with jQuery( () =&amp;gt; &amp;#123;  $(window).scroll( () =&amp;gt; &amp;#123;    // listen to the scroll event    if(window.scrollY &amp;gt; 220)&amp;#123;      // the distance between the top of the document and start of your post area, only show when you actually start reading :)      var percentage = Math.ceil( ( (window.scrollY - 200 + $(window).height()) / $('section.entry').height() )*100 )      // calculate the percentage of reading, here I minus the distance at the top but add the height of your screen to make sure it will hit 100 when scroll down to the bottom      if(percentage&amp;lt;=100)&amp;#123;        // show and update the progressbar        $('div#progressbar').fadeIn(300).find('span.text').text(percentage+&quot;% READ&quot;)        $('div#progressbar').fadeIn(300).find('span.bg').css(&amp;#123;width:percentage+&quot;%&quot;&amp;#125;)      &amp;#125;      // hide it when read 100%      if(percentage &amp;gt;= 100)&amp;#123;        $('div#progressbar').fadeOut(300)      &amp;#125;    &amp;#125;else&amp;#123;      // hide if you scroll up to the top      $('div#progressbar').fadeOut(300)    &amp;#125;  &amp;#125;)&amp;#125;)()
And then you just need a html snippet like this on your post page and add your own styles for them:
1div#progressbar&amp;#10;  span.bg&amp;#10;  span.text
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode NSum Problem</title><link>http://taoalpha.me/blog/2016/01/13/oj-oj-leetcode-nsum/</link><category>OJ</category><tag>HashTable,LeetCode</tag><pubDate>2016-01-14T01:19:20.000Z</pubDate><description>1. Two SumQuestionGiven an array of integers, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution.
Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2
LeetCode1. 2Sum
Tags: Array, Hash Table
AnswersIndexOfBefore we think about hashtable, the more strightforward idea is that we subtract the current number from the target and then check whether the result is in the rest of the list or not.
12345678910111213/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var secondIndexOffset = nums.slice(i+1,nums.length).indexOf(target - nums[i])    if(secondIndexOffset&amp;gt;-1)&amp;#123;      return [i+1,i+secondIndexOffset+2]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 456 ms
Or we use while to save some time:
123456789101112131415/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        return [i+1,j+1]      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 336 ms
hashtableThe previous answer can solve the problem but it is too slow, it is O(n^2) way too slow. We need to speed it up.
Since we can assume each input would have exactly one solution which means that there should not have duplicate number in the nums or the duplicate numbers wouldn’t affect the result, so we can use a hashtable store all the numbers and the index of them to speed up the process.
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var mapper = &amp;#123;&amp;#125;  for(var i =0;i&amp;lt;nums.length;i++)&amp;#123;    mapper[nums[i]] = i+1  &amp;#125;  for(i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var remain = target - nums[i]    if(mapper[remain] &amp;amp;&amp;amp; mapper[remain] -1 !== i)&amp;#123;      return [i+1,mapper[remain]]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 140 ms
Personal Follow Upif we can not assume that each input would have exactly one solution, then how to solve it?
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = []  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(i,j)      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
If we want get all possible and no duplicate combinations(using values instead of indices) of two sum:
1234567891011121314151617181920212223242526272829/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var i = 0, j = nums.length-1  var output = []  nums.sort( (a,b)=&amp;gt; a - b)  while(i&amp;lt;j)&amp;#123;    if(nums[i]+nums[j] == target)&amp;#123;      output.push([nums[i],nums[j]])      i ++      j --      // remove the duplicate values      while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;        i++      &amp;#125;      while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;        j--      &amp;#125;    &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;      j --     &amp;#125;else&amp;#123;      i ++    &amp;#125;  &amp;#125;  return output&amp;#125;
Use hash table:
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = [],nnums = [],amapper = &amp;#123;&amp;#125;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    if(!amapper[nums[i]])&amp;#123;      nnums.push(nums[i])      amapper[nums[i]] = 1    &amp;#125;else&amp;#123;      amapper[nums[i]] ++    &amp;#125;  &amp;#125;  // build the hash of all elements and remove the duplicates  // store all possible combinations  for(var i = 0;i&amp;lt;nnums.length;i++)&amp;#123;    for(var j = i+1;j&amp;lt;nnums.length;j++)&amp;#123;      var sum = nnums[i]+nnums[j]      if(sum == target)&amp;#123;        output.push([nnums[i],nnums[j]])      &amp;#125;    &amp;#125;  &amp;#125;  // consider about the special case that two sub elements are same  if(amapper[target/2] &amp;gt;=2)&amp;#123;output.push([target/2,target/2])&amp;#125;  return output&amp;#125;
Compared with the two pointers method, this one would be a little slower - test with replacing this one with previous one in the findNSum function below.
18. 4SumQuestionGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d). The solution set must not contain duplicate quadruplets.
For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
LeetCode18. 4Sum
Tags: Array, Hash Table, Two Pointers, Medium
Answersreduce to 2Sum123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[][]&amp;#125; */var fourSum = function(nums, target) &amp;#123;  // sort  nums.sort( (a,b)=&amp;gt; a - b)  var output = []  findNSum(nums,target,4,[],output)  return output&amp;#125;;var findNSum = (nums,target,N,result,output)=&amp;gt;&amp;#123;  // base exit case  if(nums.length &amp;lt; N || N &amp;lt; 2) return  // 2Sum like before but don't need to sort the list again  if(N==2)&amp;#123;    // can replace below with any one of these 2Sum ways    var i = 0, j = nums.length-1    while(i&amp;lt;j)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(result.concat([nums[i],nums[j]]))        i ++        j --        // remove the duplicate values        while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;          i++        &amp;#125;        while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;          j--        &amp;#125;      &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;        j --       &amp;#125;else&amp;#123;        i ++      &amp;#125;    &amp;#125;  &amp;#125;else&amp;#123;    for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;      if(i==0 || (i&amp;gt;0 &amp;amp;&amp;amp; nums[i-1] != nums[i]))&amp;#123;        // recursively call findNSum        findNSum(nums.slice(i+1,nums.length), target-nums[i],N-1,result.concat([nums[i]]),output)      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 328 ms
Since the nums is sorted, we can use pruning during the for loop to save a lot of time:
12// add this within the for loop before the recursionif(nums[i]*N &amp;gt; target || nums[nums.length-1]*N &amp;lt; target) break
Runtime: 228
Using Hash TableThink about using the hashtable store all value of two pairs, and then treat it like a twoSum problem, but will use a lot space.
SummaryAll NSum problems can be solved by the same way.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Dynamic scheduling crawler for FeedPusher</title><link>http://taoalpha.me/blog/2016/01/12/tech-dynamic-scheduling-crawler-for-feedpusher/</link><category>tech</category><tag>Crawler,FeedPusher,NodeJS</tag><pubDate>2016-01-12T08:12:44.000Z</pubDate><description>As I promised, I have been working on refactoring the feedpusher with pure JS/nodeJS from last week. Now I have set up the basic database struture and spider which has already been running for one week with 80 sites and 8k feeds stored into my mongodb on raspberry pi.
Today, I jsut set up a new process to crawl the updates which I called dynamic scheduling which means now the spider can decide whether this site needs to be recrawled this time or not by itself. Why? Most important reason is that as the number of sites goes bigger, the time it crawles all sites is longer, and also crawl every site everytime is not a good way.
Now I will explain how I do that with nodeJS.
TheoryOur purpose is let the spider decide when to crawl a specific website/rss link, or in another word, everytime the spider runs, it needs to decide which website should be recrawled this time.
What data I haveNow I have and I can store some data into my database that may be good for this purpose, but we want to use as few as possible, so I decide to use these two attributes:

lastCrawled: time I last crawled this website;
updateDuration: the duration between two continuous crawl of this site;

Dynamic SchedulingThe lastCrawled is pretty simple and we don’t have a lot things can do with it. But the updateDuration is the core of the dynamic scheduling, since we can increase it and tell the spider that this site needs a longer duration before next crawling and vice versa.
So the basic idea is:
The larger the updateDuration is, the longer the website get recrawled.
Rules
When to crawl: if current time minus the time lastCrawled is longer than the updateDuration, then the website needs to be recrawled;
Motivate: if this round of crawling got any updates(new feeds) of this website, then we decrease the updateDuration of this website which is like motivating this website because of the updates;
Penalize: if this round of crawling got no updates(new feeds) of this website, then we increase the updateDuration of this website which is like penalizing this website because of the later update than expected;

ResultsBased on these simple rules, the updateDuration of one site would be dynamic changing and will reflect the frequency of a website updates in some level.
CodingThe coding part is pretty stright forward, but since the spider need get a lot of data from the mongodb, so you might need a lot promises to make sure the order of different processes is under your control.
I will put the Pseudocode here, if you are interested in the real code, you can check my feedpusher code refactoring repo :)
PseudocodeThis is not a real pseudocode… but I believe you can bare with that :)
1234567891011121314151617181920212223242526272829303132333435363738394041424344// feed is the object of my core class I used for this spiderfeed.db.open((err, db) =&amp;gt;&amp;#123;  // connect with database  var allSites = [] // store all sites we crawled this time in order to update the lastCrawled and updateDuration later  // find all sites from the database  feed.findAllSites().then((data) =&amp;gt; &amp;#123;    var curTime = moment()    // Need use promise to make sure all finished before you update the lastCrawled and updateDuration    return Promise.all(data.filter( (v) =&amp;gt; &amp;#123;      // filter all sites that the time from lastCrawled has passed the updateDuration      return (((curTime - moment(v.lastCrawled)) / 3600 / 1000) &amp;gt; v.updateDuration)    &amp;#125;)    .map( (v) =&amp;gt;&amp;#123;      // crawl and store each feedUrl which is the link of the rss      allSites.push(v.feedUrl)      return feed.crawler(v.feedUrl)    &amp;#125;) )  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    // update the lastFCrawled for all sites    return feed.updateCrawled(allSites)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at crawler&quot;)    console.log(reason)    db.close()  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    console.log(feed.stats)    feed.updateDuration(allSites).then( () =&amp;gt; &amp;#123;      // Now update the updateDuration for all sites      db.close()    &amp;#125;,(reason)=&amp;gt;&amp;#123;      console.log(&quot;Broken at updatedDuration&quot;)      console.log(reason)      db.close()    &amp;#125;)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at updatedCrawled&quot;)    console.log(reason)    db.close()  &amp;#125;)&amp;#125;)
Yup! currently it works pretty good! :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>ES6 Quiz With Answer</title><link>http://taoalpha.me/blog/2016/01/11/tech-es6-quiz-with-answer/</link><category>tech</category><tag>ES6,JS,Quiz</tag><pubDate>2016-01-11T08:15:24.000Z</pubDate><description>Origin Post
@kangax’s ES6 quiz, explained@kangax created a new interesting quiz, this time devoted to ES6 (aka ES2015). I found this quiz very interesting and quite hard (made myself 3 mistakes on first pass).
Here we go with the explanations:
Question 1:123456(function(x, f = () =&amp;gt; x) &amp;#123;  var x;  var y = x;  x = 2;  return [x, y, f()];&amp;#125;)(1)

[2, 1, 1]
[2, undefined, 1]
[2, 1, 2]
[2, undefined, 2]

The most complex question for me in this quiz. I didn’t get it right initially until read the spec and clarified with @kangax. First I answered [2, undefined, 1], which is “almost correct”, except one subtle thing. The correct answer here is the first one, [2, 1, 1], and let’s see why.
As we know, parameters create extra scope in case of using default values.
Parameter f is always the function (the default value, since it’s not passed), and it captures x exactly from the parameters scope, that is 1.
Local variable x shadows the parameter with the same name, var x;. It’s hoisted, and is assigned default value… undefined? Yes, usually it would be assigned value undefined, but not in this case, and this is the subtle thing we mentioned. If there is a parameter with the same name, then the local binding is initialized not with undefined, but with the value (including default) of that parameter, that is 1.
So the variable y gets the value 1 as well, var y = x;.
Next assignment to local variable x happens, x = 2, and it gets value 2.
By the time of the return, we have x is 2, y is 1, and f() is also 1. It’s also a tricky part: since f was created in the scope of parameters, its x refers to the parameter x, which is still 1.
And the final return value is: [2, 1, 1].

Question 2:123456(function() &amp;#123;  return [    (() =&amp;gt; this.x).bind(&amp;#123; x: 'inner' &amp;#125;)(),    (() =&amp;gt; this.x)()  ]&amp;#125;).call(&amp;#123; x: 'outer' &amp;#125;);

[‘inner’, ‘outer’]
[‘outer’, ‘outer’]
[undefined, undefined]
Error

Arrow functions have lexical this value. This means, they inherit this value from the context they are defined. And later it stays unchangeable, even if explicitly bound or called in a different context.
In this case both arrow functions are created within the context of {x: &amp;#39;outer&amp;#39;}, and .bind({ x: &amp;#39;inner&amp;#39; }) applied on the first function doesn’t make difference.
So the answer is: [&amp;#39;outer&amp;#39;, &amp;#39;outer&amp;#39;].

Question 3:1let x, &amp;#123; x: y = 1 &amp;#125; = &amp;#123; x &amp;#125;; y;

undefined
1
{ x: 1 }
Error

Variable y will eventually have value 1 since:
First, let x defines x with the value undefined.
Then, destructuring assignment { x: y = 1 } = { x } on the right hand side has a short notation for an object literal: the {x} is equivalent to {x: x}, that is an object {x: undefined}.
Once it’s destructured the pattern { x: y = 1 }, we extract variable y, that corresponds to the property x. However, since property x is undefined, the default value 1 is assigned to it.
So the answer is: 1.

Question 4:1234567(function() &amp;#123;  let f = this ? class g &amp;#123; &amp;#125; : class h &amp;#123; &amp;#125;;  return [    typeof f,    typeof h  ];&amp;#125;)();

[“function”, “undefined”]
[“function”, “function”]
[“undefined”, “undefined”]
Error

This IIFE is executed with no explicit this value. In ES6 it means it will be undefined (the same as in strict mode in ES5).
So the variable f is bound to the class h {}. Its typeof is a &amp;quot;function&amp;quot;, since classes in ES6 is a syntactic sugar on top of the constructor functions.
However, the class h {} itself is created in the expression position, that means its name h is not added to the environment. And testing the typeof h should return &amp;quot;undefined&amp;quot;.
And the answer is: [&amp;quot;function&amp;quot;, &amp;quot;undefined&amp;quot;].

Question 5:1(typeof (new (class &amp;#123; class () &amp;#123;&amp;#125; &amp;#125;)))

“function”
“object”
“undefined”
Error

This is an obfuscated syntax playing, but let’s try to figure it out :)
First of all, since ES5 era, keywords are allowed as property names. So on a simple object example, it can look like:
123let foo = &amp;#123;  class: function() &amp;#123;&amp;#125;&amp;#125;;
And ES6 standardized concise method definitions, that allows dropping the : function part, so we get the:
123let foo = &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
This is exactly what corresponds to the inner class () {} – it’s a method inside a class.
The class itself is anonymous, so we can rewrite the example:
12345let c = class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;new c();
Now, instead of assigning to the varialbe c, we can instantiate it directly:
123new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
The result of a default class is always a simple object. And its typeof should return &amp;quot;object&amp;quot;:
123typeof (new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;);
And the answer is: &amp;quot;object&amp;quot;.

Quetion 6:1typeof (new (class F extends (String, Array) &amp;#123; &amp;#125;)).substring

“function”
“object”
“undefined”
Error

Here we have a similar obfuscated example (but we already figured out this inlined typeof, new, and class thing above ;)), though the interesting part is the value of the extends clause. It’s the: (String, Array).
The grouping operator always returns its last argument, so the (String, Array) is actually just Array.
So what we’ve got here is:
12345class F extends Array &amp;#123;&amp;#125;let f = new F();typeof f.substring; // &quot;undefined&quot;
Since array instances do not have substring method, and our extended class F didn’t provide it either, the answer is &amp;quot;undefined&amp;quot;.

Question 7:1[...[...'...']].length

1
3
6
Error

Here we deal with the spread operator. It allows to spread all the elements to the array. It can work with any iterable object.
Strings are iterable, meaning that we can iterate over their chars (in this case char by char). So the inner [...&amp;#39;...&amp;#39;] results to an array: [&amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;]:
12345let s = '...';let a = [...s];console.log(a); // ['.', '.', '.']
Array are iterable as well. So the outer spread is applied on our new array:
1234let result = [...a];console.log(result); // ['.', '.', '.']console.log(result.length); // 3
As we can see spreading the array happens element by element, so the resulting array just copied all the elements, and looks the same – with just 3 string dots.
And the answer is: 3.

Question 8:1typeof (function* f() &amp;#123; yield f &amp;#125;)().next().next()

“function”
“generator”
“object”
Error

In this example we encounter a generator function. When executed, they return a generator object:
1let g = (function* f() &amp;#123; yield f &amp;#125;)();
Generator objects have next method, that returns the next value at the yield position. The returned value has iterator protocol format:
1&amp;#123;value: &amp;#60;returned value&amp;#62;, done: boolean&amp;#125;;
So on first next() we get:
1g.next(); // &amp;#123;value: f, done: false&amp;#125;
As we see, the returned value itself doesn’t have method next(), so trying to call it as a chain would result to an error:
1g.next().next(); // error
Notice though, that we could normally call it as:
12g.next(); // &amp;#123;value: f, done: true&amp;#125;g.next(); // &amp;#123;value: undefined, done: true&amp;#125;
So the answer is: Error.

Question 9:1typeof (new class f() &amp;#123; [f]() &amp;#123; &amp;#125;, f: &amp;#123; &amp;#125; &amp;#125;)[`$&amp;#123;f&amp;#125;`]

“function”
“undefined”
“object”
Error

The obfuscated example results to a Syntax Error since class name f() is not correct.
The answer is Error.

Question 10:1typeof `$&amp;#123;&amp;#123;Object&amp;#125;&amp;#125;`.prototype

“function”
“undefined”
“object”
Error

This one is very tricky :)
First, we deal with template strings.
They are capable to render values of variables directly in the strings:
123let x = 10;console.log(`X is $&amp;#123;x&amp;#125;`); // &quot;X is 10&quot;
However, in the example we have something that looks a bit strange: it’s not ${Object} how it “should be”, but the $.
No, it’s not another special syntax of template strings, it’s still a value inside ${}, and the value is {Object}.
What is {Object}? Well, as we mentioned earlier above, ES6 has short notation for object literals, so in fact it’s just the: {Object: Object} – a simple object with the property named &amp;quot;Object&amp;quot;, and the value Object (the built-in Object constructor).
Now it’s becoming more clear:
1234let x = &amp;#123;Object: Object&amp;#125;;let s = `$&amp;#123;x&amp;#125;`;console.log(s); // &quot;[object Object]&quot;
See what’s happened? The ${x} is roughly equivalent to the:
12345'' + x;// or the same:x.toString(); // &quot;[object Object]&quot;
Now, the string &amp;quot;[object Object]&amp;quot; obviously doesn’t have property prototype:
123&quot;[object Object]&quot;.prototype; // undefinedtypeof &quot;[object Object]&quot;.prototype; // &quot;undefined&quot;
So the answer is: &amp;quot;undefined&amp;quot;.

Question 11:1((...x, xs)=&amp;gt;x)(1,2,3)

1
3
[1,2,3]
Error

This one is the simplest. Rest parameters can appear only at the last postion. In this case ...x goes as a first argument of an IIFE arrow function, so results to a Parse Error.
And the answer is: Error.

Question 12:12345let arr = [ ];for (let &amp;#123; x = 2, y &amp;#125; of [&amp;#123; x: 1 &amp;#125;, 2, &amp;#123; y &amp;#125;]) &amp;#123;  arr.push(x, y);&amp;#125;arr;u

[2, { x: 1 }, 2, 2, 2, { y }]
[{ x: 1 }, 2, { y }]
[1, undefined, 2, undefined, 2, undefined]
Error

Several topics combined here: destructuring assignment, default values, and for-of loop.
However, we can quickly identify it’s an error, because of two one thing:
EDIT 1: @fkling42 pointed out that the variable y is in the environment, but is not initialized yet (being under TDZ – Temportal Dead Zone), and that’s the reason why it cannot be accessed
EDIT 2: @getify pointed out, that value 2 actually normally passes RequireObjectCoercible check, and hence there would be no error in destructuring let { x = 2, y } = 2;.

{ y } is a short notation of {y: y} and will fail, since variable y doesn’t exist in the scope; The variable y is in the scope, but is under TDZ, so cannot be accessed
(we wouldn’t reach this, because of the frist error, but): trying to destructure 2 will fail too will not fail, since to object coercion will be normally applied.

So the answer is: Error.

Question 13:123456(function() &amp;#123;  if (false) &amp;#123;    let f = &amp;#123; g() =&amp;gt; 1 &amp;#125;;  &amp;#125;  return typeof f;&amp;#125;)();

“function”
“undefined”
“object”
Error

This example is only on attention, since it’s a syntax error: the arrow function =&amp;gt; cannot be defined in this way, since we have a an object with the g (consice) method.
And the answer is: Error.

ConclusionI like such tricky quiz questions, it’s always fun to track the runtime semantics and parsing process manually. Of course, most of the things here are far from practical production code, and are interesting mostly from the theoretical viewpoint. Still I found it enjoyable.
I’ll be glad to discuss all the questions in the comments.
Good luck with ES6 ;)
Written by: Dmitry Soshnikov
http://dmitrysoshnikov.com
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Scalable and Modular Architecture for CSS</title><link>http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/</link><category>read</category><tag>CSS,Modularity,SMACSS</tag><pubDate>2016-01-11T00:13:50.000Z</pubDate><description>Modularity of Web DevAs your project becomes more complex, its more difficult to maintain the code, no matter what kind of language you are using. That’s why we use OOP for most of the projects, by doing that, it saves you a lot of time and energy. Since web development becomes more popular, more and more people start focusing on this area and come up with some fantastic ideas about how to apply modularity or OOP on web development.
We all know that a basic website would contains three basic parts: HTML/CSS/JS. HTML is in charge of the struture, the CSS will focus on the appearance, and JS will give your website more animation(now css can do that too) and interaction. Among all these three parts, HTML is the easiest one, there is not so many things to talk about except the semantic tag, H5..etc, if you want to improve the modularity, most times HTML is not what you care most. Instead, CSS and JS are your primary concern.
Scalable and Modular Architecture for CSS is a nice book focus on applying modularity to CSS, and here is the notes I wrote down after I read it. About JS, we will talk about it later :) You can start with a nice and good coding style.
Reading NotesCategories of RulesJonathan Snook groups CSS rules into five types of categories:

Base: Base rules are the defaults. They are almost exclusively single ele- ment selectors but it could include attribute selectors, pseudo-class selectors, child selectors or sibling selectors. Essentially, a base style says that wherever this element is on the page, it should look like this;
You can use some reset frameworks out there, just be sure you know everything it does before you actually put it in your project;


Layout: Layout rules divide the page into sections. Layouts hold one or more modules together;
Generally, a Layout style only has a single selector: a single ID or class name;
Sometimes, you may have different layouts base on different settings like user preference, then you can use more than one selectors;


Modules: Modules are the reusable, modular parts of our design. They are the callouts, the sidebar sections, the product lists and so on;
Each Module should be designed to exist as a standalone component;
Avoid using IDs and ele- ment selectors, sticking only to class names;
Only include a selector that includes semantics. A span or div holds none. A heading has some. A class defined on an element has plenty;
If you do wish to use an element selector, it should be within one level of a class selector;


State rules: State rules are ways to describe how our modules or layouts will look when in a particular state. Is it hidden or expanded? Is it ac- tive or inactive? They are about describing how a module or layout looks on screens that are smaller or bigger. They are also about de- scribing how a module might look in different views like the home page or the inside page;
A state is something that augments and overrides all other styles;
States should be made to stand alone and are usually built of a single class selector, sometimes you can use !important to address the state;
In a case where a state rule is made for a specific module, the state class name should include the module name in it;


Theme rules: Theme rules are similar to state rules in that they describe how modules or layouts might look. Most sites don’t require a layer of theming but it is good to be aware of it;
Focus on general appearance of your website like colors, borders etc;



And also using proper name for different categories can be beneficial for immediately understanding which category a particular style belongs to and its role within the overall scope of the page. Here is a simple example:
123456789101112/* Example Module */.example &amp;#123; &amp;#125;/* Callout Module */.callout &amp;#123; &amp;#125;/* Callout Module with State */.callout.is-collapsed &amp;#123; &amp;#125;/* Form field module */.field &amp;#123; &amp;#125;/* jsExample is a subclass or variation of example */.example-jsExample &amp;#123; &amp;#125;/* Inline layout  */.l-inline &amp;#123; &amp;#125;
Tips
Minimizing the Depth: The depth of applicability is the number of generations that are affected by a given rule;
Two Goals of SMACSS: Increase semantics and decrease reliance on specific HTML;
How to separate the files in your project:
Place all Base rules into their own file;
Depending on the type of layouts you have, either place all of them into a single file or major layouts into separate files;
Put each module into its own file;
Depending on size of project, place sub-modules into their own file;
Place global states into their own file;
Place layout and module states, including media queries that affect those layouts and modules, into the module files;


Organize styles in the following order:
Box: display, float, position, left, top, height, width…
Border: border;
Background: background;
Text: font-family, font-size, text-transform, letter-spacing…
Others: others;


Be Consistent;

SummaryThis book is pretty short with all valueable content. Strongly recommend after you get familiar with all basic css concepts.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (2)</title><link>http://taoalpha.me/blog/2015/06/30/read-coffeescript-programming-with-jquery-rails-and-nodejs-2/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-30T04:00:00.000Z</pubDate><description>SummaryAfter learned the basic syntax of CoffeeScript, I re-wrote all my blog’s js files with CoffeeScript. I have to say, practice is the best way to learn and understand one skill. Especially for coding, if you just read the book and never write a single line by yourself, you will never become a master of it or you may stick in the beginner for ever.
Today we will finish the book. Talking about how to combine the CoffeeScript with some other web tools we use a lot: jQuery, Rails and Nodejs.
NotesHere I just ignored the second chapter about how to install the coffeescript and nodejs in your computer, if you need some help, feel free to comment below the blog or just visit the nodejs and coffeescript to find a way yourself.
jQueryjQuery is the most popular js module people used in their websites or webapps. And using jQuery with CoffeeScript is just like javascript. jQuery is javascript, after all.
Want to use CoffeeScript with jQuery? Just do it and follow the rules we learn from the basic syntax part. Here I list several examples and if you look it closely, you will find everything you have already known if you read the first chapter carefully. The author of the book shows us another complex examples: TodoMVC in CoffeeScript.
BTW: TodoMVC is a great project which shows you how to write a todo app in all kinds of tools and frameworks.
1234567891011121314151617181920212223242526272829303132333435363738394041$ -&amp;gt;  do some  do another### =&amp;gt;$(function() &amp;#123;  some();  return another();&amp;#125;);That's just like the $(document).ready(function()&amp;#123;&amp;#125;)#### A function using ajax to send mail, which is a new feature I will add to my blog in a few days :)@sendMail = (msg)-&amp;gt;  $.ajax    type: 'POST'    url: 'https://mandrillapp.com/api/1.0/messages/send.json'    data:      'key': ''      'message':        'from_email': msg.sender_mail        'from_name' : msg.sender_name        'to': [            &amp;#123;              'email': ''              'name': 'TaoAlpha'              'type': 'to'            &amp;#125;          ]        'autotext': 'true'        'subject': msg.subject        'html': msg.content  .done (response)-&amp;gt;    showAlert(&quot;success&quot;,&quot;Thanks for your contribution!&quot;)  .fail (data)-&amp;gt;    showAlert(&quot;fail&quot;,&quot;Sorry! Failed to send the email. Please retry!&quot;)# another function to get unique result from an array of objectsArray::getObjectUnique = (id) -&amp;gt;  a=b=[];  add = (data) -&amp;gt; b.push data[id];data  (add i for i in @ when b.indexOf(i[id]) == -1 )
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// You can see that you have saved a lot of keystrokes and the codes look more clean and beautiful.// Because coffeescript doesn't support declare global variables directly, and if we want to use the function in other script, we need to declare it into the `this` scope.this.sendMail = function(msg) &amp;#123;  return $.ajax(&amp;#123;    type: 'POST',    url: 'https://mandrillapp.com/api/1.0/messages/send.json',    data: &amp;#123;      'key': '',      'message': &amp;#123;        'from_email': msg.sender_mail,        'from_name': msg.sender_name,        'to': [          &amp;#123;            'email': '',            'name': 'TaoAlpha',            'type': 'to'          &amp;#125;        ],        'autotext': 'true',        'subject': msg.subject,        'html': msg.content      &amp;#125;    &amp;#125;  &amp;#125;).done(function(response) &amp;#123;    return showAlert(&quot;success&quot;, &quot;Thanks for your contribution!&quot;);  &amp;#125;).fail(function(data) &amp;#123;    return showAlert(&quot;fail&quot;, &quot;Sorry! Failed to send the email. Please retry!&quot;);  &amp;#125;);&amp;#125;;# get unque result for array of objectsArray.prototype.getObjectUnique = function(id) &amp;#123;  var a, add, b, i, j, len, results;  a = b = [];  add = function(data) &amp;#123;    b.push(data[id]);    return data;  &amp;#125;;  results = [];  for (j = 0, len = this.length; j &amp;lt; len; j++) &amp;#123;    i = this[j];    if (b.indexOf(i[id]) === -1) &amp;#123;      results.push(add(i));    &amp;#125;  &amp;#125;  return results;&amp;#125;;
RailsRuby on Rails is a web framework that came around in 2004. And it soon became quite popular. Actually many people believe that Rails saved the ruby…
Check this:How to download and install Rails if you haven’t installed it.
Rails’s principles
Convention over configuration


Rails is designed to assume that the programmer will follow certain known conventions, which if used, provide great benefit and much less need to configure the framework.That means that the framework makes assumptions on how a typical application should be built and structured and it doesn’t try to be overly flexible and configurable. This helps you spend less time on mundane tasks like configuring and wiring up an application architecture and more time on actually building your app.


Don’t repeat yourself, or DRY


Every piece of knowledge must have a single, unambiguous, and authoritative representation within a system.Rails strives to remove duplication and boilerplate wherever it can.

How to use Rails with CoffeeScriptLuckily, after Rails 3.1, you don’t need do anything to let Rails support CoffeeScript. It has already become part of rails! And also, rails has changed its default js library to jQuery.
So what you need to do if you want to use coffeescript with rails? Nothing but learn rails!
Just like the author said in the book: “If you haven’t done so already, I encourage you to spend some more time learning Rails as well as Ruby, and immersing yourself in the wonderful communities they support.”
Node.jsNode is fantastic. It changes something. Before node, javascript was mostly run inside browsers. Now it just came out and gave web developers a chance to become a full-stack!
Features of Node
Event-driven


The Node.js framework only allows non-blocking, asynchronous I/O. This means that any I/O operation that is accessing an external resource, such as the operating system, a database, or a network resource must happen asynchronously.


Fast and scalable


The V8 JavaScript engine(created by google and used in chrome) used by Node.js is highly optimized for performance, thus making Node.js applications very fast. The fact that Node is non-blocking will ensure that your applications will be able to handle many concurrent client requests without using a lot of system resources.


Node is not Rails


Rails strives to be a full-stack solution to building web applications, whereas Node.js is more of a low-level system for writing any type of fast and scalable network application.

Node and CoffeeScriptWant to write coffeescript in node? It’s easy, all you need is a module named CoffeeScript. And like many other languages, node has several frameworks people built for web development, like: Express.
The core about how to use coffeescript with nodejs is to use the --watch for coffee command in node. It will automatically compile all file end with coffee into js when there is a change made into these files.
And just like jQuery, you just follow the rules and write your code.
DigestCoffeeScript is a tool that can help you write js more quickly and elegant. And any platform or language you want to use coffeescript, what you need to do is following the coffeescript’s rules. There is no difference caused by platform or language.
That’s all. Thanks!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (1)</title><link>http://taoalpha.me/blog/2015/06/28/read-coffeescript-programming-with-jquery-rails-and-nodejs/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-28T04:00:00.000Z</pubDate><description>SummaryThe notes I took while I was learning the ‘CoffeeScript’. If you are a real beginner with ‘CoffeeScript’, I suggest you start with another book called “The Little Book on CoffeeScript”, it’s better for beginners. And after that, this one is definitely your best choice.
CoffeeScript is a language which complies to JavaScript. Like the sass or scss to css except that CoffeeScript is not compatible with javascript. So you can not mix the javascript syntax with the CoffeeScript.
This note is mainly about the fist chapter of the book, a nice introduction for CoffeeScript including the basic syntax.

And to improve my english, I think i will start writing english notes for the english books. ^_^

NotesCoffeeScript is pretty popular in the community of JavaScript for its simplicity, elegant and readable. Now let us dive into it.
Instead of  listing the keywords and statements used in CoffeeScript one by one, it would better we learn CoffeeScript from comparing the difference between the CoffeeScript and JavaScript.
CoffeeScript fix some ugly stuffs in JavaScript
CoffeeScript removes most of the semicolons and the curly braces which used a lot in JavaScript, gives us a clearly view of the code, but you can still use the semicolons if you want, and you still have to use the semicolons if you want to put multiple statements in single one;
CoffeeScript learns a lot from ruby and python. Like this one: it uses whitespace or indentation, more accurately, to delimit the code blocks instead of braces.
CoffeeScript removes a lot of parenthesis for many statements and functions, like if..else, while loops and functions with single string parameter. But this is optional, you can still use them if you want. Notice: you will need parenthesis if you want to call a function without any parameters)
Function: as the first class object in JavaScript, CoffeeScript also does a lot improvements for it.
If you write js, you will know that the syntax is really ugly when you want to write a anonymous function. Now you can make it pretty beautiful with CoffeeScript;
CoffeeScript also saves you a lot keystrokes for defining the functions;
so what are the rules?
Replace the function keyword with -&amp;gt;;
Drop the parenthesis if there is no argument for the function;
Put the arguments enclosed with parenthesis in front of the -&amp;gt;, and if the argument has a default value, you can set it in the parenthesis;
Drop the curly braces and use indentation for the function body;
Automatically return the last expression of the function, but if you need return something before, you still need to use the return;





1234567891011121314151617 -&amp;gt; alert 'hi there!'# the code above won't self-initiating, if you want to do that, you need use parenthesis or the `do` keyword like below:# (-&amp;gt; alert 'hi there!')()# do -&amp;gt; alert 'hi there!'square = (n=1) -&amp;gt; n * n# function using splats# this is an alternative way for using Array.prototype.slice()gpaScoreAverage = (scores...) -&amp;gt;  total = scores.reduce (a, b) -&amp;gt; a + b  total / scores.lengthalert gpaScoreAverage(65,78,81)scores = [78, 75, 79]alert gpaScoreAverage(scores...)
1234567891011121314151617181920212223242526272829303132333435var square;(function()&amp;#123;  return alert(&quot;hi there!&quot;);&amp;#125;);/* the code in comments above will compile to:(function()&amp;#123;  if (n == null) &amp;#123;    n = 1;  &amp;#125;  return alert(&quot;hi there!&quot;);&amp;#125;)();*/square = function(n) &amp;#123;  return n * n;&amp;#125;;// [].slice.call(arguments,0) ==&amp;gt;  Array.prototype.slice.call(arguments,0)var gpaScoreAverage, scores,  slice = [].slice;gpaScoreAverage = function() &amp;#123;  var scores, total;  scores = 1 &amp;lt;= arguments.length ? slice.call(arguments, 0) : [];  // get the single score value or a list of the scores  total = scores.reduce(function(a, b) &amp;#123;    return a + b;  &amp;#125;);  return total / scores.length;&amp;#125;;alert(gpaScoreAverage(65, 78, 81));scores = [78, 75, 79];alert(gpaScoreAverage.apply(null, scores));
CoffeeScript saves you a lot of keystrokes
CoffeeScript will declare the variables you need at the top of the function for you automatically. So that means you can’t create the global variables in a function like you can do in JavaScript, actually you can’t use the var keyword in CoffeeScript. &amp;lt;= many people agree that omitting the var keyword makes the variables become global is a really bad desgin…
Object:
CoffeeScript supports the class keyword, and it will create a closure to build the class;
Use the constructor to initialize some private properties, or just omit it;
Every function you define in a class will be added to the object as a prototype method;
Use @ as a shortcut for this;
fat arrow: When you want to use this in previous scope instead of the new scope, you need the fat arrow : =&amp;gt;;
Use super to call the parent’s method (same name, so just pass the parameter);
Use :: as a shortcut for .prototype, so you can extend your prototype as this:Vehicle::stop =-&amp;gt; alert &amp;#39;stop&amp;#39;;



123456789101112131415161718192021222324252627282930313233class Vehicle  # Use the constructor to initialize some private properties  # Use @ as this  constructor: -&amp;gt;    @c = 1  drive: (km) -&amp;gt;    alert &quot;Drove #&amp;#123;km&amp;#125; kilometres&quot;class Car extends Vehicle constructor: -&amp;gt;   @odometer = 0 drive: (km) -&amp;gt;   @odometer += km   super km name:&quot;John Doe&quot; driver: (msg) -&amp;gt;   @msg = msg whoisdriver: -&amp;gt;   @msg()car = new Carcar.drive 5alert &quot;Odometer is at #&amp;#123;car.odometer&amp;#125;&quot;class Person  constructor: (name)-&amp;gt;    @name = name    @mycar = new Car()    @mycar.driver =&amp;gt; alert &quot;#&amp;#123;@name&amp;#125;&quot;mike = new Person &quot;Mike&quot;# use `=&amp;gt;` to show mike's name instead of the default `john doe` set in Carmike.mycar.whoisdriver()
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var Car, Person, Vehicle, car, mike,  extend = function(child, parent) &amp;#123; for (var key in parent) &amp;#123; if (hasProp.call(parent, key)) child[key] = parent[key]; &amp;#125; function ctor() &amp;#123; this.constructor = child; &amp;#125; ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; &amp;#125;,  hasProp = &amp;#123;&amp;#125;.hasOwnProperty;Vehicle = (function() &amp;#123;  function Vehicle() &amp;#123;    this.c = 1;  &amp;#125;  Vehicle.prototype.drive = function(km) &amp;#123;    return alert(&quot;Drove &quot; + km + &quot; kilometres&quot;);  &amp;#125;;  return Vehicle;&amp;#125;)();Car = (function(superClass) &amp;#123;  extend(Car, superClass);  function Car() &amp;#123;    this.odometer = 0;  &amp;#125;  Car.prototype.drive = function(km) &amp;#123;    this.odometer += km;    return Car.__super__.drive.call(this, km);  &amp;#125;;  Car.prototype.name = &quot;John Doe&quot;;  Car.prototype.driver = function(msg) &amp;#123;    return this.msg = msg;  &amp;#125;;  Car.prototype.whoisdriver = function() &amp;#123;    return this.msg();  &amp;#125;;  return Car;&amp;#125;)(Vehicle);car = new Car;car.drive(5);alert(&quot;Odometer is at &quot; + car.odometer);Person = (function() &amp;#123;  function Person(name) &amp;#123;    this.name = name;    this.mycar = new Car();    this.mycar.driver((function(_this) &amp;#123;      return function() &amp;#123;        return alert(&quot;&quot; + _this.name);      &amp;#125;;    &amp;#125;)(this));  &amp;#125;  return Person;&amp;#125;)();mike = new Person(&quot;Mike&quot;);mike.mycar.whoisdriver();
Other Good Things
CoffeeScript will quote reserved words automatically if you use them in your literal object;
You can also drop the comma when you define your literal array or literal object only if you put one property per line, you can drop the braces for object, but you need them for array;
Use #{variable_name} to concatenate the string and variables instead of +, but only use them enclosing with double-quote, the single-quote strings are literal, borrowed from ruby;
CoffeeScript will always convert the == and != to === and !==;
Use the existential operator: ? to check whether a variable exists and has a value or not(means not null or undefined);
Also use the soak: ?. as a shortcut for ternary statement;
Support some new keywords like unless, the opposite to if;
Use plain english aliases for some of the logical operators: is for ===,isnt for !==,not for !,and for &amp;amp;&amp;amp;,or for ||,true can also be yes, or on,false can be no or off;
Support assign multiple values at once;
CoffeeScript replaces the case in switch with when ... then, so you can forget about the break, and it also replaces the default with else;
CoffeeScript supports the chained comparisions: 61 &amp;gt; a &amp;gt; 39;
You can use ### to comment multiple lines. The biggest difference between ### and # is former one will be part of generated javascript;

1234567891011121314151617b=1if a? &amp;amp;&amp;amp; b?  alert &quot;a.c equals to #&amp;#123;a?.c&amp;#125;&quot;[city, state, country] = [&quot;!2&quot;,&quot;24&quot;,&quot;2&quot;]# or function which returns an object with the same structure as you described before the `=`&amp;#123;address: &amp;#123;street: myStreet,room: myRoom&amp;#125;&amp;#125; = getAddress()### =&amp;gt;var b;b = 1;// since we declared the b before, we only need to check if b is null.if ((typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null) &amp;amp;&amp;amp; (b != null)) &amp;#123;  alert(&quot;a.c equals to &quot; + (typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null ? a.c : void 0));&amp;#125;var city, country, myRoom, myStreet, ref, ref1, state;ref = [&quot;!2&quot;, &quot;24&quot;, &quot;2&quot;], city = ref[0], state = ref[1], country = ref[2];ref1 = getAddress().address, myStreet = ref1.street, myRoom = ref1.room;###
Special for List
List: CoffeeScript borrowed a lot list comprehensions from python[ x*2 for x in object_name ] and ruby.
while: it works nearly the same as in javascript except that it has an opposite keyword in CoffeeScript: until and both of them can be used as expression and will return a array;
for: the standard statement is [action or mapping] for [selector] in [collection] when [condition] by [step]. Last by following with a number would affect the loop step(`i++``);
[f_number..l_number]: it will create a array with numbers between the fist number and the last number, you can use ...(3 dots) to make the array only contains the numbers in between;
of: for key-value pairs of an object, you can use of to loop them through;



1234567891011121314151617181920212223242526272829303132333435363738394041times = [0..2](n*times while times -= 1).pop()### =&amp;gt; var times; times = [0, 1, 2];((function() &amp;#123;  var results;  results = [];  while (times -= 1) &amp;#123;    results.push(n * times);  &amp;#125;  return results;&amp;#125;)()).pop();###alert x for x in flavors when x != 'h' by 2###=&amp;gt;var x, i, len;for (i = 0, len = flavors.length; i &amp;lt; len; i+=2) &amp;#123;  x = flavors[i];  if (x !== 'h') &amp;#123;    alert(x);  &amp;#125;&amp;#125;###ages = john: 25 peter: 26 joan: 23alert &quot;#&amp;#123;name&amp;#125; is #&amp;#123;age&amp;#125; years old&quot; for name, age of ages###=&amp;gt;var age, ages, name;ages = &amp;#123;  john: 25,  peter: 26,  joan: 23&amp;#125;;for (name in ages) &amp;#123;  age = ages[name];  alert(name + &quot; is &quot; + age + &quot; years old&quot;);&amp;#125;###
Digest
For JavaScript:
Every class in JS is a function object;
Only function object has the default prototype, so the normal objects like literal string, number or even string created from String(),any objects created by functions, they all don’t have the default prototype;
But every object has a default constructor which is exactly the function object who create it;


For CoffeeScript:
If there is only one line in the body, you can move it in front of the condition &amp;lt;= while/until/for/if...



Puzzle
Q1: In the second code example above, CoffeeScript create a default extend function for us:

123456789101112131415161718192021var extend = function(child, parent) &amp;#123;  for (var key in parent) &amp;#123;      if (hasProp.call(parent, key)) child[key] = parent[key];  &amp;#125;  // Start from here  function ctor() &amp;#123;      this.constructor = child;  &amp;#125;  ctor.prototype = parent.prototype;  child.prototype = new ctor();  // End  // Just cannot understand the codes above...  // Why we need another function as the child's prototype? We have already copied all the properties from parent, or we just need a beautiful prototype chain? `Car &amp;lt;= ctor() &amp;lt;= Vehicle() &amp;lt;= Object` compared to `Car &amp;lt;= Car &amp;lt;= Object()`.  // Then why not we just use the child.prototype = new parent() ??? we can still get a good prototype chain. `Car &amp;lt;= Vehicle &amp;lt;= Vehicle &amp;lt;= Object`.  child.__super__ = parent.prototype;  return child;&amp;#125;,hasProp = &amp;#123;&amp;#125;.hasOwnProperty;
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (5)</title><link>http://taoalpha.me/blog/2015/06/24/read-javascript-the-definitive-guide-5/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-24T08:00:00.000Z</pubDate><description>概述在十到十二章中, 第十章的正则表达式内容最为丰富, 也是目前应用即为广泛的内容之一. 不过这里也主要是结合js的应用, 实际上正则表达式本身就是一个很值得研究的话题, 有不少书都在谈这个话题, 我后面要读的书目中恰巧就有这么一本, 后面会更加详细的学习以下正则表达式的方方面面.
十一章算是非常前沿, 高端或者说冷门的点了, 随着浏览器的盛行以及技术的进步, 安全问题始终都是一个很重视的点, 而在这种攻防演练中也促进了js本身的进步, 而主流浏览器本身更是走在了js的最前沿. 各种新的属性都是由他们引入而逐渐成为标准的;
十二章主要是对走出浏览器的JS做了一个简单的介绍, 而NodeJS的大名在近几年在前后端, 全端领域都可谓是人尽皆知. 我也会在之后阅读相关书籍的时候做更详细的笔记记录.
阅读笔记Chapter 10 - Pattern Matching Regular Expressions
normal repetition characters:
{m,n} 匹配m-n次;
{m,} 匹配至少m次;
{m} 匹配恰好m次;
? 匹配0或1次;
+ 匹配1或多次;
* 匹配0或多次;


Nongreedy repetition:
??, +?, *? 在常规的匹配后加上?就能让匹配尽可能发生的短, 它会在允许范围内, 找到尽可能短的匹配;


Alternation, Grouping, Reference:
| 表示匹配前者或者后者;
(...) 成组, 以组的形式来使用*,+,?等, 同时会记录组的匹配以用于Reference;
(?:...) 只是成组, 不记录匹配, 不能用于reference, 也不算做reference的序号中去;
\n 引用, n表示序号, 从1开始, 代表之前第几个group的匹配, 用于匹配开头结尾相同且多样的有奇效:/([&amp;#39;&amp;quot;])[^&amp;#39;&amp;quot;]*\1/ 匹配单引号或者双引号内的内容;
需要注意的就是, reference不能用于[]的character class之中!


anchor characters:
^: 匹配开头;
$: 匹配结尾;
\b: 匹配词边界, /\bJava\b/ =&amp;gt; Java
\B: 匹配非词边界, /\B[Ss]cript\B/ =&amp;gt; JavaScript, postscript...
?=p: 表示内容需要匹配p规则,但是返回的命中中不包含这部分;
?!p: 表示内容不匹配p规则;


flags:
i: 大小写敏感, 即区分大小写;
g: 全局匹配, 默认是匹配首个;
m: 多行匹配;


String Methods for Pattern Matching:
search(): 返回匹配词的位置或者-1代表无返回;
replace(): 支持正则匹配替换, 同时支持替换时使用$n代表是正则匹配的引用, 比如text.replace(/&amp;quot;([^&amp;quot;]*)&amp;quot;/g, &amp;#39;“$1”&amp;#39;);即替换&amp;quot;&amp;quot;为“”;
match(): 返回包含了匹配的结果, 返回结构为数组格式;
split(): 接受正则匹配作为其分隔符, 比如: &amp;quot;1, 2, 3&amp;quot;.split(/\s*,\s*/); =&amp;gt; [&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;], 就去掉了本来直接split()多余的空格;


RegExp prototype method:
exec(): 基本等同match(), 不过接受的是string类型去匹配, 而由正则去调用, 当表达式加了全局flag后, exec()每次执行会记录其上次匹配的位置并从此开始新的匹配, 比如:var pattern = /Java/g;pattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).indexpattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).index就会相继输出0,28两个位置;
test(): 用以检测表达式是否匹配了传入的string, 其执行逻辑(g模式下记录上次匹配位置)和exec()一样;



Chapter 11 - JavaScript Subsets and Extensions本章主要介绍一些目前主流浏览器支持但是还没有写入JavaScript官方版本中的一些js语言的子集(非官方版本)和扩展属性:

subsets: 通常是为了确保不确定安全性的代码能够安全的运行而出现的(除了Crockford’s JavaScript: The Good Parts);
ADsafe, 最早一个因为安全因素设计的子集语言, 会禁止对绝大多数全局变量的访问;
dojox.secure: 算是Dojo toolkit的一个扩展;
Caja: 其包含了两个子集, 一个是Cajita, 比较严格, 类似ADsafe 和 dojox.secure; 还有个是Valija, 则比较接近如今ECMAScript 5的strict mode了;
Microsoft Web Sandbox;
FBJS: facebook使用的一个自己;通常子集都需要对应一个verifier, 来确保代码符合其要求;


extensions:
const: 声明常量, 比如: const pi = 3.14;;
let: 块变量声明, 相当于缩小版的var, 作用域仅存活在最近的一个块结构里, 你可以用{}来自行创建一个block;
destructing: 允许多变量结构化赋值: let [x,y] = [1,2];let [r,theta] = polar(1.0, 1.0); function polar(x,y){...};甚至这种all = [first,second] = [1,2,3,4]; 或者这种let transparent = {r:0.0, g:0.0, b:0.0, a:1.0}; let {r:red, g:green, b:blue} = transparent;;
for/each: 和for/in循环不同, for/each遍历对象的属性值而不是属性名, 且可操作类array对象;
for/in: 从js 1.7(mozilla的js引擎版本号)开始, for/in也不局限在array和常规object了, 只要是可循环的元素都可以使用了;
yield: 从python中引入的;
Array Comprehensions:  还是从Python中借用的, let evensquares = [x*x for (x in range(0,10)) if (x % 2 === 0)];
try/catch: 支持多catch;



Chapter 12 - Server-Side JavaScript随着js的发展, 慢慢的超出了其本身的作用域: 浏览器. 随着Google V8引擎为js包入了unix的常用API: files,processes,streams,sockets等, js开始走出浏览器进入server端了. 正式命名为Node.JS. 想来很多人可能都听过, 因为后面我的数目中也包含了相关的书, 且本章内容也没见过太多, 所以就一起留到以后吧~
参考文献:
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (6)</title><link>http://taoalpha.me/blog/2015/06/25/read-javascript-the-definitive-guide-6/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-25T10:00:00.000Z</pubDate><description>概述正式进入本书第二部分的内容, 核心主要围绕在浏览器内的js. 包含了最基本的使用方式, 方法, 因浏览器而增加的各种属性方法, 操作css, dom的方法, 以及常用的一些js框架, 库等, 同时还包含了目前浏览器大热的安全领域.
阅读笔记Chapter 13 - JavaScript in Web Browsers
异步:
defer: 使浏览器在解析并加载渲染完HTML的DOM后加载此js脚本;
async: 使浏览器在尽快执行js脚本, 但在下载js脚本时不停止DOM的解析, 优先级高于defer;
使用方式为在script中增加关键字即可: &amp;lt;script defer src=&amp;quot;deferred.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;;
注意在使用defer/async的时候, js中不能使用document.write();
document.readyState的变化过程: loading(async downloading, normal executing) =&amp;gt; interactive (defer/async executing) =&amp;gt; complete(defer/async done, event handlers invoked);


Compatibility Check:
按照目前的浏览器格局, 基本上一个浏览器就有着一种js的版本, 除了标准版本的基础功能之外, 所有的扩展功能, 各家与各家的实现方式都略有不同, 所以在使用过程中, 就需要我们考虑到兼容性的问题;
Can I Use…, 这是一个非常优秀的检测某个属性, 方法的浏览器支持度, 拿不准的都可以在这里进行查询确认, 其还支持css和html5的检测;
IE5的时候引入了一个Conditional Comments的技巧, 是通过特殊的html注释从而让浏览器识别其IE版本, 比如&amp;lt;!--[if lte IE 7]&amp;gt;&amp;lt;![endif]--&amp;gt;就代表IE7及以下, 而写在这个if里面的内容就会在IE7及以下的浏览器中被识别并作为页面html的一部分而提取出来(仅限IE浏览器), 其他的浏览器都会自动当做注释不理会此部分;
IE的JS也支持Conditional Comments, 比如/*@cc_on @if (@_jscript)...@end @*/, 这里面@cc_on...@*/是整个Conditional Comments, 而里面的@if (@_jscript)...@end则是判断部分, 其中@_jscript是IE自身js编译器的名称;


Accessibility:
对于身体原因而有不便的人, js的支持效果会大打折扣, 所以根据这部分人的情况而优化自身的网页结构, 目前也是网页设计的一大核心之一;


Security:
随着js的发展使用, 其危害性也日益提升;
目前的保障安全手段主要有:限制其功能,限制其使用范围和情景,敏感权限默认关闭虚人工开启;
The Same-Origin Policy: js只允许读取与当前执行环境域名相同域名下的windows属性, 那么怎么界定相同域名呢:
来自不同的网络服务器;
来自相同的网络服务器, 不同的端口;
同一网络服务器, 同一端口, 不同的http协议(http,https);
以上, 都认为是不同域名;


如何舒缓此规则:
document.domain: 考虑到同级子域名也会被禁止, 那么通过设定document.domain为同一母域名即可实现同级子域名的跨域;
Cross-Origin Resource Sharing: 通过http请求新增的Access-Control-Allow-Origin头部, 服务器就可以指定其允许跨域的程度了;
cross-document messaging: HTML5新增了一些很强大的API,cross-document messaging API就是其中之一, 它允许不同的document之间的js进行通讯;





Chapter 14 - The Window Object
Timers:
setTimeout(): 延时触发;
setInterval(): 定时循环执行;
clearTimeout(): 清除延时触发;
clearInterval(): 清除定时循环;


Location:
window.location === document.location 两者皆为当前页面url, 并随页面url变化而更新;
document.URL 也是指代加载后的当前页面, 但不随页面内动态变化引起的url变化而变化;
Location这个对象本身包含了多个属性分别指代url的不同部分:protocol表示网络协议, host, hostname通常都指示域名,前者包含端口, port表示端口, pathname表示以域名根目录为/的相对路径, search表示url中?以后的部分但不包含hash部分, hash则是表示url#以后的部分;
Location还包含了三个常用的函数:assign(),replace(),reload(), 其中前两者功能都一样, 都是用以加载新页面的, 不过replace()加载的同时将当前页面从history中去除了(就是不能后退后之前页面了), 而assign()还保留着; reload()就更不用说了, 只是单纯的重载页面;


History:
back(),forward(): 等价于浏览器的后退,前进按钮;
go(n): 接受数字作为参数, 表示向前或者后退n个页面;
如果页面中有iframe, 那么其history会自动合并到主界面的history中;


Navigator:
appName: 浏览器的名称;
appVersion: 浏览器版本号;
userAgent: 用户代理, 对应HTTP的USER-AGENT;
platform: 操作系统;
onLine: 是否连通网络, HTML5支持;
geolocation: 用户地理位置信息, HTML5支持;
javaEnabled(): 对Java扩展的支持, 非标准;
cookiesEnabled(): 能够设置cookie, 非标准;


Screen:
width,height: 当前屏幕的长宽尺寸;
availWidth,availHeight: 去除功能区等部分之后的实际展现内容的屏幕尺寸;
colorDepth: 显示屏幕的bits-per-pixel;


Dialog Boxes:
alert(): 弹出对话框, 展示传入的信息;
confirm(): 自带OK,Cancel按钮的对话框, 返回对应的boolean值;
prompt(): 附带输入框, 返回输入的值;
上述三个类型的对话框的样式结构都无法调整, 是浏览器默认设定的;
showModalDialog(): 则更加复杂, 它可以支持弹出一个页面, 其接受的第一个参数即为页面的url, 后面的参数则是弹出窗口的属性; 在chromium中已经被禁止了


onerror handler:
用于处理错误信息的, 你完全可以定制这个函数来更好的显示js中的错误信息;


Document Elements As Window Properties:
当一个html元素被赋予了id时, 其id对应名称的全局变量不存在时, 其自动转为全局变量, 属性名称即为id名, 但如果id名已经被使用, 则不生效;
对于&amp;lt;a&amp;gt; &amp;lt;applet&amp;gt; &amp;lt;area&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;form&amp;gt; &amp;lt;frame&amp;gt; &amp;lt;frameset&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;img&amp;gt; &amp;lt;object&amp;gt;这样的元素, 其name值和id效果是一样的, 且name值支持多个元素相同, 会自动生成类array形式, 对于iframe, 对应的属性会指向其内嵌窗口的window对象;


Multiple Windows and Frames:
通过js打开的新窗口都可以被js获取到, 并进行操作, 但是需要符合same-origin的原则;
frame嵌入的窗口可以通过parent.frames属性来获取, 也可以通过其自带的contentWindow来获取;



谜题
Q: 在测试same-origin的时候, 发现有些网站可以设定子域名的document.domain为母域名, 有些不能? 比如在google的搜索结果页, 就可以, 但是在github pages中想要设置为github.io就不可以, 会出现&amp;#39;github.io&amp;#39; is a top-level domain.这样的错误?

参考资料
JavaScript the Definitive Guide 6th edition
Can I Use …
host and hostname

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (7)</title><link>http://taoalpha.me/blog/2015/06/26/read-javascript-the-definitive-guide-7/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-26T06:00:00.000Z</pubDate><description>概述阅读笔记Chapter 15 - Scripting Documents
Selecting:
document.getElementById(id): 通过id, 一个id对应一个元素;
document.getElementsByName(name): 通过name, 可多个;
document.getElementsByTagName(tagname): 通过标签名;
document.getElementsByClassName(class_name): 通过类名;
querySelectorAll(css_selector): 通过css的选择器, 返回所有匹配;
querySelector(css_selector): 返回首个匹配;


Trees of Nodes:
parentNode: 父节点;
childNodes: 子节点;
firstChild, lastChild: 首个或者最后一个子节点;
nextSibling, previousSibling: 下一或者上一兄弟姐妹节点;
nodeType: 节点类型, Document 节点返回9, 元素节点返回1, 文本节点返回3,注释节点返回8, DocumentFragment节点返回11;
nodeValue: 当前节点的文本内容;
nodeName: 标签名, 大写;


Trees of Elements: 忽略所有的文本节点和注释节点;
firstElementChild, lastElementChild: 返回首个或者最后一个元素节点;
nextElementSibling, previousElementSibling
childElementCount: 返回子元素节点的个数;


Attributes of Elements:
getAttribute()
setAttribute()
hasAttribute()
removeAttribute()


Dataset Attributes: 由HTML5引入, 所有带data-前缀的属性都算是合法的html元素属性.
Element Content:
innerHTML
outerHTML: 包含匹配元素自身标签;
insertAdjacentHTML(): 允许指定插入位置beforebegin, afterbegin, beforeend or afterend;
textContent: IE不支持
innerText: IE支持, 功能同上;


Creating,Inserting, and Deleting Nodes
document.createElement(tag_name)
document.createTextNode(text): 创建文本节点;
document.createComment(text): 创建注释节点;
document.createDocumentFragment(): 创建孤立节点;
node_name.cloneNode(): 复制当前节点;
element_node.appendChild(element_node_2): 由后插入;
element_node.insertBefore(element_node_2): 由前插入;
removeChild(): 移除当前节点n.parentNode.removeChild(n);;
replaceChild(): 替换


DocumentFragment: 孤立节点, 其没有母节点(null), 当appendChild()等操作针对其时, 操作执行对象自动变为其所有子节点, 且操作完成后, 其自身为空;
viewport: 表示实际展示内容的窗口, 在顶层网页中为去除浏览器菜单等等之外的部分, 而在iframe中则为iframe定义的frame大小;
document: 表示页面内容的窗口, 通常都大于viewport;
getBoundingClientRect(): 返回节点的长宽,上下左右边界属性width,height,top,left,bottom,right, 返回的结果是基于viewport的;
document.elementFromPoint(): 返回x,y处的元素节点 - 根据z-index, 从外到内的返回;
scroll(), scrollTo(), scrollBy(): 窗口滚动控制, 最后的scrollBy()传入的x,y表示在原有的基础上的增加值;
scrollIntoView(): 滚动到某个节点;
document.forms: 获取页面中所有form元素;
其他document属性:
cookie
domain
lastModified: 修改时间;
location: 等同于window.location
referrer
title
URL: 之前提到过, 其只保存打开时的当前链接, 不随页面内的动态变化而变化;



Chapter 16 - Scripting CSS
js可以通过node.style来访问元素样式属性, 可以获取, 赋予; 而通过更加复杂的函数变化, 就可以创造出一些很棒的动效来, 在css3之前, 所有的非gif或者flash动效基本都是通过js实现的.
window.getComputedStyle(element,&amp;quot;null or :first-line etc&amp;quot;)则可以获取某个元素(或者某个元素的伪类)的所有样式属性, 同时获取的值都会自动转为标准的绝对值(比如设定的百分比也会自动计算出来返回),但是其不能赋予;
disableStylesheet()可以禁止某个元素的所有样式, 如果传入的是数字, 那么会按照document.styleSheets的顺序查找, 如果是string, 则作为css selector查询对应的元素;
insertRule(rules,insert_index), deleteRule(rules) 即插入整条的结构化的css语句, IE下对应的函数为addRule(),removeRule();
document.createStyleSheet则可以创建一个新的样式表, 等价于在head里面创建一个style标签;

Chapter 17 - Handling Events
Events的类型
Device-dependent input events:mousedown, mousemove, mouseup, keydown, keypress, keyup, touchmove, gesturechange;
Device-independent input events: click
User interface events: focus, change
State-change events: loadstart, progress, loadend
API-specific events: dragstart, dragenter, dragover, drop, waiting, playing, seeking, volumechange etc
Timers and error handlers;


Handlers:
Event Handler Attributes: onclick=&amp;quot;&amp;quot;,window.onload = f();
addEventListener(event_name,function,[capturing event handler]): 添加事件, 最后的capturing通常为false;
removeEventListener(): 和上面的add相反;
stopPropagation(): js的事件触发是沿着DOM树向上传递的, 而通过stopPropagation()就能抑制这一环节;
preventDefault(): 很多元素有其自身的事件属性, 比如a标签的跳转, form元素的提交, 当我们想要取消其默认事件的发生时, 可以使用此函数来阻止其发生;



总的来说, 这一章内容其实很丰富, 但是其内容多数都是建立在之前的基本内容之上的. 着重需要知道的就是各种不同的事件, 其支持的元素, 类型以及触发的方式即可. 此类用法主要还是多用多练, 可以试试不同的event都包含那些属性~哈哈
Chapter 18 - Scripted HTTP
XMLHttpRequest:
Ajax: 由js端发起, 通过http请求和服务端交互;
Comet: 由服务端发起, js如果需要反应则使用Ajax回应, 通常由EventSource对象处理;
标准流程:new XMLHttpRequest()=&amp;gt;open(&amp;#39;type of request&amp;#39;, url,[],[username],[userpassword])=&amp;gt;setRequestHeader()=&amp;gt;send([content_body])&amp;lt;=onreadystatechange&amp;lt;=customized handler
通常GET类型的请求我们会通过encodeURIComponent来进行url拼接, 直接在url中体现, send()的时候就不用传值了;
POST类型的请求通常以json格式传递, 我们需要在send()中传入JSON.stringify()的数据, 当然如果是XML的POST, 那么直接传入对应的doc即可, 而像file这类的文件实体, 也是直接传入对应的实体即可;
起中Header部分我们只能自行设定部分, 而Content-Length,Date,Referer,User-Agent等等都由浏览器自动帮我们填上了;
readyState: UNSENT 0(open()还没执行); OPENED 1(open()已经执行);HEADERS_RECEIVED 2(headers已被接收),LOADING 3(正在接受返回),DONE 4(完毕).
XMLHttpRequest对象有一个onprogress的属性可以用来检测其执行进度, 它对应的属性值中包含了lengthComputable, loaded,total, 通过这三个就可以做一个简单的进度条跟踪请求的进度了;
如果是上传行为, 其onprogress属性存在于XMLHttpRequest_Object.upload.onprogress之中;
abort(): 用来取消请求;


EventSource:
标准流程: new EventSource(&amp;quot;url_to_server_file&amp;quot;) =&amp;gt; onmessage



Chapter 19 - The jQuery LibraryjQuery流行度的一大证据之一! 哈哈 我计划抽时间好好读一下jQuery的源码, 所以这里只是大概扫了一遍, 基本也都是应用层面的, 多数我差不多都使用过~哈哈
Chapter 20 - Client-Side Storage我在早先做chrome插件详见我的portfolio的时候, 写过一篇专门介绍web存储的文章. 恩, 当时写了不少patch系列, 哈哈, 改天写个脚本全部导出来转移过来.
恩
参考资料
JavaScript the Definitive Guide 6th edition 我现在就去写导入工具… 今天就到这里吧, 明天算是最后一篇就能完结本书啦~

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (8)</title><link>http://taoalpha.me/blog/2015/06/27/read-javascript-the-definitive-guide-8/</link><category>read</category><tag>js,reding notes</tag><pubDate>2015-06-27T12:00:00.000Z</pubDate><description>概述先说题外话: 昨天读到中途转去忙把以前的旧文章移植过来, 昨夜就已完成, 主要通过python解析了导出来的xml文本, 然后获取对应的时间信息和url信息组成符合jekyll规则的文件名, 再利用文本拼接出每个文件中固有的头和主体, 本来计划用html2text来把每个博文转为markdown, 不过后来源码有些问题, 对部分博文识别不好, 我也没时间细改, 所以就干脆拼接了html到主体中去.
主要导入了当初写的Patch系列和针对UX写的翻译系列. 分别归类到了Tech和DandP目录下. 有兴趣的可查看之~
今天来继续完结JavaScript: the Definitive Guide一书.
阅读笔记Chapter 20 - Client-side Storage
application cache:
为了丰富web app的功能, 或者说让web app更加的像native app, 就有了application cache这个机制, 从而让离线对于web app来说成为了可能;
application cache存储所有的静态格式, 包含html,css,javascript,images等等, 所有和web运行相关的资源文件;
application cache不作为常规cache而被轻易清理掉, 它会一直保持直到被要求删除或者用户手动删除;
Manifest: 为了能够让浏览器将网页存储到application cache里, 我们需要一个manifest文件, 并将之引入到html的head中&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;
此文件必须以CACHE MANIFEST为起始行;
列出所有需要加入application cache里的文件, 用相对路径, 相对与manifest文件而言;
#表示注释, 空行自动忽略;
此文件生效的前提是其MIME属性为text/cache-manifest, 即Content-Type这个header属性, 通常你需要自行在server中添加对应的规则;
如果网页由多个html组成, 则每个html都需要使用&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;声明, 指向同一个appcache文件即可;
一旦缓存, 则所有资源文件都从缓存中获取, 未列出的资源不予加载;


Complex Manifest:
manifest支持复杂规则, 其支持多个section, 包含了NETWORK:,FALLBACK:这两类, 还要加上默认的CACHE:;
NETWORK:: 所有不予cache必须要从网络获取的资源, 可以设定路径, 支持通配符*;
FALLBACK:: 如其名, 优先从网络获取, 无法获取时从本地获取, 所以其每行指定两个url;


Update:
对于Application Cache而言, 其更新主要依照manifest, 浏览器会自动在情况允许时帮助你查看manifest是否更新, 如有, 则重新缓存所有文件;
注意: 浏览器不会自动帮你查看缓存的文件是否更新, 只查看manifest;
通常可以使用#加一行version的注释行来强制更新;
applicationCache.onupdateready: application cache提供了状态函数来指示其更新的进度, 你可以针对其加以操作, 还包含onchecking,onnoupdate,ondownloading,onprogress,oncached,onerror,onobsolete;
除了上述事件外, 还可以通过applicationCache.status来探测其状态: ApplicationCache.UNCACHED =&amp;gt; (0),ApplicationCache.IDLE =&amp;gt; (1),ApplicationCache.CHECKING =&amp;gt; (2),ApplicationCache.DOWNLOADING =&amp;gt; (3),ApplicationCache.UPDATEREADY =&amp;gt; (4),ApplicationCache.OBSOLETE =&amp;gt; (5);
swapCache(): 清楚旧或者废弃的缓存;


Delete:
很简单, 删除manifest, 去掉html中的引用即可;





12345678910111213CACHE MANIFEST# appVersion: 1CACHE:myapp.htmlmyapp.cssmyapp.jsFALLBACK:videos/ offline_help.htmlNETWORK:cgi/
这就算是一个最基本的manifest了.
Chapter 21 - Scripted Media and Graphics
Images:
onmouseover: 鼠标hover移入事件;
onmouseout: 鼠标hover移出事件;
new Image(): 通过创建一个Image对象, 可以赋予其src属性从而实现预加载的功能;


Audio
(new Audio()).canPlayType(type): 检测某种类型的文件是否能播放;
play(): 播放;
initialTime: 初始播放进度;
duration: 文件总时长;
currentTime: 当前播放进度;
muted: boolean, 是否静音;
volume: 音量值;
controls: boolean, 是否显示控件;
loop: boolean, 是否循环;
preload: 是否预加载以及预加载类型, metadata表示加载时长,帧速等, auto表示尽可能预加载更多的内容, none什么都不预加载;
autoplay: boolean, 是否自动播放;
playbackRate: 播放速度(1.0 == normal speed);
readyState: 加载情况(0,1,2,3,4)=&amp;gt;(尚未加载, 已加载但当前位置未加载, 当前位置已开始加载但是不足以开始播放(下一帧还没加载好),已加载且足够播放但是不足以播放到结尾,加载基本足够可以播放至结束)
networkState: 当前媒体文件使用网络的情况(0,1,2,3)=&amp;gt;(还没开始, 没开始但可能已经加载完或者预加载设置为none, 正在使用中, 无法找到资源);
error: 错误信息(1,2,3,4)=&amp;gt;(用户手动停止, 类型正确网络不通畅, encoding问题, 类型不支持)


Video



SVG: Scalable Vector Graphics

SVG算是一种xml格式的矢量图类型;
最新的主流浏览器基本都支持直接在img中嵌入svg, 部分老的浏览器依然只支持使用object标签: &amp;lt;object data=&amp;quot;sample.svg&amp;quot; type=&amp;quot;image/svg+xml&amp;quot; width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;/&amp;gt;
一定程度上SVG很像canvas, 不过它是通过XML的属性来实现的(比如通过&amp;lt;line x1=&amp;#39;50&amp;#39; y1=&amp;#39;5.000&amp;#39; x2=&amp;#39;50.00&amp;#39; y2=&amp;#39;10.00&amp;#39;/&amp;gt;来画线);


Canvas

作为HTML5引入的一个可谓是最重要的标签之一, canvas的存在极大的丰富了网络的表现形式;
canvas和js的关系紧密, 因为其绘画的实现方式就是通过js;
canvas.getContext(&amp;#39;2d&amp;#39;/&amp;#39;3d&amp;#39;): 通过它创建的对象就可以在画布上尽情挥洒了;
很多canvas的函数本质都是数学坐标的公式运算!



我会在后面阅读的HTML5 Canvas中更加详细的研究canvas的各种用法~ 敬请期待~
  
Chapter 22 - HTML5 APIs
Geolocation:
navigator.geolocation.getCurrentPosition()
navigator.geolocation.watchPosition(): 在用户位置变化时唤醒;
navigator.geolocation.clearWatch()
实例 codepen


History Management:
pushState()
replaceState()
实例 codepen


Cross-Origin Messaging:
postMessage()
onmessage()
实例 codepen


Web Workers:
通常来说, js的执行是单线程的, 不支持多线程, 利用Worker可以稍稍的模拟下多线程;
Worker开启的执行不能对window和Dom有任何的操作, 和主线程只能通过postMessage()来交互;
Worker对象的工作域是WorkerGlobalScope, 完全和主线程工作域不同;
Worker支持importScripts来引入其需要的js库;
实例 codepen - 因为跨域问题, 所以这里不能执行, 不过代码很简单, 很好理解, 有兴趣的可以download到本地测试


Typed Arrays and ArrayBuffers:
HTML5 的数组类型变的更加强大, 开始出现类似Int8Array(),Uint8Array()等多种新形式;
实例 codepen


Blobs:
算是存储的一种新形势, 浏览器通常可以存储Blobs到内存或者硬盘中, blobs本身更是可以代表任何数据, 以二进制的形式;
实例 codepen


The Filesystem API: 开启本地文件交互时代;
实例 codepen


Client-Side Databases: 主要为IndexedDB;
实例 codepen


Web Sockets: 一种相对http来说的新网络协议;
实例 codepen



上面针对HTML 5的各个API给出了一个对应的实例, 毕竟看着具体的代码和例子才有意思哈哈
参考资料
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>像TED一样演讲</title><link>http://taoalpha.me/blog/2015/06/25/read-speaking-like-people-on-ted/</link><category>read</category><tag>reading notes,speaking</tag><pubDate>2015-06-25T09:00:00.000Z</pubDate><description>概要今天顺带读完了这本”像TED一样演讲”, 作者上一部和演讲相关的书是”乔布斯的魔力演讲”. 归纳了下书中的核心点, 记录分享给大家. 这一类的书干货其实能占到全书1/10就已经算不错了~ 所以一般看起来也比较快.
阅读笔记情感共鸣
释放你内心的热情 =&amp;gt; 热情可以传染;
掌握讲故事的艺术 =&amp;gt; 故事可以刺激并吸引人脑的注意力, 拉近你与听众的距离;
与演讲主题相关的个人故事;
与演讲主题相关的他人故事;
关于产品或者品牌的某个故事;


让演讲好像好友交谈一样自然;

制造新奇
给人们一个看世界的新视角;
设计让观众惊掉下巴的环节 =&amp;gt; 触发神经学家所说的讲情绪, 让记忆更加深刻;
用幽默给你的演讲加分;

令人难忘
严格遵守18分钟的时间规则 =&amp;gt; 有约束才有创造力;
抓住观众吸引力的魔法, 多感官体验 =&amp;gt; 让内容视觉化;
表现最真实的自己;

书中涉及到的TED(部分)
Bryan Stevenson: We need to talk about an injustice
Dan Ariely: Our buggy moral code
Truly sustainable economic development
Jennifer Granholm: A clean energy proposal – race to the top!
Amy Cuddy: Your body language shapes who you are
Robert Ballard: The astonishing hidden world of the deep ocean
Hans Rosling: The best stats you’ve ever seen
Mary Roach: 10 things you didn’t know about orgasm
Bill Gates: Mosquitos, malaria and education
Jill Bolte Taylor: My stroke of insight
Stephen Hawking: Questioning the universe
David Christian: The history of our world in 18 minutes

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript 阅读阶梯清单</title><link>http://taoalpha.me/blog/2015/06/10/read-must-read-list-of-javascript/</link><category>read</category><tag>js</tag><pubDate>2015-06-10T09:00:00.000Z</pubDate><description>缘起今天翻完了Getting Good With JavaScript, 对于其精华浓缩的设计很欣赏, 很适合有一定无基础或者有一定基础但觉得野路子出身想要夯实一下的人读. 而在文末的Appendix A中作者提到的这个 Rey Bango’s Must-Read list of JavaScript 确实在是本书的又一大收获. 特转来分享~
基础入门所谓入门自然是以打牢基础为目的, 所以下列书都是以基础概念为主, 算是领路之书(考虑到国情需要, 我都尽可能替换为豆瓣链接了):

JavaScript: The Good Parts
Professional JavaScript for Web Developers (Wrox Programmer to Programmer)
ppk on JavaScript, 1/e
Beginning JavaScript with DOM Scripting and Ajax: From Novice to Professional (Beginning: from Novice to Professional) 
Eloquent JavaScript

初窥门径一旦你入了门, 就可以修炼中级秘术了~ 可以看到有两条中级秘术和入门级是一样的, 哈 这就和基础功打的够扎实, 基本拳脚也能当秘术使唤的~

Professional JavaScript for Web Developers (Wrox Programmer to Programmer) 
JavaScript: The Definitive Guide 
Eloquent JavaScript - Online 
DOM Scripting: Web Design with JavaScript and the Document Object Model

高手之路一旦确保自己有了一个牢靠的基础后, 我们就可以开启自己的高手之路了.

High Performance JavaScript (Build Faster Web Application Interfaces)
Object-Oriented JavaScript: Create scalable, reusable high-quality JavaScript applications and libraries
JavaScript Patterns
Pragmatic Guide to JavaScript
Pro JavaScript Techniques
JavaScript Rocks
Secrets of the JavaScript Ninja

造物主模式下面这些就是正儿八经的神级模式了… 当你已经把javascript里里外外摸得门清的时候, 就可以试试调整下面的了… 有一种去看汇编原理的感觉了… 开始研究底层源码了…

Standard ECMA-262 ECMAScript Language Specification 3rd edition (December 1999) – PDF File
Standard ECMA-262 ECMAScript Language Specification 5th edition (December 2009)

JS相关blog分享除了书籍之外, 作者还推荐了一些可以订阅查看的博客~ 我根据其目前存活情况, 主题变更情况简单筛选了下(多数都已经失效了)~

DailyJS - 强烈赞同, 很值得订阅!
JavaScript Weekly Newsletter
YUI Theatre
Rey Bango 作者本人哈哈

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (2)</title><link>http://taoalpha.me/blog/2015/06/18/read-javascript-the-definitive-guide-2/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-18T10:00:00.000Z</pubDate><description>概述作为JS中的一等公民, function(函数)始终是JS的核心中的核心. 所以这里单独用一篇笔记来记录JavaScript: the definitive Guide一书第八章的内容. 主要介绍了函数的定义, 作用域, 参数, 声明以及执行等基础知识, 另外也着重介绍了其高级用法中的closure. 我将自己觉得重要的, 值得记录的部分都作为心得摘抄如下:
心得arguments对象对每一个function而言, 都自动会有一个内置的arguments对象, 用它就可以访问传入的参数了. 通常来说arguments对象我们只会用在不定长传参的函数上, 但arguments本身带有的一个函数却是可以在某些时刻发挥重要作用的~ 这个函数就是callee函数:
12345678// 递归自我调用函数在解决一些问题的时候是很常用的, 而通常情况下我们都会在函数内调用本函数名即可, 但是如果我们需要实现自我调用的函数正好是一个无名函数呢?// arguments.callee 即调用当前执行的函数function(x)&amp;#123;return x*arguments.callee(x-1)&amp;#125;// 如上, 就实现了一个很简单的&amp;gt;2阶乘计算了
需要特别注意的就是callee作为arguments对象的一个方法, 是可以跟随arguments作为参数传递的, 而且其作为参数的时候保持其所指代函数不变.
既然说到arguments, 就多说两句喽. 首先arguments算是一个类array的object. 它本身具有array的一些特性, 比如可以直接调用length函数(通常的object是不能通过.length直接调用获取长度的, 需要使用Object.keys(object_name).length才能获得). 但是它本身和array.length有很大的差别, 其中最大的一个差别就是: 无法通过.length直接更改数组长度.
123456var a = [1,3,4]a.length = 5console.log(a)// output: [1,3,4,undefined x 2](function(x)&amp;#123;arguments.length = 5;console.log(arguments)&amp;#125;)(10,1,2)// output: [10,1,2]
可以看到通过对arguments.length直接赋值, 并不会影响其本身的长度, 这一点和array本身有很大的差别.
PS. 上述示例是增加长度, 其实缩减长度也是一样的, 多余的元素会被自动删除. 所以, 通过直接向array.length赋值也算是一个修改array长度的方法喽~
PSS. 通常如果一个函数接受参数比较多的时候, 为了预防因为参数顺序而产生的问题, 可以采取传json格式的object作为参数, 这样就能够通过key而不根据顺序获取参数了.
Function的property请先看下述代码:
1234567891011f.temp = &quot;test&quot;function f(x)&amp;#123;  console.log(arguments.length);  console.log(arguments.callee.length);  console.log(f.temp);&amp;#125;f(1,2)// output: 2 1 &quot;test&quot;
首先, 我们看一下我们前两个输出值:
  如上所述,arguments.length即代表传入参数的数量, 我们传入了两个参数, 所以这里输出2, 没有任何问题. 那么后面的arguments.callee.length又是什么呢? 为什么它输出的是1呢? 
  根据之前的介绍, 我们当知道arguments.callee是代指当前的函数f(), 那么对应的arguments.callee.length即我们的函数f的length了. 对于Function这个对象而言, 它所拥有的length这一属性特指其声明的参数数量, 我们应该知道JavaScript作为一个很宽松的语言, 其函数定义后接受的参数是不定长的, 即便传入参数与函数声明的参数不相等也是不会抛出异常的, 那么有时候我们需要获取确保函数接受的参数和其声明的参数数量一致, 就可以使用函数自身的length属性来实现;
其次, 我们自定义了一个f的属性temp, 但是我们实在函数定义之前赋予这个属性的, 为什么依然能够在函数运行中输出呢? 
  这主要是因为js的执行顺序所致. js在载入执行过程中, 首先会将内部声明的函数都定义之后才会正式由上至下的逐次执行. 所以这里虽然我们把f.temp写在了函数定义之前, 但是js执行过程中, 还是首先定义了函数f, 接着才开始运行我们的f.temp赋值语句. 自然就不会报错说f没有定义了~
PS. 其实不止是Function, 即便是普通的变量声明, 也是编译和执行分开进行的, 比如var a = 2;也是拆解为var a; a = 2两步执行的, 而声明都是发生在编译过程, 待编译过程全部结束后, 才会由上到下一次执行, 这也是为什么, 单纯的声明可以出现在代码的任意部位都不会影响其所在作用域的生效, 不会爆出not defined的错误;
reserved word, identifier, keyword这三个作为基础知识, 可以说是每门语言都共通的概念,  但很多时候我们都不会用到或者不会特意去区分这三个名词, 而最近因为看原版书, 经常会出现三个词的交叉, 所以这里特别google了以下, 试图总结下三者的区别:

identifier: 通常我们把我们定义的变量名, 函数名, 类名, 标签名,宏定义名, 类型名等称为identifier, 取其标识之意, 用以作为其名称以便代用;
reserved word: 与identifier相对, reserved word则是指由语言规定而保留的一些词, 这些词有着特定的用途而不能被用作identifier;
keyword: 作为语言语法的组成部分之一, keyword通常都会有着特定的含义, 绝大多数的keyword都是reserved word, 但也有少量语法中存在keyword不是reserved word的情况, 比如fortran就没有reserved word的概念, 它的所有keyword都可以用作identifier;

reserved word和keyword确实在很大程度上是共同的, 除了上述说的类似fortran语言这种情况外, 也存在reserved word不是keyword的情况, 比如java中的goto就是一个reserved word, 但本身又不是一个keyword, 所以可以说goto这个词基本在java中是完全废弃的~ 那他们为啥要定义这个goto呢?? 有一种说法是这样情况通常是为未来版本预留的~ 还有一种说法是JVM作者James Gosling最初加了goto的支持, 但后来发现完全没必要, 就又去掉了, 但是为了兼容性问题,也一直没有把goto从reserved word此表中删去.
PS. 很多时候也有人完全不区分reserved word和keyword的区别, 完全等同二者为”不能用来做identifier的词”.
closure - 闭包在javascript中, 一个function由两部分组成: 函数执行的代码以及代码执行的环境. 而这两个组合到一起后也有个专属的名称, 即closure. 不过单独一个独立函数的closure并没有什么值得说的意义, 因为其执行的环境, 即我们称之为scope的东西, 随着函数的执行开始与结束会自动的被创建并清理掉, 所以通常情况下closure都单指在嵌套函数中. 当存在嵌套的函数时, 并且函数之外存在一个reference指向函数的话, 事情就变得好玩多了:
12345678910111213141516171819202122232425262728function f()&amp;#123;  var id = 1;  return function()&amp;#123;console.log(id++)&amp;#125;&amp;#125;f()();f()();f()()// output: 1,1,1// 每次我们调用`f()`,都会自动创建一个包含了其局部变量`id`的对象, 而嵌套的函数`f()()`会自动继承母函数的作用域;// 但每次随着调用结束, 因为没有任何外部引用, 所以创建的对象都会自动的被回收, 如此就导致每次调用`f()()`都会输出1了;var k = f();k();k();k()// output: 1,2,3// 同样是调用`f()`, 但是我们首先引入了一个新的变量`k`引用`f()`函数; // 这样随着`f()`的调用和结束, 其创建的`call`对象(即包含了局部变量id的那个对象)就因为还存在外部引用而得以保留// 所以后面连续调用`k()`的过程中, 本身的嵌套函数就始终共享着`call`对象的作用域, 如此每次输出的时候都是先获取了局部变量id, 然后在执行`id++`,所以输出为1,2,3// 不喜欢`f()()`这种调用方式, 也不想单独创建新变量来增加引用? 当然可以, 只需要借助下`anonymous function`即可:var f = (function()&amp;#123;    var id = 1;    return function()&amp;#123;console.log(id++)&amp;#125;  &amp;#125;)();f();f();f()// output: 1,2,3// `anonymous function`是自执行的函数, 这里相当于把之前的`var k = f()`以及`f()`的声明定义合二为一了.
可以说上述基本就是closure最基本的内容了, 而closure作为js的高级用法之一, 掌握了它, 你就能做很多有意思的操作了. 一个简单的例子就是: 你可以参照closure的原理来模拟实现浏览器探查元素(inspector)的breakpoint功能.
因为原作trimpath上的文章已经无法访问, 所以转载了一个类似的如下, 略作了简单的修改(加了几句更友好的提示和显示每一步的运算结果):
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// This function implements a breakpoint. It repeatedly prompts the user// for an expression, evaluates it with the supplied self-inspecting closure,// and displays the result.  It is the closure that provides access to the// scope to be inspected, so each function must supply its own closure.// // Inspired by Steve Yen's breakpoint() function at// http://trimpath.com/project/wiki/TrimBreakpoint//function inspect(inspector, title) &amp;#123;    var expression, result;    // You can use a breakpoint to turn off subsequent breakpoints by    // creating a property named &quot;ignore&quot; on this function.    if (&quot;ignore&quot; in arguments.callee) return;    while(true) &amp;#123;        // Figure out how to prompt the user        var message = &quot;&quot;;        // If we were given a title, display that first        if (title) message = title + &quot;\n&quot;;        // If we've already evaluated an expression, display it and its value        if (expression) message += &quot;\n&quot; + expression + &quot; ==&amp;gt; &quot; + result + &quot;\n&quot;;        else expression = &quot;&quot;;        // We always display at least a basic prompt:        message += &quot;Enter an expression to evaluate, or just click cancel to see the next step of current calculation.&quot;;        // Get the user's input, displaying our prompt and using the        // last expression as the default value this time.        expression = prompt(message, expression);        // If the user didn't enter anything (or clicked Cancel),        // they're done and so we return, ending the breakpoint.        if (!expression) return;        // Otherwise, use the supplied closure to evaluate the expression        // in the scope that is being inspected.         // The result will be displayed on the next iteration.        result = inspector(expression);    &amp;#125;&amp;#125;function factorial(n) &amp;#123;        var inspector = function(x) &amp;#123;                return eval(x);        &amp;#125;        inspect (inspector, &quot;Entering factorial()&quot;);        var result = 1;        while (n &amp;gt; 1)&amp;#123;                result = result * n;                n--;                inspect(inspector, &quot;factorial() loop with current result:&quot;+result);        &amp;#125;        inspect(inspector, &quot;Exiting factorial()&quot;);        return result;&amp;#125;inspect(function (x) &amp;#123;return eval(x);&amp;#125;, 'Hello')factorial(5)// 通过closure, 它就可以检测factorial执行的各个环节, 从而更容易的找到你在不同环节的问题.
虽然closure让你可以写出更加复杂的js代码, 但是本身closure的使用还是要慎重的, 因为closure需要存储函数对象在内存中而不销毁, 所以如果函数主体庞大, 那么对于内存的压力和运行性能都是会有影响的~
Function constructor类似Array, String等都有着一个对应的类, 可以允许你通过new来创建对象. Function也有自己对应的Function()类, 可以通过:new Function()来创建函数, 其接收不定长参数, 最后一个参数始终作为函数运行主体. 不过通常来说这种方法定义函数远没有我们常用的function关键词来的方便, 所以使用上倒是少了很多~ 不过有几点还是值得注意的:

new ClassFunction() 是把function作为constructor的一种用法, 你可以简单的理解为: var cc = new ClassFunction(params) ==&amp;gt; var cc = new Object();ClassFunction.call(cc,params)
new Function()不接收函数名参数, 即其创建的都是anonymous function;
new Function()不继承作用域, 几遍其是在嵌套函数中定义, 也只继承global域, 不会继承上层函数的作用域;

谜题12345678910111213var name = &quot;The Window&quot;;var object = &amp;#123;  name : &quot;My Object&quot;,  getNameFunc : function()&amp;#123;    console.log(this);    return function()&amp;#123;      return this.name;    &amp;#125;;  &amp;#125;&amp;#125;;console.log(object.getNameFunc()());// output: Object&amp;#123;name:&quot;My Object&quot;&amp;#125;; &quot;The Window&quot;
上述定义中, 为什么嵌套函数没有继承上层函数的this呢? 反而继承了全局的this?
猜测解答: this这个关键字是个比较特殊的关键字, 它具有一个很有趣的特点就是: 当一个函数作为函数而不是方法来调用的时候, this指向的是全局对象, 只有当它是方法的时候, 其指向的才是所属对象; 题目来源阮一峰博客. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (1)</title><link>http://taoalpha.me/blog/2015/06/17/read-reading-javascript-the-definitive-guide-1/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-17T10:00:00.000Z</pubDate><description>概述“JavaScript: the definitive guide”可谓是JS入门必读数目之一了. 今天正好读到第7章, 做一简单总结. 前7章的内容都集中在JS中的基本知识上, 包含了:

数据类型: 最简单的primitive datatypes: string, number, boolean , 两个空值类型: null, undefined(通常认为空值类型属于promitive的一种),以及稍微复杂点的: object类型;
变量问题: 变量规则, 变量作用域问题;
基础表达式和操作符: 操作符的优先级问题, 多操作数和单操作数以及执行顺序等;
陈述语句: 包含了if/for/while/do/with/switch(case)/break/continue/return/var/identifiers/empty statement等等;
Object: json格式object以及常规的array类型对象的分别介绍以及自身结构属性, 异同点等;

心得break/continue 后接 label:  break/continue是通常用于for/white/do等循环语句中用以做状态判断的, 但本身其还有另一种用法, 就是通过后接标记语句的用法来是break或者continue能针对标记语句操作, 比如下面这个跳出多层嵌套的例子:
12345678910test:&amp;#123;  for(var i = 0; i&amp;lt; 10; i++)&amp;#123;    for(var j = 0; j&amp;lt; i*5; j++)&amp;#123;      console.log(j);      if(j==3) break test;    &amp;#125;  &amp;#125;&amp;#125;// continue test; 也是同样的用法
但需要注意的即使:

continue 语句(带有或不带标签引用)只能用在循环中;
break 语句(不带标签引用),只能用在循环或 switch 中;

with 语句在js中经常涉及到变量作用域的问题, 而with语句的存在就是可以将某个object放入到其子语句的作用域链中, 什么意思呢? 首先通常来说, 在函数内, 其作用域链由全局作用域(全局对象)和本地作用域(local对象)组成, 我们在引用变量的时候就是在作用域链上逐个查询. 而with的作用就是把某个object插入到作用域链中去, 从而能够直接访问其子元素:
1234567891011a = &amp;#123;&quot;nae&quot;:&quot;hhh&quot;,&quot;test&quot;:&quot;results&quot;&amp;#125;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;nae = &quot;sl&quot;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;// 证明with引入的作用域甚至还在global域之上
不过呢, 通常很少人会去用with的, 因为它过于吃力不讨好了, 其对性能的影响是没有什么优化空间的, 与其使用with, 不如直接定义全局变量或者变量的简写(有一种with的用法是为了省略书写冗长的变量名)更为方便了.
sort内嵌比较函数:sort()本身作为array类型内置的几个函数之一, 默认通常是按照字母表来排序的, 但是其本身也是支持自定义排序规则的, 只需要我们把规则传入即可:
12345678910// 以数字序列为例var a = [12,3,5,8]a.sort()// output: [12,8,5,3]a.sort(function(a,b)&amp;#123;return a - b;// 返回&amp;lt;0, 则a排在b前面, &amp;gt;0 则b在前面, =0则表示相等;&amp;#125;)// output: [3,5,8,12]
利用这一方法你就可以定制你的排序规则了, 甚至可以按照奇偶性排序都可以做到~ 比如 偶数在前: return a % 2-b % 2; 哈哈
concat,slice,splice这三个函数分别都是对array类型的元素进行母串增减获取子串而出现的, 其中有几点需要注意的:

concat()函数支持数字多参数分别传入, 也支持数组传入的形式, 效果都是一样的, 但是concat()不支持递归解套, 即如果你传入的是多层嵌套的数组, concat()只会解套一次; 此外, concat()的操作是不影响母串的;
slice和splice都可以用于获取子数组使用的, 其区别主要有两点, slice()接受的两个参数都代表的是index, 分别是起始次序到终止元素次序, 取子串时计算首位参数的元素,不计算第二位参数所代表的元素, 而splice则传入的两个参数分别是起始元素次序和要截取元素个数,即同样都是(1,2), 后者代表截取第二个元素起始共计两个元素的子串, 前者则只获取第二个元素; 此外, slice()返回子串而不修改原数组, splice()则会在返回子串的同时修改原数组(原数组为去除子串的结果);
splice()除了可以用获取子串外, 还能用于给母串添加元素. splice()可以接受超过2个参数, 从第三个参数起, 多出来的参数都是作为插入元素的, 执行的顺序则是删减完后当前位置插入, 即splice(2,2,1,3,4)表示的就是删掉第三个元素开始共计两个元素, 然后在同样的位置插入1,3,4三个元素, 同时, splice()也接受数组传入, 但是它不主动进行解套;

除了splice(), 上面的sort()的操作也是针对a数组进行的操作, 其结果也是针对a生效的, 即a的值是会被改变的;
pop,push,shift,unshift除了splice()之外, 我们通常用于直接操作母串增减的就是pop,push,shift,unshift四个了, 下面简单介绍下四者的区别:

pop, push分别代表对母串最后一个元素的进出栈操作, pop是弹出最后一个元素, push则是在最后一个元素的后面继续压入新元素, 同样也支持数组元素压入, 但是不自动解套;
shift, unshift和pop,push基本类似, 不同的地方在于操作的位置和后者相反, 是在栈头的位置, 即首位元素处; shift用于移出首位元素, unshift用于在首位增加元素, 接受数组, 也不自动解套, 同时多参数传入时, 作为整体一次性压入, 即unshift(2,3),压入后为[2,3,...].

这里比较独特的就是unshift多参数的压入问题了, 按我的预期其实是逐个元素压入, 这样顺序就是和传参相反, 但结果确实整体压入, 顺序与传参一致了~
谜题书中第七章介绍说在array中如果直接赋值的index是超限(&amp;gt;2^32-1), 负值或者对应表达式的结果是此类值时, 会自动转为string传入定义, 这就引发了一个问题: 一旦如此定义后, 此变量还是array吗?
我在console中简单的测试了下:
1234567891011121314151617181920var a = [1,2,3]// a.length == 3a[-1.2] = &quot;hehe&quot;a// output: [1,2,3]  where is a[-1.2] ?a[-1.2]// output: &quot;hehe&quot;  WTF???a.length// output: 3 ??console.log(a)// output: [1,2,3,-1.2:'hehe']console.log(a.length)// output: 3a instanceof Array// ouput: Truea[&quot;h&quot;] = &quot;hh&quot;a// output: [1,2,3]console.log(a)// output: [1,2,3,-1.2:&quot;hehe&quot;,h:&quot;hh&quot;]
问题: a依然还是一个Array(亦或者不是?), 但用json定义的方式赋值的那几个值还是有效的, 可获取的, 但是为什么直接print出来的时候没有这些值呢, 甚至长度都不包含定义的这几个指? 为什么console.log()可以打出来呢?
猜测解释: a最初被定义为array, 但是却被json方式传值, 存储到了其内存中, 但是调用a时依然按照array来打印, 所以会自动滤除掉不符合array的几个值(只会按照index来找值). 但是console.log()是打出来其存储内容, 所以就按照其内存存储形式打印出来了.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (3)</title><link>http://taoalpha.me/blog/2015/06/22/read-javascript-the-definitive-guide-3/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-22T04:00:00.000Z</pubDate><description>概述先说点不相关的… 为了更好的阅读, 所以以后读书笔记相关的博文都会分拆成4个部分:

概述: 算是阅读总结摘要以及类似这段话之类的声明介绍等等;
阅读笔记: 这部分主要以阅读过程中的记录为主, 会比较杂, 基本算是逐点记录, 评判相对主观;
心得: 这部分则主要为笔记的延伸, 算是对笔记的一种补充或者说自己的阅读理解消化所得, 有时候也会覆盖到一些使用架桥等等;
谜题: 这里主要记录一些没有完全理解的部分, 会加上自己的猜测解答, 当弄懂后会更新正解;

DONE.
本篇是博主重新翻阅了”JavaScript the Definitive Guide(第六版)”的前4章内容(之前 阅读笔记-2均是第五版的)后的读书笔记以及心得体会. 内容主要覆盖js的基本用法, 考虑到重复, 这里主要是在上两篇的基础上查漏补缺.
阅读笔记Chapter 2 - 基础知识JS能识别的whitespaces:
常规空格: \u0020 # 即url中常见的%20
Tab(制表符): \u0009 # js中常见的\t
Vertical Tab: \u000B # \v
Form Feed(翻页/页码分隔符): \u000C # \f
Nonbreaking Space(不间断空格): \u00A0  # 通常在html中用来阻止默认连续多空格自动归一的性质(auto collapsing)而使用&amp;amp;nbsp;, 同时因为软件处理的需要, 使用&amp;amp;nbsp;能够防止相应的处理器将普通空格转为行分隔;
Byte order mark: \uFEFF
any character in Unicode category Zs

JS能识别的line terminators:
line feed: \u000A # \n
carriage return: \u000D # \r
line separator: \u2028
paragraph separator: \u2029

值得一说的是, js是支持unicode作为indentifier的合法字符的, 但是上述这些则不在其中.
JS的”Unicode Escape Sequences”类似”\u00E9”这种结构的字符在js都代表一种特殊的字符:”unicode”. 如果你在js中使用这些字符, js会自动将其编译为对应的字符(如果是在js的注释中, 则不会编译, 而是以ascii对待), 比如: 示例就会编译为”é”. 而在js中, 这种对等关系是支持的, 即 &amp;quot;\u00E9&amp;quot; === &amp;quot;é&amp;quot;是为真的.
但是一定要慎用… 因为unicode变化过多, 有时候输出看起来一样的字符, 其本质不一定一样: &amp;quot;e\u0301&amp;quot;的输出也是”é”, 但是它相当于是&amp;quot;e&amp;quot;+&amp;quot;\u0301&amp;quot;组成的.
JS中的&amp;quot;;&amp;quot;在JS中, &amp;quot;;&amp;quot;作为语句结尾并不是必须的, 只有当多语句同行的时候, &amp;quot;;&amp;quot;才是必须的. 当你没有&amp;quot;;&amp;quot;的时候, js会自动为你添加合适的&amp;quot;;&amp;quot;. 通常它会自动将它没有&amp;quot;;&amp;quot;无法解析代码时候遇到的换行处加以&amp;quot;;&amp;quot;(除了类似return,break, ++, –等, 它会自动将其后的行分隔符作为&amp;quot;;&amp;quot;对待.):
1234567var aa=3console.log(a)// output: 3// js在第一个换行处识别了其语句分割的意义, 但是在 a = 3 的两个分割处都因为它可以识别合并后的语句所以没有作为`&quot;;&quot;`处理.
但是上述的成功不意味着js的智能, 更多时候如果我们不合适的使用&amp;quot;;&amp;quot;, 会造成很多奇怪的问题的, 比如以(, [, /, +, -为起始的语句很可能会被误认为是前一语句的延续. 所以通常来说, js的编码还是比较鼓励使用&amp;quot;;&amp;quot;作为语句结尾的.
Chapter 3 - 数据类型Number:
Global viriables: Infinity,NaN
Global Objects: Math,Number

Tips:

NaN 具有唯一性, 其不等于任意值, 包括它自己, 0/0会产生’NaN’, 但是0/0 != NaN, 如果需要判断一个变量是不是NaN, 需要使用isNaN()这个内置的函数;
Infinity &amp;lt;==&amp;gt; Number.POSITIVE_INFINITY &amp;lt;==&amp;gt; 1/0
-Infinity &amp;lt;==&amp;gt; Number.NEGATIVE_INFINITY &amp;lt;==&amp;gt; -1/0
Binary Floating-Point会导致小数级错误, 比如0.3-0.2 != 0.2-0.1, 这个属于计算机本身因为二进制编码的原因所致, 所以在比较数字大小的时候要格外小心;

String:
immutable ordered sequence of 16-bit values

Tips:

string的长度都是按照16-bit来计算的, 所以当如果一个字符超过了16-bit, 则会按照多的计算. 比如: e - \ud835\udc52, 就需要按照两个16bit计算, 即其长度应为:”2”
从ECMAScript 5之后就允许string跨行定义了, 只需要在换行的地方加上一个反斜杠\, 即可.
转义字符\如果加在普通字符前, 不会产生任何效果;
typeof null =&amp;gt; Object , typeof undefined =&amp;gt; undefined;
null == undefined, null!==undefined =&amp;gt; True

类型转换javascript是一个很宽松的语言, 我们不需要预先定义变量类型, 而在运算以及执行过程中, js也会自动的帮助我们进行类型转换, 当然为了更好的借助这一特点, 了解下图中的js转换类型的规则还是非常有必要的.

其中object转换 primitive datatype 的话, 一般会按照如下步骤进行:

首先会默认调用toString()函数, 你可以自行定义这一函数, 如果toString()返回结果正常, 则转换结束;
如果toString()未定义, 或者返回结果非primitive datatype的话, 会自动调用valueOf()函数, 同上一步;
而如果两个都没找到, 那么js将会抛出TypeError;

而根据要转换的是string还是number而交换1,2两步( string 的话先调用toString(), 且返回值必然会转为string; 如果是number的话, 则先找valueOf(), 返回结果为number). 当然至于boolean的话, 所有的object转换到boolean都是true.
Array转换string的时候默认的toString()就是一个join()调用~ Function的话, 则也可以自己定义toString()函数.
Tips:

x + “” // Same as String(x)
+x // Same as Number(x). You may also see x-0
!!x // Same as Boolean(x). Note double !
在ECMAScript 5的strict模式下, 所有变量君需要声明才能赋值, 否则会报错;

Chapter 4: Expressions and Operators
上图为按照优先级顺序排列下来的操作符(横线分隔的同一组块之间的级别相同).
Tips:

运算顺序不影响赋值顺序, 赋值顺序始终都是严格从左到右的, 比如:h = x+y+z, 那么赋值顺序始终都是h-&amp;gt;x-&amp;gt;y-&amp;gt;z; 通常情况下, 这一赋值顺序不会影响之后的计算顺序, 对结果基本没什么影响, 除了一种情况:
如果前变量的赋值会影响到后面变量的值的话, 比如共用同一个变量, 那么这种情况下, 赋值顺序就可能会对结果产生一定的影响了. 最简单的例子就是z = 2;y = function(){z = 3;return 1};, 因为y是一个函数, 而它的执行会改变z的值, 所以y()+z和z+y()的结果就是不相同的.

“+”运算符中的类型转换:

string优先, 只要有两个操作数中有一个是string或者是有toString()的object, 那么其都会按照string来进行链接运算;
除非两个都是非string, 才会进行加法运算;
当”+”作为单操作数时, 则意味着将操作数向number类型转换;


&amp;amp;&amp;amp;运算符如果第一个为false, 则不执行第二条判断, 所以可以用这个方法来代替if: (a==b) &amp;amp;&amp;amp; alert(&amp;quot;a equals b&amp;quot;)就相当于if(a==b) alert(&amp;quot;a equals b&amp;quot;).

!(p &amp;amp;&amp;amp; q) === !p || !q
!(p || q) === !p &amp;amp;&amp;amp; !q
a op= b 和 a = a op b通常是等价的, 除非a本身的重复赋值会有副作用, 比如 a[i++] += 1和a[i++] = a[i++] +1就不一样, 因为后者前后两个i不同了.
eval()函数会继承当前的scope, 除非eval()被赋予某个新的reference, 那样的话只会使用global的scope;
void操作数很少用到, 它是个单操作数的操作符, 其用法就是丢弃操作数的返回结果, 然后返回 undefined…

心得whitespaces 和 line terminators通常在js里面我们使用\s来统一代表所有其可以识别的whitespace, line terminators. 如下例:
1234567var k = 'asd \t asdasd \na asd \f asda dad\rasd\u2028asd\u2029\u00A0'k// output 里面有两个换行的符号, 我这里为了演示方便就不换行了k.replace(/\n/g,'-')// 同上,里面的&quot;\r&quot;我也不换行了k.replace(/\s/g,'-')// output: &quot;asd---asdasd--a-asd---asda-dad-asd-asd--&quot;
因为在console中输出的时候是不换行的, 所以有时候单单看console输出的话, 类似这种编码问题所致的错误就找不出来, 为了省事, 我们可以统一使用\s来代表所有此类符号.
谜题Q: 按照正常来说Number.MAX_VALUE加上一个数应该就会自动转为Infinity, 但实际上, 测试过程中发现, 只有当Number.MAX_VALUE加上一个足够大的数后才会等与Infinity, 这是为什么?
1234567Number.MAX_VALUE// output: 1.7976931348623157e+308Number.MAX_VALUE +1// output: 1.7976931348623157e+308...Number.MAX_VALUE + Math.pow(10,1000)// output: Infinity
正解: the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign.

IEEE 754
In the following two rounding-direction attributes, an infinitely precise result with magnitude at least bemax ( b − ½ b^(1-p) ) shall round to ∞ with no change in sign; here emax and p are determined by the destination format (see 3.3). With:

roundTiesToEven: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with an even least significant digit shall be delivered

roundTiesToAway: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with larger magnitude shall be delivered.



ECMAScript does not specify which of the round-to-nearest, but it doesn’t matter here because both gives the same result. The number in ECMAScript is “double”, in which

b = 2
emax = 1023
p = 53,

_so the result must be at least 2^1024 - 2^970 ~ 1.7976931348623158 × 10^308 in order to round to infinity. Otherwise it will just round to MAX_VALUE, because that is the closer than Infinity.Notice that MAX_VALUE = 21024 - 2971, so you need to add at least 2^971 - 2^970 = 2^970 ~ 9.979202 × 10^291 in order to get infinity._
Q: &amp;#39;0&amp;#39; == false 是 true, 为什么 null == false 就是 false呢?
猜测解释: ==这样的是比较value的, 而 null转换为boolean类型为false, 并不意味着两者的value是相同的. ==只会比较value, 而不会进行转换. 也即true, false两个boolean类型的其value也是1,0. 而null和undefined的value则不同, 前者为空, 后者为无.
参考资料:
JavaScript the Definitive Guide 6th edition
Unicode Property
List of Unicode Characters
编码历史介绍

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (4)</title><link>http://taoalpha.me/blog/2015/06/23/read-javascript-the-definitive-guide-4/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-23T07:00:00.000Z</pubDate><description>概述第六版和第五版的最大区别在于ECMAScript 5的引入, 这是目前发布的最新的js版本, 有着最新的属性和函数, 目前主流浏览器基本都已经完全支持. 本文为阅读5-9章内容的笔记总结, 主要是覆盖了JS中的语句和典型对象.
阅读笔记Chapter 5 - Statements
switch/case中使用的是===进行比较判断的, 而不是==;
with带入scope chain的对象只有读取权限, 没有写入功能, 即with后, 可以获取其代入的对象, 但其内声明的变量都依然归于gloabl或者local之中;
debugger是ECMAScript 5引入的一个新的statement, 起主要作用是和浏览器结合使用, 用于创建断点以便查错使用;
use strict也是ECMAScript 5引入的, 严格来说不算statement而是directive, 不过两者很是相近; 其使用必须位于js整体的起始位置或者是一个function主体的起始位置;
use strict的使用会开启代码的strict mode, 为了提升效率, 错误追踪以及更好的安全性, 其语法要求会更加严格, 简单列举如下:
停用with语句;
所有变量必须声明才能调用;
所有独立声明的函数而非对象的方法定义的, 其this域都默认为undefined, 而函数如果通过apply,call调用, 其this域为传入对象;
对未声明变量的赋值或者不能写入的对象进行写入, 都会抛出异常;
eval调用会自动创建临时局部scope, 不再能直接对母域新建声明了;
arguments成为传入参数的硬拷贝, 和传入参数名之间不在绝对相等, 即改变一方不会引起另一方的改变, 同时停用其caller,callee方法;
delete用于变量, 函数或者函数参数的时候会抛出异常, 操作对象的某个未声明属性也会抛出异常;
对象(包括函数)创建中不能出现同名属性(参数);
直接声明的八进制数是不允许的(即0开头的数字);
eval,arguments作为keywords对待, 不能赋值, 或赋予其他变量, 也不能用于identifier;




Chapter 6 - Objects
Property Attributes (ECMAScript 5之后引入可自定义配置, 之前默认三者皆有.)
writable: 可赋值;
enumerable: 可递归;
configurable: 可配置 - 可删除也可修改;


Object Attributes
portotype: 指向当前对象的属性继承对象;
class: 指代对象所属类别;
extensible: 指示当前对象是否能够新增属性 (ECMAScript 5引入);


Object Categories and Property Types:
native object: js中内置的对象, 包含Arrays, functions, dates, regular expressions等;
host object: 由js运行环境所定义的对象, 比如常见的浏览器, 就包含了HTMLElement对象;
user-defined: 执行js代码的时候创建的对象;
own property: 直接由对象中定义的属性;
inherited property: 由对象的prototype object继承来的属性;


Prototype:
任何一个对象(除了Object.protytpe)的出现都必然包含了第二个对象的存在: new Array() =&amp;gt; Array.prototype;
Object.prototype是唯一一个没有母继承的对象了, 它是最顶部的类;
类似new Array() =&amp;gt; Array.prototype =&amp;gt; Object.prototype这样的两个prototype就组成了Array的prototype chain;
Object.create() 是ECMAScript 5引入的新的创建对象的方法, 其接受两个参数, 第一个参数会作为新建对象的prototype传入, 第二个则是用来描述新对象的属性的. 如果你传入null, 则新建对象是完全没有prototype的, 只有Object.create(Object.prototype)才是等价于我们常用的{} or new Object();
获取某个object的未定义属性将返回undefined, 但是获取undefined或者null的某个属性则会抛出异常;


getter &amp;amp;&amp;amp; setter
ECMAScript 5新引入的两个accessor properties, 分别对应某个属性的调用和赋值;
只有setter的属性只有写入权限, 只有getter的属性则是只读权限;


property attributes
value, writable, enumerable, and configurable
对应的accessor property: get, set, enumerable, and configurable
Object.getOwnPropertyDescriptor(object_name, property_name) 获取某个属性的特征描述;
Object.defineProperty(object_name, property_name,{property_attribute:attribute_value}) 对某个属性设定其特征描述;



下例即为利用Object.defineProperty自定义的一个extend()函数:
123456789101112131415161718192021222324252627282930// Example 6-3. Copying property attributes/** Add a nonenumerable extend() method to Object.prototype.* This method extends the object on which it is called by copying properties* from the object passed as its argument. All property attributes are* copied, not just the property value. All own properties (even non-* enumerable ones) of the argument object are copied unless a property* with the same name already exists in the target object. */Object.defineProperty(Object.prototype,  &quot;extend&quot;,  &amp;#123;    writable: true,    enumerable: false,    configurable: true,    value: function(o) &amp;#123;      // Define Object.prototype.extend      // Make it nonenumerable      // Its value is this function      // Get all own props, even nonenumerable ones      var names = Object.getOwnPropertyNames(o); // Loop through them      for(var i = 0; i &amp;lt; names.length; i++) &amp;#123;        // Skip props already in this object        if (names[i] in this) continue;        // Get property description from o        var desc = Object.getOwnPropertyDescriptor(o,names[i]);        // Use it to create property on this Object.defineProperty(this, names[i], desc);      &amp;#125;    &amp;#125;  &amp;#125;);

Object Attributes;
Object.getPrototypeOf() ECMAScript 5引入, 可用于获取某个对象的prototype;
p.isPrototypeOf() 同上, 用于判断某个对象是否为另一个对象的prototype;
Object.isExtensible(),Object.preventExtensions()则分别是用于判断一个object是否是可扩展的, 以及禁止其可扩展性的(此操作不可复原);
Object.seal()类似Object.preventExtensions(), 不过它同时禁掉了properties的configurable属性,Object.isSealed()则是对应用于判断是否sealed的函数;
Object.freeze()比Object.seal()还要严格,所有属性都变为可读了, 对应的查询函数为:Object.isFrozen();
Object.preventExtensions(),Object.seal(),Object.freeze()都是只针对当前object而言的;
class属性目前基本没啥用, 有点等价或者说更细化的typeOf or instanceOf了;



Chapter 7 - Arrays这里主要记录ECMAScript 5引入的一些新的方法, 3已有的可以查看 阅读笔记-2

forEach(value,index,array_itself): array自身的循环调用函数, 相当于for(i in array_name){}, 区别在于其不支持break等可以跳出循环的语句, 如果你想要提前结束循环, 就需要通过try/catch包裹并利用抛出异常来结束循环;
map(): 也算是循环的一种, 遍历每个元素并传递给传入的函数, 最终返回一个新数组;
filter(): 顾名思义, 这是对数组进行筛选的, 值得一提的是filter()会自动跳过空白,所以对于稀疏数组通过filter()可以去除所有空白, 在加上undefined判断, 就可以去除所有空值了;
every() 和 some(): every()是当数组每个元素都使传入函数为真的时候返回真, some()则是只要一个为真即返回为真, 需要注意的事, 对于空数组, every()会返回真, 而some()会返回为假;
reduce(function,initial_value) 和 reduceRight(): 通过执行传入函数而对数组元素进行整合,计算,判断, 最终返回一个结果: var max = a.reduce(function(x,y) { return (x&amp;gt;y)?x:y; });即返回数组的最大值; reduceRight()与reduce()一致, 只是循环顺序相反, 从右到左; 当没有声明初始值时, 采用第一个执行元素作为初始值;
indexOf() 和 lastIndexOf: 顾名思义, 获取数组中某个元素的index, 前者获取首个匹配元素的index, 后者获取最后一个匹配元素的index;

Chapter 8 - Functions
Functions的调用有四种:
直接调用;
作为对象的方法调用;
作为constructor调用;
通过call,apply方法调用(间接调用);


call() 和 apply:
call和apply都是间接调用的方法, 允许一个函数临时客串为某个object的方法;
一定程度上, 可以等价于o.m = f;o.m();delete o.m;
其接受的第一个参数会成为函数运行的this域, 如果是非strict mode下, 传入null/undefined则会自动将global作为this, 而如果传入的是primitive datatype, 则自动转为对应的wrapper object, 即string =&amp;gt; String;
call和apply的区别主要体现在后面的参数上, 前者以分散元素传入, 后者则以整体数组形式传入, 所以用apply可以把原本只支持不定长参数的函数转换为接受数组的函数:var biggest = Math.max.apply(Math, array_of_numbers);;
apply对类array元素处理方式同array元素;


bind(): 很是类似call和apply, 本质也是把某个函数作为某个对象的方法调用, 实现则是通过把object和function绑定, 形成一个新函数从而每次调用新函数都等价于调用了object.funtion, bind接受多个参数, 其首个以后的参数都会作为this域成员代入函数中, 并按序成为函数自身的参数function f(y,z) { return this.x + y + z };var g = f.bind({x:1}, 2);g(3) // 2被赋予了y, 新的3则给了z;
higher-order function: 作用于另一个函数之上的函数;

partial and memoization 这两个都是function programing中常用的方法:

partial: 类似bind()这种会把传入参数默认分配到函数自身的部分接受参数上的做法就是partial application;
memoization: 将函数运行过程的计算结果缓存起来的方式;



123456789101112131415161718192021222324function array(a, n) &amp;#123; return Array.prototype.slice.call(a, n || 0); &amp;#125;// 用以处理类array元素(转为真正的array)function partial(f /*, ... */) &amp;#123;  var args = arguments;  // 存储partial的参数  return function() &amp;#123;    var a = array(args, 1);    // 取出首位以后的参数    var i=0, j=0;    for(; i &amp;lt; a.length; i++)      if (a[i] === undefined) a[i] = arguments[j++];      // 这里的arguments是第二层参数      // 将空元素逐个替换成第二层参数里的值, j自动随着执行+1    a = a.concat(array(arguments, j))    // 组成新的参数数组    return f.apply(this, a);    // 调用f函数, 并传入参数a  &amp;#125;;&amp;#125;var f = function(x,y,z)&amp;#123;return x*y*z&amp;#125;partial(f,undefined,2)(1,3)// x:1,y:2,z:3
123456789101112131415// Return a memoized version of f.// It only works if arguments to f all have distinct string representations.function memoize(f) &amp;#123;  var cache = &amp;#123;&amp;#125;;  return function() &amp;#123;    var key = arguments.length + Array.prototype.join.call(arguments,&quot;,&quot;);    if (key in cache) return cache[key];    else return cache[key] = f.apply(this, arguments);  &amp;#125;;&amp;#125;// 应用方式类似;var factorial = memoize(function(n) &amp;#123;return (n &amp;lt;= 1) ? 1 : n * factorial(n-1); &amp;#125;);factorial(5) // 此时会自动缓存4,3,2的阶乘值. 对于一些复杂的运算, 如此可以很好的加快运算速度.
Chapter 9 - Classes and Modules除了 阅读笔记-2中包含的, 由于ECMAScript 5所引入的那些object property自然都可以应用到新的class中, 从而创建更为复杂有效的函数. 其实js中目前不存在class这个关键词, 所以其模仿的class, 说白了就是一个复杂一些的函数对象.
而因为其内容驳杂繁多, 我么会在后面的应用中有很多实践的机会, 这里就不一一描述了.
参考资料
JavaScript the Definitive Guide 6th edition
Functional Javascript

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript Coding Style</title><link>http://taoalpha.me/blog/2016/01/09/read-javascript-coding-style/</link><category>read</category><tag>JS,coding style</tag><pubDate>2016-01-10T01:49:12.000Z</pubDate><description>Why and What is Coding StyleCoding style is like the common styles and patterns that are used in your personal codebase or some organizations’ codebase, its purpose is making your code more readable and reusable through the entire developemnt, especially when you work in a team. Everyone can create their own coding style, there is no right or wrong among them, like you prefer 4 spaces than 2 spaces, you like to use camelCase represent the functions and variables,that’s totally fine. 
The benefit of using the same style is obvious, it can save you a lot of time reading and modifying others’ code or even your own code. There are some styles that are pretty popular and agreed by a lot of people and team, like Google Style Guide. Being modified and updated for so many years, I believe these styles would be a better choice to choose rather than create one by yourself.
Javascript Style GuideThere are several popular style guide for javascript, one is the part of the Google Style Guide series:  Google JavaScript Style Guide, another is created by airbnb:Airbnb JavaScript Style Guide, and also there is a Code Conventions for the JavaScript Programming Language created by the author of JavaScript: The Good Parts.
I read them all and summarize the core parts here.
Google JavaScript Style GuideHere I ignore all parts related to the Google Closure Compiler, if you are interested in, take a look at Closure Compiler.
Syntax &amp;amp; Basic Concept
var: never declare a variable without var to save you from global variables;
semicolons: always use semicolons, sometimes the closing brackets are not enough to signal the end of the statement: Javascript never ends a statement if the next token is an infix or bracket operator;
new: Never use wrapper objects for primitive types(like new Boolean(false), return an object!), but can use Boolean(0) to do casting, also for array and object, use literal syntax instead of new; 
prototye: Use prototype to attach methods to an object created via new, initialize other properties within constructor,Current JavaScript engines optimize based on the “shape” of an object, adding a property to an object (including overriding a value set on the prototype) changes the shape and can degrade performance., and NEVER modify prototype of builtins like Object and Array;
delete: Use set to null instead of delete to delete some properties, but if the number of properties of the object matters, use delete;
closure: Be careful to use closure since it might cause memory leak;
eval,with(){}: Just don’t use them;
for-in-loop: Only use it to iterate the key of object/hashmap;
quote: Use single quote &amp;#39;&amp;#39; for strings, use string concatenation if the string is too long;

Naming
CONSTANT_NAME: always use ALL_CAP_SNAKE_CASE represent the constant;
functionName,variableName,methodName: use camelCase represent the functions and variables, methods;
ClassName,EnumNamesLikeThis: use CamelCase represent class or enums;
filenameslikethis.js: use plain lowercase as the name of the files;
_private: private should be named with a trailing underscore;
opt_: Optional function arguments start with opt_;
global: try not to contaminate the global, can use a global object to store all variables you want to use as gloabl scope - prevent some conflicts between global and local;

Comments &amp;amp; JSDocJust remmeber that comments is written for someone who isn’t familiar with the code including youself after a long time!
Here is some resouces about the JSDoc
TipsSome Boolean Expressions1234567891011121314151617Boolean('0') == true'0' != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&amp;#123;&amp;#125;) == true&amp;#123;&amp;#125; != true&amp;#123;&amp;#125; != false
Better For Loop1234var paragraphs = document.getElementsByTagName('p');for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) &amp;#123;  doSomething(paragraph);&amp;#125;
BE CONSISTENTAirbnb JavaScript Style GuideI will address some difference between this one and google’s.
Syntax &amp;amp; Basic Concept
const: Alwasy use const on references instead of var, ensure that you can not reassign your reference, Block-scoped;
let: If you must reassign references, use let instead of var, Block-scoped;
reserved words: don’t use reserved words as keys;
object shorthand: use object shorthand for method and value defined in an Object, and also put all shorthands at the beginning of the object declaration;

123456789101112131415161718// methodconst atom = &amp;#123;  value: 1,  addValue(value) &amp;#123;    return atom.value + value;  &amp;#125;,&amp;#125;;// value, if value and key are the same// put all shorthands at the beginning// only quote properties that are invalid identifiersconst obj = &amp;#123;  lukeSkywalker,  foo: 3,  bar: 4,  'data-blah': 5,&amp;#125;;

spreads: Use ... to copy arrays: const itemsCopy = [...items]; 
Array.from(): Use Array.from() convert an array-like object to an array;
destructuring: Use object and array destructuring when accessing and using multiple properties of an object;

123456789101112131415161718192021222324// goodfunction getFullName(user) &amp;#123;  const &amp;#123; firstName, lastName &amp;#125; = user;  return `$&amp;#123;firstName&amp;#125; $&amp;#123;lastName&amp;#125;`;&amp;#125;// bestfunction getFullName(&amp;#123; firstName, lastName &amp;#125;) &amp;#123;  return `$&amp;#123;firstName&amp;#125; $&amp;#123;lastName&amp;#125;`;&amp;#125;// array destructuringconst arr = [1, 2, 3, 4];const [first, second] = arr;// Prefer object destructuring for multiple return values to array destructuring// goodfunction processInput(input) &amp;#123;  // then a miracle occurs  return &amp;#123; left, right, top, bottom &amp;#125;;&amp;#125;// the caller selects only the data they needconst &amp;#123; left, right &amp;#125; = processInput(input);

template strings: When programmatically building up strings, use template strings instead of concatenation;
functions declarations: Use function declarations instead of function expressions, when you must use function expressions (as when passing an anonymous function), use arrow function notation;

1234567891011121314151617181920212223242526272829// badconst foo = function () &amp;#123;&amp;#125;;// goodfunction foo() &amp;#123;&amp;#125;// use arrow functions as function expressions// immediately-invoked function expression (IIFE)(() =&amp;gt; &amp;#123;  console.log('Welcome to the Internet. Please follow me.');&amp;#125;)();// No function declarations should be in a block// badif (currentUser) &amp;#123;  function test() &amp;#123;    console.log('Nope.');  &amp;#125;&amp;#125;// goodlet test;if (currentUser) &amp;#123;  test = () =&amp;gt; &amp;#123;    console.log('Yup.');  &amp;#125;;&amp;#125;

arguments: Don’t use it, use ...args instead;

12345678910function concatenateAll(...args) &amp;#123;  return args.join('');&amp;#125;```  - `default value`: Use default parameter syntax rather than mutating function arguments, and always put default parameters last;``` javascriptfunction handleThings(name, opts = &amp;#123;&amp;#125;) &amp;#123;  // ...&amp;#125;

spacing: put space between function name and the brackets and curly brackets;
parameter: Never mutate parameters, Never reassign parameters;

123456789// badfunction f1(obj) &amp;#123;  obj.key = 1;&amp;#125;;// goodfunction f2(obj) &amp;#123;  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;&amp;#125;;

arrow functions: 
If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement;
and if the expression spans over multiple lines, wrap it in parentheses;
If your function takes a single argument and doesn’t use braces, omit the parentheses;



12345678910111213141516171819// good[1, 2, 3].map(number =&amp;gt; `A string containing the $&amp;#123;number&amp;#125;.`);// bad[1, 2, 3].map(number =&amp;gt; &amp;#123;  const nextNumber = number + 1;  `A string containing the $&amp;#123;nextNumber&amp;#125;.`;&amp;#125;);// good[1, 2, 3].map( (number) =&amp;gt; &amp;#123;  const nextNumber = number + 1;  return `A string containing the $&amp;#123;nextNumber&amp;#125;.`;&amp;#125;);[1, 2, 3].map(number =&amp;gt; (  `As time went by, the string containing the $&amp;#123;number&amp;#125; became much ` +  'longer. So we needed to break it over multiple lines.'));

class: Always use class. Avoid manipulating prototype directly;
extends: Use extends for inheritance;
methods: Methods can return this to help with method chaining;

123456// goodclass PeekableQueue extends Queue &amp;#123;  peek() &amp;#123;    return this._queue[0];  &amp;#125;&amp;#125;

import: Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system, which means don’t use require etc;
Do not use wildcard imports;
And do not export directly from an import;



1234567891011121314// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide';// bad// filename es6.jsexport &amp;#123; es6 as default &amp;#125; from './airbnbStyleGuide';// good// filename es6.jsimport &amp;#123; es6 &amp;#125; from './AirbnbStyleGuide';export default es6;

iterators and generators:
Don’t use iterators. Prefer JavaScript’s higher-order functions like map() and reduce() instead of loops like for-of;
Don’t use generators for now.



123456789101112131415161718const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &amp;#123;  sum += num;&amp;#125;sum === 15;// goodlet sum = 0;numbers.forEach((num) =&amp;gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&amp;gt; total + num, 0);sum === 15;

properties:

Use dot notation when accessing properties;
Use subscript notation [] when accessing properties with a variable;


variables:

Always use const to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that;
Use one const declaration per variable;
Group all your consts and then group all your lets;
Assign variables where you need them, but place them in a reasonable place;


hoisting:

var declarations get hoisted to the top of their scope, their assignment does not; 
const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ);
It’s important to know why typeof is no longer safe;
Anonymous function expressions hoist their variable name, but not the function assignment;
Named function expressions hoist the variable name, not the function name or the function body;
Function declarations hoist their name and the function body;



1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// using const and letfunction example() &amp;#123;  console.log(declaredButNotAssigned); // =&amp;gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned); // =&amp;gt; throws a ReferenceError  const declaredButNotAssigned = true;&amp;#125;// assignment will not be hoistedfunction example() &amp;#123;  console.log(anonymous); // =&amp;gt; undefined  anonymous(); // =&amp;gt; TypeError anonymous is not a function  var anonymous = function () &amp;#123;    console.log('anonymous function expression');  &amp;#125;;&amp;#125;function example() &amp;#123;  console.log(named); // =&amp;gt; undefined  named(); // =&amp;gt; TypeError named is not a function  superPower(); // =&amp;gt; ReferenceError superPower is not defined  var named = function superPower() &amp;#123;    console.log('Flying');  &amp;#125;;&amp;#125;// the same is true when the function name// is the same as the variable name.function example() &amp;#123;  console.log(named); // =&amp;gt; undefined  named(); // =&amp;gt; TypeError named is not a function  var named = function named() &amp;#123;    console.log('named');  &amp;#125;&amp;#125;// BUT! Function declarations hoist their name and the function body.function example() &amp;#123;  superPower(); // =&amp;gt; Flying  function superPower() &amp;#123;    console.log('Flying');  &amp;#125;&amp;#125;

Comparison Operators &amp;amp; Equality:
Use === and !== over == and !=;
Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules:
Objects evaluate to true
Undefined evaluates to false
Null evaluates to false
Booleans evaluate to the value of the boolean
Numbers evaluate to false if +0, -0, or NaN, otherwise true
Strings evaluate to false if an empty string ‘’, otherwise true





Comments
Use /** ... */ for multi-line comments. Include a description, specify types and values for all parameters and return values;
Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block;
Prefixing your comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that needs to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME – need to figure this out or TODO – need to implement;

12345678910111213/** * make() returns a new element * based on the passed in tag name * * @param &amp;#123;String&amp;#125; tag * @return &amp;#123;Element&amp;#125; element */function make(tag) &amp;#123;  // ...stuff...  return element;&amp;#125;
Spaces
Use soft tabs set to 2 spaces;
Place 1 space before the leading brace;
Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations;
Set off operators with spaces;
End files with a single newline character;
Use indentation when making long method chains. Use a leading dot, which emphasizes that the line is a method call, not a new statement;
Leave a blank line after blocks and before the next statement;
Do not pad your blocks with blank lines;
Do not add spaces inside parentheses;
Do not add spaces inside brackets;
Add spaces inside curly braces;
Avoid having lines of code that are longer than 100 characters (including whitespace);

Commas and Semicolons
Leading commas: NOPE;
Additional trailing comma: Yup;
Always use semicolons;

12345// good (guards against the function becoming an argument when two files with IIFEs are concatenated);(() =&amp;gt; &amp;#123;  const name = 'Skywalker';  return name;&amp;#125;)();
Type Casting &amp;amp; Coercion
Perform type coercion at the beginning of the statement, use String,Number etc instead of other tricky methods;
If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing;
Be careful when using bitshift operations. Numbers are represented as 64-bit values, but Bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits;

12345678910// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &amp;gt;&amp;gt; 0;// be careful2147483649 &amp;gt;&amp;gt; 0 //=&amp;gt; -2147483647
Naming
Avoid single letter names. Be descriptive with your naming;
Use camelCase when naming objects, functions, and instances;
Use PascalCase when naming constructors or classes;
Use a leading underscore _ when naming private properties;
Don’t save references to this. Use arrow functions or Function#bind;
If your file exports a single class, your filename should be exactly the name of the class;
Use camelCase when you export-default a function. Your filename should be identical to your function’s name;
Use PascalCase when you export a singleton / function library / bare object;

1234567891011121314// badfunction foo() &amp;#123;  const that = this;  return function () &amp;#123;    console.log(that);  &amp;#125;;&amp;#125;// goodfunction foo() &amp;#123;  return () =&amp;gt; &amp;#123;    console.log(this);  &amp;#125;;&amp;#125;
Accessors
Accessor functions for properties are not required;
If you do make accessor functions use getVal() and setVal(‘hello’);
If the property is a boolean, use isVal() or hasVal();
It’s okay to create get() and set() functions, but be consistent;

jQuery
Prefix jQuery object variables with a $;
Cache jQuery lookups;
For DOM queries use Cascading $(&amp;#39;.sidebar ul&amp;#39;) or parent &amp;gt; child $(&amp;#39;.sidebar &amp;gt; ul&amp;#39;);
Use find with scoped jQuery object queries;

1234567891011// goodfunction setSidebar() &amp;#123;  const $sidebar = $('.sidebar');  $sidebar.hide();  // ...stuff...  $sidebar.css(&amp;#123;    'background-color': 'pink'  &amp;#125;);&amp;#125;
TestingYou should write testing!!!
Code Conventions for the JavaScript Programming LanguageAll coved by two styles I list above.
SummaryCompared to google’s old style guide, airbnb’s style guide has much more valuable new ES6 styles, if you are an active ES6 users, I strongly suggest you use airbnb’s style !!!
Even you are a solo worker, you should use some common styles, it is a good habit and you should have.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Using @font-face</title><link>http://taoalpha.me/blog/2014/07/15/read-yi-using-font-face/</link><category>read</category><tag>CSS,font-face,翻译文章,译系列</tag><pubDate>2014-07-15T10:00:00.000Z</pubDate><description>如下例:
123456789@font-face &amp;#123;  font-family: 'MyWebFont';  src: url('webfont.eot'); /* IE9 Compat Modes */  src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */       url('webfont.woff') format('woff'), /* Modern Browsers */       url('webfont.ttf')  format('truetype'), /* Safari, Android, iOS */       url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&amp;#125;
由于如今WOFF是如此之火, 你也可以简化使用:
123456@font-face &amp;#123;  font-family: 'MyWebFont';  src: url('myfont.woff') format('woff'), /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */       url('myfont.ttf') format('truetype'); /* Chrome 4+, Firefox 3.5, Opera 10+, Safari 3—5 */&amp;#125;
其实只用WOFF也可以的, 目前基本主流浏览器都能支持了.
然后你就可以在其他元素中使用这一属性了~ 比如:
1234body &amp;#123;  font-family: 'MyWebFont', Fallback, sans-serif;&amp;#125;
讲讲font-face的历史吧, @font-face是用于加载以及使用你自定义的字体而出现的, 针对的就是如今浏览器有权限使用的系统已有的有限字体. 这里有个系统预装字体的详情介绍.
说到性能. 一般我们认为字体文件都是非常巨大的, 同时还会让你的网站增加很多额外的请求, 这些都会拖慢你的站点速度. 所以在使用之前请务必确保你考虑清楚.
如果你确实要使用自定义字体, 有一种更好的更负责的方式是尽可能的加载足够少的字母和样式种类. 比如, 如果你使用google fonts, 只需要引入一些特定的组合即可:
123@import url(http://fonts.googleapis.com/css?family=Averia+Sans+Libre:400,300italic,700);
甚至可以缩减引入的字符数量.
相比于性能, @font-face似乎经常出现各式各样的bug…比如这种, 这种,还有这种…
关于字体格式, 倒是有几种, 每种都还有些历史.
  WOFF    Web Open Font Format. 是专为网络使用而创造的, 由Mozilla和一些其他组织共同发展起来的, WOFF字体通常比其他格式字体加载的更快, 主要是因为他们使用了比OTF和TTF更加压缩的结构, 这种结构中还能包含一些meta信息和license信息, 目前来说WOFF应该是最大的赢家了, 主流的浏览器基本都已经能够支持了.    SVG/SVGZ    Scalable Vector Graphic(Font). SVG是一种字体的矢量化过程, 主要可以让体积变的更小, 同时也能够用于移动设备. 这个字体格式是4.1版本以下的Safari浏览器唯一支持的字体格式了. 目前来说SVG依然不能被Firefox, IE以及IE 移动版支持. Firefox主要精力都在支持WOFF了~ 天知道他们什么时候支持SVG… SVGZ是SVG的再压缩版本.    EOT    Embedded Open Type. 这一格式是由微软从15年前创造的(真正意义上@font-face的源头). 也是唯一一种IE8以及以下版本支持在@font-face中使用的格式了.    OTF/TTF    OpenType Font 和 TrueType Font. 在一定程度上WOFF格式的出现也是因为这些格式可以很容易被复制, 无论合法与否. 同时, OpenType的某些特性(比如手写字体等)比较吸引设计师们.  


字体服务有很多, 主要就是提供那些你可能无权使用的字体, 从而让你的使用合法化. 主要有以下这些:
  Cloud Typography  Typekit  Fontdeck  Webtype  Typotheque  Fontspring  WebINK  Fonts.com  Google Fonts  Font Squirrel



想要对比下这些服务的好坏?
Source Link:  CSS Tricks
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>How Users Read on the Web(译)</title><link>http://taoalpha.me/blog/2013/06/04/read-how-users-read-on-the-web-translation/</link><category>read</category><tag>HCIBib,产品学习,网页浏览,翻译文章</tag><pubDate>2013-06-04T10:00:00.000Z</pubDate><description>本文主要是针对网页上的文字排版对于用户阅读的影响,列举了三种不同的处理方式以及混合情况下对网页可用性的提升效果.他们从不阅读。
人们极少逐字逐句地阅读网页上的内容，他们只是扫视页面，选取某些字词语句来阅读。 在关于人们如何阅读网站的研究中，我们发现大概79%的测试用户对于任何他们进入的页面都是采用扫视的方式阅读，只有16%的用户 是逐字阅读的。(更新：一个新的研究发现用户在阅读email时比阅读网站更加散漫。)
所以，网页需要提供可以扫视的文本信息，利用：
    高亮关键字(超文本链接是高亮的一种形式，字体和颜色变化也是高亮的形式)    有意义的子标题(不算作很明智的选择)    符号列表    一个段落一个主题(如果用户没有段落中前几个词所吸引的话,那么他们会跳过剩下的所有)    倒金字塔风格,先说结论    相比传统的写作而言,字数至少要减少一半我们发现可信性对于网页用户而言是非常重要的,因为对于网页信息背后的作者以及网页是否可以信任是不清楚的.可信性可以通过高质量的图片/优秀的写作以及向外的超文本连接来提高.外链表现出作者已经做完了该做的,并不担心用户访问别的站点.
用户厌恶”商业感”,通过主观的自我夸赞和宣言(有史以来最经典的)来提升写作风格在当下的网页中已经不再使用了.网页用户非常忙碌的,他们想要得到最直接的结果.还有,如果用户清晰的看到网站在夸大,可信性会一落千丈的.
衡量提高网页写作风格带来的影响
为衡量一些我们已经确认的内容指南所带来的影响,我们制作了想通网站的五个不同的版本(形同的基础信息;不同的措辞;相同的站点导航).接着我们让用户在不同的网站下完成相同的任务.正如下表中所示,易用性在简介版本以及浏览性版本的网站中得到了很明显的提升(58%以及47%的提高).而且当我们将三种 方式整合到一起来提升写作风格,形成一个单一的站点,结果会更加炫目:124%的易用性提升.




网页版本

示例段落

可用性提升

促销对照组 使用的就是常规商业网站使用的风格
Nebraska is filled with internationally recognized attractions that draw large crowds of people every year, without fail. In 1996, some of the most popular places were Fort Robinson State Park (355,000 visitors), Scotts Bluff National Monument (132,166), Arbor Lodge State Historical Park &amp;amp; Museum (100,000), Carhenge (86,598), Stuhr Museum of the Prairie Pioneer (60,002), and Buffalo Bill Ranch State Historical Park (28,446).
0% (by definition)

简洁版本只有对照组的一半字数
In 1996, six of the best-attended attractions in Nebraska were Fort Robinson State Park, Scotts Bluff National Monument, Arbor Lodge State Historical Park &amp;amp; Museum, Carhenge, Stuhr Museum of the Prairie Pioneer, and Buffalo Bill Ranch State Historical Park.
58%

扫描式布局 和对照组文本一致,但采用易于扫视的格式
Nebraska is filled with internationally recognized attractions that draw large crowds of people every year, without fail. In 1996, some of the most popular places were:

Fort Robinson State Park (355,000 visitors)
Scotts Bluff National Monument (132,166)
Arbor Lodge State Historical Park &amp;amp; Museum (100,000)
Carhenge (86,598)
Stuhr Museum of the Prairie Pioneer (60,002)
Buffalo Bill Ranch State Historical Park (28,446).47%客观的语言 利用中立而不是主观自负或者言过其实的语言(其他都和对照组一致)Nebraska has several attractions. In 1996, some of the most-visited places were Fort Robinson State Park (355,000 visitors), Scotts Bluff National Monument (132,166), Arbor Lodge State Historical Park &amp;amp; Museum (100,000), Carhenge (86,598), Stuhr Museum of the Prairie Pioneer (60,002), and Buffalo Bill Ranch State Historical Park (28,446).27%整合版本以上三种写错风格修改的集合.In 1996, six of the most-visited places in Nebraska were:
Fort Robinson State Park
Scotts Bluff National Monument
Arbor Lodge State Historical Park &amp;amp; Museum
Carhenge
Stuhr Museum of the Prairie Pioneer
Buffalo Bill Ranch State Historical Park124%在客观语言版本中可用性获得了27%的提升着实让我们吃惊了.我们期待用户可以喜欢这个版本胜过对照组(实际上也确实是这样的),但是我们认为评价标准对于任意一种语言而言都是一样的.正如预计的那样,我们的四种评价标准(时间错误内存网站结构)都获得了客观风格比原始的促销版本更好一些的结论.我们用以解释这一发现的猜想是促销性语言为用户强加了认知的负担,必须让用户花费精力去过滤夸张的表象从而获得事实. 当人你们在阅读一个以”Nebraska是一个充满了国际公认景点的地方”开头的地方,他们的第一反应是”不,不是的”,并且这一想法将会降低他们使用网站的速度,分散他们的注意力.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Introduction To Usability(译)</title><link>http://taoalpha.me/blog/2013/06/13/read-introduction-to-usability-translated/</link><category>read</category><tag>UX,Usability,产品学习,翻译文章</tag><pubDate>2013-06-13T09:00:00.000Z</pubDate><description>Introduction To UsabilitySummary 如何定义可用性?如何,什么时间,什么地方来提升?为什么你要关注可用性?这是一个关于核心的可用性概念的介绍以及回答一些基本的问题.
What–Definition Of Usability
可用性是一个表征质量的属性,用以描述用户界面在使用性上的难易程度.”Usability”这个词本身也有用以提升设计过程中易用性的方法的含义.
可用性主要通过以下5个部分的特点组成:
    易学性:对于用户而言,第一次使用时完成基础任务的难易程度?    高效性:一旦用户学会了之后,他们完成任务的效率有多高?    记忆性:当用户在一段时间的不用后再次返回时,他们重新熟练的容易性如何?    错误率:用户会犯多少错误,这些错误的严重程度如何,以及他们从这些错误中脱身的难易程度?    满意度:用户使用这一设计的满意度如何?此外还有很多重要的品质属性.其中比较关键的一个就是实用性,表征的是设计的功能性:它所做的都是用户所需的吗?
可用性和实用性都是同等重要的,而且它们一起决定了设计是否有用:如果某物很容易但却不是你想要的也是没啥意义的. 虽然对于幻想那种可以做任何你想做的事情的系统也不见得是好的,但是如果你的交互界面很难用的话,你是不可能做到这一点的.为了研究一个设计的实用性,你可以用提升易用性同样的研究方法.
    Definition: Utility—它是否提供了你所需要的功能;    Definition: Usability–这些功能用起来的难度和满意度如何.    Definition: Useful = Usability + UtilityWhy Usability is Important(为什么可用性这么重要)
在网络上,可用性是一个必须要考虑的生存条件.如果一个网站非常难用,人们就会离开.如果一个公司的主页不能描述清楚公司提供的产品或者服务,用户可以做什么等,人们也会离开.如果用户在一个网站迷路了,他们就会离开.如果一个网站的信息很难阅读或者无法回答用户的关键问题,他们也会离开. 注意到一个模式了吗?根本不存在这样的情况:用户费劲的阅读说明书或者花费很多时间去理解一个界面.外面还有无数的网站等待用户去选择,离开是用户在感到难用时的第一选择.
电子商务的第一条定律就是如果用户无法找到产品,他们就无法购买这个产品.
对于企业内部网络,可用性就是一个关乎员工生产力的事情了.用户如果花费太多的时间在内部网络或者纠结于思考那些困难的指令,那么也就等同于在浪费着你付给他们工作的薪水了.
目前最佳的财政预算是将设计项目预算的10%留给可用性上.平均来讲,这些大概是一个网站期望的质量标准的2倍左右,而且大概是一个内部网络质量标准花费的两倍略低一些.对于软件或者实际的物理商品,强调设计过程的易用性,所致的提升效果会相对较小,但是依然很显著.
对于内部的设计项目,应该考虑将培训预算砍掉一半,而将易用性方面的预算加倍,以及加倍做事的员工的时薪.对于外部的设计,则应该考虑加倍销售的预算以及注册用户和用户引导的预算,同时加倍那些对你的设计项目有提升动机的预期计划.
How to Improve Usability(如何提升易用性)
在研究易用性上有很多方法,但是最主要最基础最有用的就是用户测试了,它包含了以下三个部分:
    找到一些典型的用户,比如电子商务网站的消费者或者内部网络的员工(在后者的情况下,他们应该是在你们部门之外工作的);    让用户实施一些有代表性的任务;    观察用户做了什么,那些地方成功了,哪些地方他们遇到了问题,而且闭上你的嘴,而让用户讲出他们想说的;逐一分别的测试用户,让他们独立解决任何问题是很重要的,.如果你帮助他们或者把他们的注意力指引向屏幕的任何部分,你都让实验结果受到了污染;
为确定一个设计最重要的易用性问题,测试5个用户就基本足够.预期去运行一个大型的,昂贵的项目研究,还不如使用这些资源进行一个小规模的测试,并且逐一重新审视你的设计,这样你才能在确定问题后修正你的易用性瑕疵.迭代设计是一个而方法来提升你的体验质量.你和用户测试的版本和界面设计越多,效果越好.
用户测试和焦点小组是不同的,焦点小组是一种相对较差的方式来评估设计的易用性.焦点小组常用于市场调研,但是为了评价交互设计,你必须足够近的观察一个用户利用你的设计界面去完成一个任务.通过聆听用户所说的会有误导:你必须去亲自观察他们真正做的是什么.
When to Work on Usability(什么时候注意易用性)
易用性在设计过程的每一步中都占据一定的地位.对于多个研究的需要也是我推荐把个人独立的研究尽快而又便宜的完成的原因之一:
    在开始一个新的设计之前,测试旧有的设计来确定其中好的部分,这样你就可以保留这些部分并加以强化,同时知道哪些对用户造成困扰的部分.    除非你在一个内部网络中工作,测试你竞争者的设计可以廉价的获取到一组相对较好的设计界面,而且这些都和你的设计有着很多共同的特性.(如果你工作于一个内部网络,那么可以通过阅读内部的设计年刊来学习其他的设计).    针对用户在他们的日常生活中是如何表现的做一个实地的考察;    对一个或者更多的新设计注意制作纸质原型并加以测试.你投资在这些设计的时间越少,效果越好,因为你需要根据测试结果来修改他们(就是不用花费太多的时间去做特别精致的原型)    通过多次迭代后,对最优秀的那个设计不断修改来完善它,逐渐的从低质量的原型到高质量的电子原型展示.每一次迭代都需要测试.    观察那些和建立可用性规则先关的设计,无论是你早期的研究还是公开的研究.    一旦你决定了并且开始着手最终的设计,再次测试一次.一些微小的可用性问题经常在实施的时候出现.不要抵制用户测试,除非你已经有了一个完成的设计了.如果你已经有了一个成品,那么再去修复绝大多数测试没有覆盖到的关键问题就会变得不可能了.像这一类的问题大多是比较偏向结构方面的,而修复他们将会需要对主要部分的重构.
想要获得一个高质量的用户体验唯一的方法就是在设计的早期就开始用户测试,并一直持续的在接下来的每一步实施它.
Where to Test(在哪里测试)
如果你每周至少实施一次用户测试,那么专门建立一个可用性实验室就有必要的了.但对绝大多数公司,在一个会议室或者办公室里进行一次测试就已经不错了,只要你关上门隔开干扰就可以了.重点在于你要有真实的用户,并且可以在他们测试的过程中陪坐一旁.你唯一需要的设备就是一个笔记本.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Knowledge vs Intelligence</title><link>http://taoalpha.me/blog/2014/11/21/read-knowledge-vs-intelligence/</link><category>read</category><tag>翻译文章,译系列</tag><pubDate>2014-11-21T10:00:00.000Z</pubDate><description>大约一周前, 我在开发我一个小产品的时候遇到了一个很严重的问题. 我花了好几个晚上的时间去解决这个问题, 但是依然没有什么进展, 这让我很沮丧.

之后的一个晚上, 我正在和 Olivier Lacan视讯, 我们讨论了这个问题. 因为他是我的一个非常好的朋友, 所以他建议我把我的桌面分享给他来让他看看. 我正在研究 Laravel一个全新的PHP的框架, 也是Olivier从来没用过的一个框架(当然其实他连PHP都不用的). 但是他很聪明而且是一个很伟大的开发者, 所以我很愉快的接受了他的要求.

我们开始梳理整个代码库, 我带着他过了一遍整个应用和框架,  他则见或提出一些内部系统的尖锐问题. 因为Olivier并不是非常熟悉Laravel, 所以他问的问题就和我不同, 而这些问题则指向了一个有趣的部分, 而这个部分正是我一个人想的时候没有注意到的. 而在一个小时的debug后, 我们找到问题的根源并且解决了它.

我之前曾谈论过有关 “编码交换”的话题, 就是把自己的电脑与他人交换, 然后尝试解决对方的问题–但是这次则是另一个问题. 这是一个类似 传统的 “橡皮鸭”的问题, 不同的是有一个可信任的聪明的朋友.

这里的关键在于知识和智慧之间的区别. 知识是关于技能, 以及经历和从中获取的信息的集合. 智慧则是应用知识的能力.  一个人缺乏某个领域的知识不代表他们不能应用自己的智慧来帮助解决对应的问题.

知识是很好的, 但是它总会随着技术和科技的 兴起没落而渐渐消失掉. 但是智慧则不会. 它跨越了技术和科技之间的壁垒, 这就是最大的区别了.

Source:

Knowledge vs Intelligence
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>The Who, What, When, Wear, and Why of Wearable Technology</title><link>http://taoalpha.me/blog/2014/10/29/read-t-the-who-what-when-wear-and-why-of-wearable-technology/</link><category>read</category><tag>Wearable,关于HCI,穿戴式设备,翻译文章,译系列</tag><pubDate>2014-10-29T04:00:00.000Z</pubDate><description>穿戴式技术的5个W

什么是移动性？移动性就应该是让内容服务对用户做到随时随地的访问， 尽可能的便捷高效。 就好比移动设备让人们再也不用坐到一台电脑前才能获取信息那样，穿戴式设备让人们甚至不用再拿着设备来获取信息了。 就好比我们把思维模式转移到iPhone的小屏幕并且学习着这全新的使用情景一样， 我们需要再次调整我们的思维方式去适应穿戴式设备–更小的屏幕，以及更加收缩的交互界面。 苹果最近推出了Apple Watch， 这也是穿戴式设备正式登场的一大证明–所有重量级玩家都已经落座， 游戏要正式开始了。

深度挖掘

首先， 了解『穿戴式』这一术语的含义非常重要，因为这一术语有一些误导性， 因为它囊括了数以百计的，有着不同目的和用途的设备于一体：智能手表，智能眼镜，智能衣服，智能袜子，智能腕带等等。 最基本的， 『穿戴式』是指所有那些用户能够穿戴起来的设备，当然这些设备还需要能够实现有价值的计算功能的能力。 但是为了能够理解他们的能力， 我们需要区分这些不同的设备以及他们的应用模式。 以下是当下最主流也是最具区分性的穿戴式设备的特点。

活动记录

通常来说， 形如腕带的这种设备都是围绕在收集我们身体数据（诸如心率， 脉搏， 运动模式， 每日行走距离等）这一服务核心来服务的。获得数据后， 他们就可以把数据传输到云端， 进行分析从而获得一些关于如何提升用户身体健康的结论。 而通过穿上这么一个并不怎么碍眼的设备， 收集我们自己的身体数据， 我们就可以更好的了解我们自己的身体， 从而更好的生活。虽然活动记录这一功能已经很受欢迎， 但是他们依然还有着很多巨大的商业价值和利用空间。 比如， 加拿大奥运代表队就利用智能服装来跟踪记录队员的重要指标， 这在团队在Sochi奥运会上取得的成功中扮演了很重要的角色。 同样的， 这些小型设备还可以影响到保险行业， 保险公司可以通过获得客户的个人信息来更加精确的计算客户的风险， 从而来降低保价。当然， 这肯定会引发很多的隐私问题， 但是对那些为了折扣同意提供自己个人信息的市民而言还是很有可能做到的。

智能手表

与活动跟踪不同， 智能手表更多的是被用来主动使用的。 在很早以前就已经播下了智能手表的种子： 近百年来， 腕表一直作为一个重要的工具， 一个用于计时，随时告知我们身处当下的工具。

如今， 智能手表远远超出了这个范畴， 它能够给我们提供更加多样的情景信息： 邮件短信的提醒，会议的提醒，天气预报，电子票（机场，剧院，音乐会等等地方）。 智能手表还有着丰富的交互，意味着我们不仅可以用来查看我们的邮件， 还能回复邮件； 我们可以用来Google，入住酒店，修改音乐记录备忘，查看时间等等，再也不用花费时间去从手袋中掏出手机了。 正如设计师们都知道的， 行动的简洁性对我们决定是否采取行动有着非常重要的影响， 所以这些多余的时间是非常重要的。 这所有的一切都在说明一个现实， 就是我们如今把手机安放到了我们的手腕上， 虽然因此有了一些设计上的限制。

而对设计师而言更加有诱惑力的一个现实就是智能手表是支持定制apps的， 这也意味着我们可以拥有一个全新的手表专属apps的生态系统了。 我们可以看到全新版本的Instagram，Pinterest，Foursquare以及各种各样的新的商业apps。 这对于各大品牌而言同样是个好消息，因为他们有了一个新的机会和渠道向他们的客户宣传自己了。

智能眼镜

信息一直在不断的向着和我们大脑建立协同发展关系的目标前进着， 而智能眼镜无疑是这一阶梯上的下一步–跟随在20世纪60年代的计算中心的成功，以及之后数十年的PC时代，笔记本时代和手机时代之后。 智能眼镜和智能手表有一点是相似的： 他们把信息和我们的距离拉的更近了， 而且鼓励这种更加简单的交互形式。 但是， 眼镜是完全的解放了我们的双手， 彻底的把信息直接带到了我们的眼前， 完全使用语音命令和感应器作为输入设备。

与智能手表很轻易的就能融入到我们的日常生活不同， 智能眼镜略微有一点过于超前了。 问题出在很多方面， 比如：技术上，习俗上，以及社交上等等。 简而言之， 以Google Glass这个当前最有代表性的智能眼镜技术为例， 它所提供的价值和他本身的价格并不相配：$1500的价格，极为有限的电池寿命，非常不舒服的街道视觉体验等等， 再加上一个简单的相机和导航，非常有限的几个酷炫应用和效果， 尚不足以说服我每天都早上把这玩意带在我的脸上。。。至少目前还不行。

这种现象也被成为『杀手级应用问题』， 但是它并不意味着这个产品或者这种表现形式就是彻底无用的。 相反， 它已经被证实对商业使用有着巨大的价值：医生们可以用在手术过程中看到重要的提示，仓库工作人员就可以用语音实现商品扫描以及详细信息录入等事情了，运动员可以实时的看到他们的数据–这些理由都足够让Google开启他们的商业化项目并且和Vuzix合作了。 这其中的模式非常清楚而直接： 允许雇员们在工作以及处理数据的过程中解放双手。 这不仅可以节省他们的时间， 同时还能提高安全性： 不需要更换手套， 拿手机或者因为别的屏幕而分散注意力。

结论

每一种穿戴式设备都有他自身的特点。有一些只是单纯的用于收集数据， 还有一些则是用来进行主动的交互， 有些是把自身的使用环境建立在每天的日常使用基础上，而有些可能在某些特定场合下更加有帮助， 有一些可能在社会接受程度上更为突出， 而有些则需要时间和规则才能被慢慢接受。 但是他们都共享着一些相似的属性， 而了解这一点对于设计师，开发者以及那些处理产品商业相关事宜的人们都会有更好帮助，帮助他们更加全面的利用这些设备。

Resource:

原文：The Who, What, When, Wear, and Why of Wearable Technology
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>当你出现在Designer News的头条之后会发生什么?</title><link>http://taoalpha.me/blog/2014/11/25/read-what-happens-when-you-appear-after-the-designer-news-headlines/</link><category>read</category><tag>DN,翻译文章,译系列</tag><pubDate>2014-11-25T12:00:00.000Z</pubDate><description>本文原文来自 What happens when you’re #1 on Designer News , 内容主要是介绍了一个上周的DN头条产品, 在DN的首位占据了大概12个小时的时间, 获得了48的赞和16个评论, 然后他们分析了这一段时间的一些数据, 很有意思, 值得一看哦~

一些背景数据: DN目前大约有17000个注册用户, 主要受众是设计圈~

总体指标:

一些关于直接来自DN的用户总体指标:

1900 用户5600 PV平均一次访问时长: 1:40min蹦失率: 60%

其他一些结果:

而因为一些看客们在社交媒体上分享了我们的网站, 所以我们实际获得了更多的访问者, 甚至在某个blog中露了一次脸:

SitePoint的报道(带来了500的访问者)大约50条Tweets来自Google+的100位访问者来自facebook的1000位访问者PV的峰值达到了80/min

有几个大牛也在twitter上转载了关于我们的产品推文.

用户的其他属性:

DN的用户基本是30岁左右, 来自美国本土的MacBook用户, 通常使用的也都是Chrome(当然他们中多数都厌恶IE, 哈哈. PS: who doesn’t?):

OS: 83% Mac, 11%  windowsMobile:  95% Desktop, 4% Mobile, 1% TabletBrowser: 88% Chrome, 11% Safari, … , 0% IE!!!Coutries: 40% 美国, 10%的英国, 5%的加拿大, 4%的德国, 4%的瑞士;Language: 85%的英语;

 

如上~

博主说:

对于一个小产品或者说初始项目而言, 这种小站或者特定细分的垂直站的推广也是不容小觑的哦~ 不过从用户属性来说, DN这种垂直站点的用户属性确实非常突出, 集中啊.
</description><source>TaoAlpha</source><author>TaoALpha</author></item></channel></rss>