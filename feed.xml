<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TaoAlpha's Blog</title><link>http://taoalpha.me/blog</link><pubDate>2016-01-31T15:26:52.319Z</pubDate><description></description><language>en</language><generator>hexo</generator><item> <title>OJ Calculator Problems</title><link>http://taoalpha.me/blog/2016/01/30/oj-oj-calculator-problems/</link><category>OJ</category><tag>LeetCode,Stack</tag><pubDate>2016-01-31T01:18:18.000Z</pubDate><description>224    Basic CalculatorQuestionImplement a basic calculator to evaluate a simple expression string.
The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .
You may assume that the given expression is always valid.
Some examples:“1 + 1” = 2“ 2-1 + 2 “ = 3“(1+(4+5+2)-3)+(6+8)” = 23
Note: Do not use the eval built-in library function.
LeetCode224	Basic Calculator
Tags: Stack, Math, Medium
AnswersTwo StackFirst, we can use two stack, one stores numbers, the other stores the operators, and once we got the “)”, we start to pop elements and operators to calculate.
123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  var nums = [], ops = [], number = 0, i;  //s = s.replace(/ /g,&quot;&quot;); // skip all spaces with replace first  for(i = 0; i &amp;lt; s.length; i++)&amp;#123;    if(s[i] == &quot; &quot;) continue; // skip all spaces    var c = s[i];    if (c == '(' || c == '+' || c == '-') &amp;#123;      // push all operators into ops and go to next position      ops.push(c);       continue;    &amp;#125;    if (c == ')') &amp;#123;      // remove the remaining &quot;(&quot;      ops.pop();    &amp;#125;else if(s[i] != &quot; &quot;  &amp;amp;&amp;amp; Number.isInteger(Number(c)))&amp;#123;      // for digits, combine them to get our operands      // Number(&quot; &quot;) will be converted to 0 and return true for isInteger()      number = number*10 + Number(c);      if (i + 1 &amp;lt; s.length &amp;amp;&amp;amp; s[i+1] != &quot; &quot; &amp;amp;&amp;amp; Number.isInteger(Number(s[i+1]))) continue;      // make sure we got all digits for one operand, and no out of bound      nums.push(number);  // push the operand to our nums      number = 0;    &amp;#125;        if (ops.length == 0 || ops[ops.length-1] == &quot;(&quot;) continue;  // skip if no operators or we have finish all in this pair of parentheses      // get our operator and operands    var op2 = nums.pop(),        op = ops.pop();        // do the calculate with second operand    if (op == &quot;+&quot;) &amp;#123;      nums[nums.length-1] += op2;    &amp;#125;else if (op == &quot;-&quot;) &amp;#123;      nums[nums.length-1] -= op2;    &amp;#125;  &amp;#125;  return nums.pop()  // now our nums should only have our result&amp;#125;
Runtime: 168 ms - 180 ms
One StackPrevious solution we use a second stack store the operators, but actually we don’t need to do that. If we separate the whole expression into several small parts, then everytime we find a parentheses, we just store the previous result after calculation to the stack, and solve the inner part first.
And in order to do this way, we need initialize the result to 0.
1234567891011121314151617181920212223242526272829303132333435363738/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  var stack = [],i,sign = 1,result = 0, number = 0;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    var c = s[i];    if (c != &quot; &quot; &amp;amp;&amp;amp; Number.isInteger(Number(c))) &amp;#123;      number = 10*number + Number(c)    &amp;#125; else if (c == &quot;+&quot;) &amp;#123;      result += sign * number;      sign = 1;  // keep the positive sign      number = 0;  // clear the number after calculation    &amp;#125; else if (c == &quot;-&quot;) &amp;#123;      result += sign * number;      number = 0;      sign = -1;  // make sure now we have a negative operator, this will affect the last result of next number    &amp;#125; else if (c == &quot;(&quot;) &amp;#123;      // result += sign*number;  // make sure our result including the last number, actually a open parenthese would always follow another operator like + or -, and we already clear the number      // now we need store the result to stack      stack.push(result);      stack.push(sign);  // store the sign, used for next operand (previous result +/- wait for next result)      result = 0;  // clear the result and solve the inner part      sign = 1;  // reinitialize the sign    &amp;#125; else if (c == &quot;)&quot;) &amp;#123;      // now we finish the inner part      result += sign*number;  // the end parenthese always follow a number      result *= stack.pop();  // determine it is - or + this result      result += stack.pop();  // now add the previous result      number = 0;  // clear the number    &amp;#125;  &amp;#125;  if (number != 0) &amp;#123;    result += sign * number;  // in case we only have a number without any operators  &amp;#125;  return result;&amp;#125;
Runtime: 176 ms
227. Basic Calculator IIQuestionImplement a basic calculator to evaluate a simple expression string.
The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.
You may assume that the given expression is always valid.
Some examples:“3+2*2” = 7“ 3/2 “ = 1“ 3+5 / 2 “ = 5
Note: Do not use the eval built-in library function.
LeetCode227. Basic Calculator II
Tags: String, Medium
AnswersDirect Updating StackSince we don’t have parentheses which make this question much easier, we can just keep calculating all the * and /, then store all results into the stack, and also store the - with second operator as a negative number, then we just need to sum all the stack to get our final answer.
In order to deal with the first number, we could prepend the expression with a “0+”, so we initialize the first number as 0 and first operator as “+”.
123456789101112131415161718192021222324252627282930313233/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */ var calculate = function(s) &amp;#123;   var stack = [], num = 0, c = &quot;+&quot;, i;   for (i = 0; i &amp;lt; s.length+1; i++) &amp;#123;     if (s[i] == &quot; &quot;) continue;  // skip all spaces     if (Number.isInteger(Number(s[i]))) &amp;#123;       num = 10 * num + Number(s[i]);       continue;     &amp;#125;else if (c == &quot;+&quot;) &amp;#123;       stack.push(num);     &amp;#125;else if (c == &quot;-&quot;) &amp;#123;       stack.push(-num);     &amp;#125;else if (c == &quot;*&quot;) &amp;#123;       stack.push(stack.pop()*num);  // do the calculation!     &amp;#125;else if (c == &quot;/&quot;) &amp;#123;       // be careful about the negative number, since we only need the integer part       var temp = stack.pop();       if (temp &amp;lt; 0) &amp;#123;         temp = Math.ceil(temp/num);       &amp;#125;else&amp;#123;         temp = Math.floor(temp/num);       &amp;#125;       stack.push(temp);     &amp;#125;     num = 0;     c = s[i];  // always store the precious closest operator before current number   &amp;#125;   stack.push(num);   return stack.reduce( (sum,v) =&amp;gt; sum += v )&amp;#125;
Runtime: 236 ms
Previous code would have an “out of bound” issue, but js just doesn’t have this kind of error…
You can remove the continue after getting the number, and change the condition for second part with:
12345if (!Number.isInteger(Number(s[i])) || i == s.length - 1) &amp;#123;  ...  num = 0;  c = s[i];&amp;#125;
Runtime: 200 ms
No StackSame idea, but we don’t need the stack, we just keep the previous result and always add the current result to the previous result whenever we can.123456789101112131415161718192021222324252627282930/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  var result = 0, cur_res = 0, op = '+', pos;  s = s.replace(/ /g,'');  for(pos = 0; pos &amp;lt; s.length;) &amp;#123;    if (Number.isInteger(Number(s[pos]))) &amp;#123;      var tmp = Number(s[pos]);      while(pos++ &amp;lt; s.length &amp;amp;&amp;amp; Number.isInteger(Number(s[pos]))) &amp;#123;        tmp = tmp*10 + Number(s[pos]);      &amp;#125;      switch (op) &amp;#123;        case '+' : cur_res += tmp; break;        case '-' : cur_res -= tmp; break;        case '*' : cur_res *= tmp; break;        case '/' : cur_res = cur_res &amp;lt;= 0 ? Math.ceil(cur_res / tmp) : Math.floor(cur_res / tmp); break;      &amp;#125;    &amp;#125;else &amp;#123;      if(s[pos] == '+' || s[pos] == '-') &amp;#123;        result += cur_res;        cur_res = 0;      &amp;#125;      op = s[pos++];    &amp;#125;  &amp;#125;  return result + cur_res;&amp;#125;
Runtime: 196 ms
CalculatorQuestionSo if we combine the two problems together, we can make a simple calculator that can do basic calculation.
AnswerThe basic idea is convert the infix notation to Polish notation or Reverse Polish notation and store them into a stack, then we can just use stack to calculate the result.
Here is the origin solution from leetcode
Here is the reverse polish notation on wikipedia
12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  s = &quot;(&quot; + s.replace(/ /g,'') + &quot;)&quot;;  var nums = [], ops = [], i, curNum = 0;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    var c = s[i];    if (Number.isInteger(Number(c))) &amp;#123;      curNum = 10*curNum + Number(c);    &amp;#125; else if (c == &quot;(&quot;) &amp;#123;      ops.push(&quot;(&quot;);      ops.push(&quot;+&quot;);    &amp;#125; else &amp;#123;      var topOp = ops[ops.length-1];      switch (topOp) &amp;#123;        case &quot;*&quot;:        case &quot;/&quot;:          curNum = topOp == &quot;/&quot; ? Math.floor(nums.pop()/curNum) : nums.pop() * curNum;          ops.pop();      &amp;#125;      switch (c) &amp;#123;        case &quot;)&quot;:          if (ops[ops.length-1] == &quot;-&quot;) &amp;#123;            curNum = -curNum;          &amp;#125;          ops.pop();          while (ops[ops.length-1] != &quot;(&quot;) &amp;#123;            curNum += ops.pop() == &quot;-&quot; ? -nums.pop() : nums.pop();          &amp;#125;          ops.pop();  // skip &quot;(&quot;          break        default:          ops.push(c);          nums.push(curNum);          curNum = 0;      &amp;#125;    &amp;#125;  &amp;#125;  return curNum&amp;#125;
Runtime: 184 ms for Basic Calculator IRuntime: 196 ms for Basic Calculator II
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Remove Duplicate Letters</title><link>http://taoalpha.me/blog/2016/01/26/oj-oj-remove-duplicate-letters/</link><category>OJ</category><tag>Greedy,LeetCode</tag><pubDate>2016-01-26T23:26:53.000Z</pubDate><description>316. Remove Duplicate LettersQuestionGiven a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.
Example:Given “bcabc”Return “abc”
Given “cbacdcbc”Return “acdb”
LeetCode316. Remove Duplicate Letters My Submissions Question
Tags: Medium, Stack, Greedy
AnswersGreedy
Greedy algorithm is an algorithm that follows the problem solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum. In many problems, a greedy strategy does not in general produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a global optimal solution in a reasonable time.

Classic problem is the coin changes problem: determine minimum number of coins to give while making change.
This problem can also be solved with greedy algorithm, we just need to determine the local optimal choice first: 

We need find the current smallest letter in the string and put it into our result, smallest means that smallest one that could be put into the result;

Now question is how we determine the smallest letter:

Condition 1: the letter is smaller than every letter appeared before it and it only appear once, then it would be our smallest, like “cbacb”, the “a” will be our current smallest;
Condition 2: the letter only appeared once and the smallest letter should be the first smallest letter before this letter, like “cbdcb”, so the “b” will be our current smallest;

1234567891011121314151617181920212223242526272829/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var i,j,res = &quot;&quot;;  while (s !== &quot;&quot;) &amp;#123;    var countMap = &amp;#123;&amp;#125;;    // build the countMap for current string    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      countMap[s[i]] = countMap[s[i]] || 0;      countMap[s[i]] ++;    &amp;#125;    var smallestPos = 0;    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      if (s[smallestPos] &amp;gt; s[i]) &amp;#123;        // update the smallest number        smallestPos = i      &amp;#125;      // until find the letter only appeared once, and we will get the index of our smallest letter      if (countMap[s[i]] == 1) break;      countMap[s[i]] --;    &amp;#125;    // put the letter into our result string    res += s[smallestPos];    s = s.slice(smallestPos+1).replace(new RegExp(s[smallestPos],&quot;g&quot;),&quot;&quot;)  &amp;#125;  return res&amp;#125;;
Runtime: 244 ms
If we build the countMap with 0 default before we do the count part, it can speed up a little.
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var i,j,res = &quot;&quot;;  while (s !== &quot;&quot;) &amp;#123;    var countMap = &amp;#123;&amp;#125;;    // build the countMap for current string    for (i = 0; i &amp;lt; 26; i++) &amp;#123;       countMap[String.fromCharCode(i + 97)] = 0    &amp;#125;    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      countMap[s[i]] ++;    &amp;#125;    var smallestPos = 0;    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      if (s[smallestPos] &amp;gt; s[i]) &amp;#123;        // update the smallest number        smallestPos = i      &amp;#125;      // until find the letter only appeared once, and we will get the index of our smallest letter      if (countMap[s[i]] == 1) break;      countMap[s[i]] --;    &amp;#125;    // put the letter into our result string    res += s[smallestPos];    s = s.slice(smallestPos+1).replace(new RegExp(s[smallestPos],&quot;g&quot;),&quot;&quot;)  &amp;#125;  return res&amp;#125;;
Runtime: 196 ms
And of course you can use recursion instead of iterator to do it, but it should be slower than iteration way.
StackThis is a solution I found from the discussion: C++ solution using stack
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var cnts = &amp;#123;&amp;#125;, stack = [], isVisited = &amp;#123;&amp;#125;;  var i,j;  // build count mapper   for (i = 0; i &amp;lt; 26; i++) &amp;#123;     cnts[String.fromCharCode(i + 97)] = 0  &amp;#125;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    cnts[s[i]] ++  &amp;#125;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    cnts[s[i]] --;    if (isVisited[s[i]]) continue;    while (s[i] &amp;lt; stack[0] &amp;amp;&amp;amp; cnts[stack[0]]) &amp;#123;      // if the letter is smaller than previous smaller letter(stack[0]) and we still have some stack[0] after this letter,      // Then we remove it from the stack      isVisited[stack[0]] = false;      stack.shift();    &amp;#125;    // put the smaller one we find into the stack    stack.unshift(s[i]);    isVisited[s[i]] = true;  &amp;#125;  return stack.reverse().join(&quot;&quot;)&amp;#125;
Runtime: 192 ms
This is so comlicated to figure out… I don’t think I can come up with this solution during any interview… maybe I can after I finish the Algoithm Class of this semester.
Another WayEasy to understand iterative Java solution has a really nice and easy to understand solution for this problem.

find out the last appeared position for each letter; c - 7 b - 6 a - 2 d - 4find out the smallest index from the map in step 1 (a - 2);the first letter in the final result must be the smallest letter from index 0 to index 2;repeat step 2 to 3 to find out remaining letters.

123456789101112131415161718192021222324252627282930313233343536373839/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var countMap = &amp;#123;&amp;#125;, res = [];  var i,j;  // build count mapper with letter-last index  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    countMap[s[i]] = i  &amp;#125;  // loop and try to find the smallest letter between each interval of last index, start from 0  var len = Object.keys(countMap).length,      begin = 0,      end = findMinLastIdx(countMap);  for (i = 0; i &amp;lt; len; i++) &amp;#123;    var minChar = &quot;z&quot;;    for (j = begin; j &amp;lt;= end; j++) &amp;#123;      if (countMap[s[j]] &amp;gt; -1 &amp;amp;&amp;amp; s[j] &amp;lt; minChar) &amp;#123;        minChar = s[j];        begin = j + 1;      &amp;#125;    &amp;#125;    res[i] = minChar;    countMap[minChar] = -1    end = findMinLastIdx(countMap);  &amp;#125;  return res.join(&quot;&quot;)&amp;#125;var findMinLastIdx = (countMap) =&amp;gt; &amp;#123;  var min = Math.pow(2,31)-1;  for(var item in countMap)&amp;#123;    if(countMap[item]!=-1)&amp;#123;      min = Math.min(countMap[item],min)    &amp;#125;  &amp;#125;  return min&amp;#125;
Runtime: 192 ms
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Ugly Number Problems</title><link>http://taoalpha.me/blog/2016/01/25/oj-oj-ugly-number-problems/</link><category>OJ</category><tag>LeetCode,Numbers</tag><pubDate>2016-01-25T07:09:04.000Z</pubDate><description>263. Ugly NumberQuestionWrite a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
Note that 1 is typically treated as an ugly number.
LeetCode263. Ugly Number
Tags: Math, Easy
AnswersI think there is only one way to solve this problem efficiently, which is based on the math fact of this problem.
Based on the definition, if we keep dividing the number by 2, 3 or 5, and finally we get 1, then it should be a ugly number, otherwise it would be something else.
1234567891011121314/** * @param &amp;#123;number&amp;#125; num * @return &amp;#123;boolean&amp;#125; */var isUgly = function(num) &amp;#123;  // num is not prime and divide by 2, 3, 5   if(num&amp;lt;1)&amp;#123;return false&amp;#125;  if(num === 1)&amp;#123;return true&amp;#125;  num = num % 5 === 0 ? num / 5 : (num % 3 === 0) ? (num / 3) : (num % 2 === 0) ? (num / 2) : &quot;true&quot;;  if(num === &quot;true&quot;)&amp;#123;    return false;  &amp;#125;  return isUgly(num)&amp;#125;;
Runtime: 208 ms
We can simplify above code with an for and while loop.
123456789101112/** * @param &amp;#123;number&amp;#125; num * @return &amp;#123;boolean&amp;#125; */var isUgly = function(num) &amp;#123;  for (var p of [2, 3, 5])&amp;#123;    while (num &amp;amp;&amp;amp; num % p == 0) &amp;#123;      num /= p;    &amp;#125;  &amp;#125;  return num == 1;&amp;#125;;
Runtime: 224 ms
264. Ugly Number IIQuestionWrite a program to find the n-th ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note that 1 is typically treated as an ugly number.
LeetCode264. Ugly Number II
Tags: Dynamic Programming, Heap, Math, Medium
AnswersUsing isUgly123456789101112131415161718192021222324252627/** * @param &amp;#123;number&amp;#125; n * @return &amp;#123;number&amp;#125; */var nthUglyNumber = function(n) &amp;#123;    console.log(n)    if(n &amp;lt;= 0) return false; // get rid of corner cases     if(n == 1) return 1; // base case    var count=1,i=0,num = 1;    for(i = 1;count &amp;lt;= n;i++)&amp;#123;        if(isUgly(i))&amp;#123;            count ++;            num = i;        &amp;#125;    &amp;#125;    return num&amp;#125;;var isUgly = function(num) &amp;#123;  // num is not prime and divide by 2, 3, 5   if(num&amp;lt;1)&amp;#123;return false&amp;#125;  if(num === 1)&amp;#123;return true&amp;#125;  num = num % 5 === 0 ? num / 5 : (num % 3 === 0) ? (num / 3) : (num % 2 === 0) ? (num / 2) : &quot;true&quot;;  if(num === &quot;true&quot;)&amp;#123;    return false;  &amp;#125;  return isUgly(num)&amp;#125;;
Sadly, it will be TLE since it is so slow….
DPThis is a classic DP problem if you treat every n-th is a status, and we can find:

f(0) = 1
f(1) = min(f(0)2,f(0)3,f(0)*5)
f(2) = min(f(1)2,f(0)3,f(0)*5)…

Just be careful about the number like 6, since it can be got from 23 or 32, so we need update both pointers stand for 2 and 3.
123456789101112131415161718/** * @param &amp;#123;number&amp;#125; n * @return &amp;#123;number&amp;#125; */var nthUglyNumber = function(n) &amp;#123;  if(n &amp;lt;= 0) return false; // get rid of corner cases   if(n == 1) return 1; // base case  var p2 = 0, p3 = 0, p5 = 0; //pointers for 2, 3, 5  var f = [];  f[0] = 1;  for(var i  = 1; i &amp;lt; n ; i ++)&amp;#123;    f[i] = Math.min(f[p2]*2,f[p3]*3,f[p5]*5);    if(f[i] == f[p2]*2) p2++;     if(f[i] == f[p3]*3) p3++;    if(f[i] == f[p5]*5) p5++;  &amp;#125;  return f[n-1];&amp;#125;;
Runtime: 212 ms
313. Super Ugly NumberQuestionWrite a program to find the nth super ugly number.
Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.
Note:(1) 1 is a super ugly number for any given primes.(2) The given numbers in primes are in ascending order.(3) 0 &amp;lt; k ≤ 100, 0 &amp;lt; n ≤ 106, 0 &amp;lt; primes[i] &amp;lt; 1000.
LeetCode313. Super Ugly Number
Tags: Math, Heap, Medium
AnswersDPWe can use same code as before, just replace the hardcode 2,3,5 with a prime list.
12345678910111213141516171819202122232425/** * @param &amp;#123;number&amp;#125; n * @param &amp;#123;number[]&amp;#125; primes * @return &amp;#123;number&amp;#125; */var nthSuperUglyNumber = function(n, primes) &amp;#123;  if(n &amp;lt;= 0) return false; // get rid of corner cases   if(n == 1) return 1; // base case  var p = [];  for(var i = 0;i&amp;lt;primes.length;i++)&amp;#123;    p[i] = &amp;#123;      prime : primes[i],      count:0    &amp;#125;;  &amp;#125;  var f = [];  f[0] = 1;  for(var i  = 1; i &amp;lt; n ; i ++)&amp;#123;    f[i] = Math.min.apply(null,p.map( (a) =&amp;gt; &amp;#123; return f[a.count]*a.prime &amp;#125; ) );    for(j = 0;j&amp;lt;p.length;j++)&amp;#123;      if(f[p[j].count]*p[j].prime == f[i]) p[j].count ++;     &amp;#125;  &amp;#125;  return f[n-1];&amp;#125;;
Runtime: 404 ms
HeapAs usally, though I got accepted for the dp solution, but it is so slow… So I open the discussion and look through some best votes answers, find this nice solution:
12345678910111213141516171819202122232425/** * @param &amp;#123;number&amp;#125; n * @param &amp;#123;number[]&amp;#125; primes * @return &amp;#123;number&amp;#125; */var nthSuperUglyNumber = function(n, primes) &amp;#123;  var res = [1],      idxs = [],      i,j;  for (i = 1; i &amp;lt; n; i++) &amp;#123;    res[i] = Math.pow(2,31) - 1;    for (j = 0; j &amp;lt; primes.length; j++)&amp;#123;      idxs[j] = idxs[j] || 0;      res[i] = Math.min(res[i],primes[j] * res[idxs[j]]);    &amp;#125;    for (j = 0; j &amp;lt; idxs.length; j++)&amp;#123;      if (res[i] == primes[j] * res[idxs[j]]) &amp;#123;        idxs[j] = idxs[j] || 0;        idxs[j] ++;      &amp;#125;    &amp;#125;  &amp;#125;  return res[n-1]&amp;#125;
Runtime: 276 ms
Actually it is pretty much the same as the DP solution… but much faster. 
We actually can combine the two for loops into one to speed up again:
123456789101112131415161718192021var nthSuperUglyNumber = function(n, primes) &amp;#123;  var res = [],      idxs = [],      vals = new Array(primes.length+1).join(1).split('').map(parseFloat),      i,j,next = 1;    for (i = 0; i &amp;lt; n; i++) &amp;#123;    res[i] = next;    next = Math.pow(2,31) - 1;    for (j = 0; j &amp;lt; primes.length; j++)&amp;#123;      // skip duplicate and avoid extra multiplication      if (vals[j] == res[i]) &amp;#123;        idxs[j] = idxs[j] || 0;        vals[j] = res[idxs[j]++] * primes[j];      &amp;#125;      next = Math.min(next,vals[j]);    &amp;#125;  &amp;#125;  return res[n-1]&amp;#125;
Runtime: 232 ms
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>High-Performance Browser Networking .1.Preface</title><link>http://taoalpha.me/blog/2014/07/24/read-yi-high-performance-browser-networking-1-preface/</link><category>read</category><tag>技术文章,浏览器性能,翻译文章,译系列</tag><pubDate>2014-07-24T11:00:00.000Z</pubDate><description>chrome一直以极速著称, 当然这和webkit内核有很大的关系, 但是本身chrome在网络处理上也有着非常多的优化方案, 综合了这些优化和本身优质的内核属性, chrome才能实现如今的极速~ 
进入正文前, 先介绍下原文或者说原书的作者: Ilya Grigorik.
Ilya是google的一个网络性能开发工程师, 其在很多方面都有杰出的成绩~ 有兴趣的可以去大神的github上看看大神都在做什么项目, 顺带能观摩学习下大神的代码~
==================================正文=============================
前言–Steve Sounders, Head Performance Engineer, Google, 2013
“优秀的开发者知道如何做, 伟大的开发者知道为什么这么做.”
我们一直都以此名言勉励自己. 我们都希望成为那个知道而且可以解释我们所使用系统的底层原理的人. 但是, 如果你是一个网页开发者, 你可能反而要走相反的路子.
网页开发者现在变得越来越细分. 你是什么类型的开发者呢? 前端? 后端? 韵味? 大数据分析? UI/UX(交互设计)? 存储? 视频? 信息流? 我还可以给这个长长的列表中加入性能工程师这一细分领域. 
我们很多时候很难平衡技术的基础学习和前沿领域的了解. 但是, 如果我们不能了解这些基础知识, 我们的知识系统一定很空洞, 很浅薄. 仅仅知道一个技术手段的顶层使用是不够的, 尤其是在面对一些复杂的问题时, 一旦出现了一些莫名其妙的问题, 那么依赖的还是掌握底层原理的人.
这也是为什么本书(High Performance Browser Networking)如此重要了. 如果你是一个网页开发者, 那么你的基础知识就是网络以及网络协议基于的金字塔结构: TCP-TLS-UDP-HTTP以及其他一些东东. 这其中的每一个协议都有其自身的性能属性特点和优化方法, 而为了创建高性能的应用, 你就需要去了解网络的工作形式, 为什么是这样的而不是那样的~
感谢上苍, 你已经找到了如何阅读本书的方法. 我真希望在我开始网络编程之路时能够有这本书啊. 当初完全依靠那些懂得网络原理的前辈的言传身教以及自己硬啃那些说明指导才一步步走到现在的. HPBN一书集合了一个网络界的前辈–Ilya Grigorik–他把自己对网络的方方面面了解都融合集成到了这本书中.
在本书中, Ilya详尽解释了许多关于网络的原理性知识: 比如为什么延迟(latency)是性能的绊脚石. 为什么TCP并不总是最好的传送机制以及UDP可能是你更好的选择. 还有为什么链接复用是个非常关键的优化. 紧接着他更进一步的提供了很多提升网络性能的具体方法. 想要减少延迟? 尽可能在里客户端更近的服务器端中断会话. 想要提升链接的复用? 启用链接的长效性. 就是这种如何做和为什么这么做的结合让本书传达的知识更有可操作性.
Ilya 阐述了网络的基本原理并且基于此介绍了很多协议和浏览器方面的前沿知识. HTTP 2.0的有点也有所介绍. 回顾了XHR以及它的局限性, 和由此引发的跨域资源共享问题的介绍.Server-Sent Events, WebSockets, 和 WebRTC 也都所涉及, 带我们领略了一些浏览器网络的最前沿.
本书的两大核心就是基础原理和前沿知识. 性能是帮助我们理解网络的根本, 并将之转化到性能是如何影响到我们的网页和用户的. 它把复杂的概念转化成了我们可以真正用于提升优化自己网站并创造更好的用户体验的工具. 这一点很重要, 这也是你为什么要阅读本身的重要原因.
浏览器是当下受众面最广的部署平台了: 它出现在每一台智能手机, 平板, 笔记本, 台机和每一个介于其中形式的载体上. 实际上, 从目前设备的涨势来看, 我们预期2020年的时候入网设备能够达到200亿–至少有一个浏览器而且至少可以接入wifi或者信号基站. 而平台的形式, 设备的厂商, 以及操作系统的版本都不是问题, 每一个设备都至少会有一个网页浏览器, 而浏览器本身功能也在越发丰富了.
我们如何看到的浏览器已经和过去的老版本有了千差万别, 这得益于进来的一系列创新: HTML, CSS形成的展示层, JavaScript作为web集成的新语言被引入, 以及HTML5的提出和其新的API都在继续提升着新平台提供高性能应用的能力. 当今再没有别的技术或者平台能够做到这样, 这么的面向全部人类, 同时这也是如今各种机会, 创新频出的领域.
实际上, 再没有比浏览器内部的网络基础机构更适合阐述网络的快速迭代和创新了. 历史上, 我们曾经受限于简单的HTTP请求式交互, 而如今, 我们拥有了更加丰富的机制, 可以实现更加有效的信息流传递, 双向而实时的交流, 自定义应用协议的传递以及一对一的视频会议, 各方之间的数据直接传输等等, 只需要JavaScript, 足矣.
最终结果? 不计其数的联网设备, 已有服务和新服务中不断壮大的用户基数, 以及对高性能应用的高需求. 速度一直都是一个功能特点, 甚至对一些应用而言, 它是决胜功能点, 而一个高性能的网页应用也需要一个对浏览器如何工作以及和网络的交互有扎实, 基础的了解的人, 这也是本书的受众.
About this Book(关于本书)
我们的目的是能够覆盖到每一个应该了解网络是如何工作的开发者: 我们使用的是哪一种协议, 它有什么局限性, 如何最大化的优化你的性能来使用你的网络, 以及浏览器提供了什么样的网络特性来让你使用.
在此过程中, 我们会深入的了解TCP, UDP以及TLS协议, 以及如何去针对性的优化我们的应用和基础结构. 接着我们会深入的了解下无线和移动网是如何工作的–就是无线电波这家伙, 比较难懂–还会讨论一些它对我们设计和搭建我们自己的应用的启发. 最后, 我们们仔细剖析一下HTTP协议是如何工作的, 并调查下浏览器中许多新的,让你兴奋的网络特性:
    即将到来的HTTP 2.0的改善;    新XHR的特点和能力;    结合Server-Send Events的数据流    使用WebScoket的双向沟通;    点对点的视频和音频沟通–WebRTC;    点对点的数据交互–DataChannel

理解每一个字节都是如何传递的,以及每个传递过程和协议的属性对我们创建高性能应用都是至关重要的知识. 毕竟, 如果我们的应用卡死在网络上, 那么无论怎么渲染, JS或者其他的优化方式都是没有意义的. 我们的目标是通过近可能最大的提升网络性能而减少等待的时间.
HPBN一书将会是任何一个乐于研究优化传递和应用性能的开发者的菜, 更广面的, 任何一个不满足于一个简单的checklist, 而是想要了解浏览器和底层协议是如何工作的, 有着强烈好奇心的人, 都是本书的受众. 其中如何做以及为什么做会交替进行: 我们将会覆盖到很多实际的建议, 帮助你更好的进行配置和架构规划, 我们还会探究下每一种优化方法的益处和代价.
Conventions Used in This Book(本书使用的一些习惯表达)
    斜体: 代表新术语, URLs, email地址, 文件名或者文件扩展名;    Constant width:Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.    Constant width bold: Shows commands or other text that should be typed literally by the user.    Constant width italic: Shows text that should be replaced with user-supplied values or by values determined by context.后面三个和两种tip的形式都无法在本译文中体现, 所以就不管了哈…Source links:    Preface Part1    Preface Part2
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>FeedPusher Pre-Alpha-Release</title><link>http://taoalpha.me/blog/2016/01/23/tech-feedpusher-pre-release/</link><category>tech</category><tag>FeedPusher,NodeJS</tag><pubDate>2016-01-24T02:26:45.000Z</pubDate><description>As getting close the the end of the winter break, I’m almost ready to release the alpha version of new feedpusher :).
Here is some declaration before I release the first version :)

Instead of a public service, the first one or maybe several versions would be invitation only since the the service host on my raspberry pi, can not handle too many requests;
Also because I will host it on my raspberry pi until the beta version, so during the alpha, maybe the service will be kind of unstable but once I have some new and fancy functions, I will add to it… :) ;
And I will release all source code including the spider, and maybe write a series posts about how to set up one for youself (actually I have done that, here is the link to my feedpusher refactor branch, all updates will synchronize to this branch);
Normally I wouldn’t record any personal information except for your standard user profile, but I will record the person who add the site first as a trace to track contributions :) ;
If you really want to use it or test it, please send me an email to ask for an invitation code, otherwise, you can use test@mail.com and test2016 to log in and have fun, remember tell me all your suggestions if you have :)

Here is the basic functions the first released version will cover:

Common:
Sign in;
Add;
Delete;
Load more;
Read;
Mark as read(automatically);
Skip all read items;
Reload as requested;


tablet or middle sized screen:
Read within the page;
Check the x-frame-option, show tips when there is some CORS limitation;


Mobile or small screen:
Nothing special


Chrome App:
Use webview;


Chrome Extension:
Not this time;



Since you have read all these bullshit… :) Now you can try the demo with the test email and password I mentioned before.
Here is the Demo
:) Thanks!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Sum Closest Problems</title><link>http://taoalpha.me/blog/2016/01/21/oj-oj-sum-closest-problems/</link><category>OJ</category><tag>KSum,LeetCode</tag><pubDate>2016-01-22T03:12:51.000Z</pubDate><description>16. 3Sum ClosestQuestionGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
For example, given array S = {-1 2 1 -4}, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
LeetCode16. 3Sum Closest
Tags: Medium, Two Pointers, Array
AnswersKeep updating closest distanceThe first idea hit my head is using the same method in NSum Questions, but store the closest distance in a single value and keep updating it.
Here is the code:12345678910111213141516171819202122232425262728293031323334/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number&amp;#125; */var threeSumClosest = function(nums, target) &amp;#123;  if(nums.length &amp;lt;= 0)&amp;#123;    return 0  &amp;#125;  if(nums.length &amp;lt;= 3)&amp;#123;    return nums.reduce( (a,sum) =&amp;gt; sum += a )  &amp;#125;  var i,left,right,closest = Math.pow(2,31)-1;  // set initial min to maximum  nums.sort( (a,b) =&amp;gt; a-b );  for(i = 0;i&amp;lt;nums.length-2;i++)&amp;#123;    // use nums.lenght -2 since there will be 3 numbers    left = i+1;    right = nums.length - 1;    while(left &amp;lt; right)&amp;#123;      // update min if we can      var sum = nums[i] + nums[left] + nums[right];      if ( Math.abs(sum - target) &amp;lt; Math.abs((closest - target)) ) &amp;#123;        closest = sum;      &amp;#125;      // normal loop over every possibility      if (sum &amp;lt; target) &amp;#123;        left ++;      &amp;#125;else&amp;#123;        right --;      &amp;#125;    &amp;#125;  &amp;#125;  return closest&amp;#125;;
Runtime : 160 ms
If there are a lot cases that atually can find the right combiantion which is the target, you can check the sum and target during the while loop, and maybe stop it earlier.
123if(sum == target)&amp;#123;  return sum&amp;#125;
Seems no simple and better solution for this one. So I will stop here.
KSum ClosestThis is not a leetcode problem. But same as KSum or NSum problems, can we summarize a general solution for KSum Closest ?
1234567891011121314151617181920212223242526272829// pre-requirement: has to be at least one solutionvar KSumClosest = function(nums, target, output, preSum, N) &amp;#123;    if (nums.length &amp;lt; N || N &amp;lt; 2) return  if (N == 2) &amp;#123;    var i = 0,        j = nums.length - 1;    while (i &amp;lt; j) &amp;#123;      var sum = preSum + nums[i] + nums[j];      if ( Math.abs(sum - target) &amp;lt; Math.abs(output.ans - target) ) &amp;#123;        output.ans = sum;      &amp;#125;      // normal loop over every possibility      if (sum &amp;lt; target) &amp;#123;        i ++;      &amp;#125;else&amp;#123;        j --;      &amp;#125;    &amp;#125;  &amp;#125;else&amp;#123;    var i = 0;    for(i = 0;i&amp;lt;nums.length;i++)&amp;#123;        preSum += nums[i]        KSumClosest(nums.slice(i+1), target, output, preSum, N - 1)        preSum -= nums[i]    &amp;#125;  &amp;#125;&amp;#125;
Accepted by previous 3sum closest.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Word Search Problems</title><link>http://taoalpha.me/blog/2016/01/20/oj-oj-word-search-problems/</link><category>OJ</category><tag>DFS,LeetCode,Word Search</tag><pubDate>2016-01-20T07:17:56.000Z</pubDate><description>79. Word SearchProblemGiven a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
For example,Given board =
[  [‘A’,’B’,’C’,’E’],  [‘S’,’F’,’C’,’S’],  [‘A’,’D’,’E’,’E’]]
word = “ABCCED”, -&amp;gt; returns true,word = “SEE”, -&amp;gt; returns true,word = “ABCB”, -&amp;gt; returns false.
LeetCode79. Word Search
Tags: Array, Backtracking, Medium
AnswersDFS and hashtableThe first idea hit my head is using dfs, so here is my exit condition:

index out of bound;
visited elements(stored in a hashtable);
prefix not fit with target;

True condition:

String match.

So I got my code:
123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string&amp;#125; word * @return &amp;#123;boolean&amp;#125; */var exist = function(board, word) &amp;#123;  var i , j, mapper = &amp;#123;&amp;#125;;   // all visited elements will be marked as true within mapper  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      if(board[i][j] == word[0])&amp;#123;        // start with the first same letter        if(dfs(board,i,j,'',word,mapper))&amp;#123;          return true        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;  return false&amp;#125;;var dfs = (board,x,y,comb,word,mapper) =&amp;gt;&amp;#123;  if(comb == word)&amp;#123;    // true condition    return true  &amp;#125;  if(mapper[x+&quot;-&quot;+y] || word.length &amp;lt; comb.length || word.indexOf(comb) !== 0)&amp;#123;    // exit condition 1    return false  &amp;#125;  if(x &amp;gt;= board.length || x &amp;lt; 0 || y &amp;gt;= board[x].length || y &amp;lt; 0) &amp;#123;    // exit condition 2, out of bound    return false  &amp;#125;  mapper[x+&quot;-&quot;+y] = true;  // mark current elements as visited  comb += board[x][y]  if(dfs(board,x+1,y,comb,word,mapper) || dfs(board,x,y+1,comb,word,mapper) || dfs(board,x,y-1,comb,word,mapper) || dfs(board,x-1,y,comb,word,mapper))&amp;#123;    return true  &amp;#125;else&amp;#123;    mapper[x+&quot;-&quot;+y] = false    // recover the element for following loop  &amp;#125;&amp;#125;
You can pass with this. But it will be slow as 404ms.
DFS OptimizationI look at my code again, and find that since I can compare the first letter, why not just compare the current letter for each dfs. So I move it into the dfs and simplify my code with new exit and true condition:
True condition:

All letters match;

Exit condition:

Letter not match;
index out of bound;
visited elements;

And also, we don’t need to store the visited elements, we can just change it and then put the origin one back after the loop;
So finally we got this:
123456789101112131415161718192021222324252627282930313233343536373839/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string&amp;#125; word * @return &amp;#123;boolean&amp;#125; */var exist = function(board, word) &amp;#123;  var i , j;  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      if(dfs(board,i,j,word,0))&amp;#123;        return true      &amp;#125;    &amp;#125;  &amp;#125;  return false&amp;#125;;var dfs = (board,x,y,word,step) =&amp;gt;&amp;#123;  if(step == word.length)&amp;#123;    // all letters match, we got our word    return true  &amp;#125;  if(x &amp;gt;= board.length || x &amp;lt; 0 || y &amp;gt;= board[x].length || y -1&amp;lt; 0) &amp;#123;    // exit condition 1 - out of bound    return false  &amp;#125;  if(board[x][y] == &quot;\0&quot; || board[x][y] !== word[step])&amp;#123;    // exit condition 2 - visited or not same letter    return false  &amp;#125;  var temp  = board[x][y];  board[x][y] = &quot;\0&quot;;   // change the visited elements to something else   if(dfs(board,x+1,y,word,step+1) || dfs(board,x,y+1,word,step+1) || dfs(board,x,y-1,word,step+1) || dfs(board,x-1,y,word,step+1))&amp;#123;    return true  &amp;#125;else&amp;#123;    board[x][y] = temp;   // put the origin letter back    return false  &amp;#125;&amp;#125;
Now with the new code, we can hit the 168 ms.
212. Word Search IIQuestionGiven a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
For example,Given words = [“oath”,”pea”,”eat”,”rain”] and board =
[  [‘o’,’a’,’a’,’n’],  [‘e’,’t’,’a’,’e’],  [‘i’,’h’,’k’,’r’],  [‘i’,’f’,’l’,’v’]]Return [“eat”,”oath”].Note:You may assume that all inputs are consist of lowercase letters a-z.
LeetCode212. Word Search II
Tags: Trie, Backtracking, Hard
AnswersTrie with classic waySince this question is based on the previous one, we can just borrow our previous code here. And if you just loop through all words, it will be TLE. So you have to do pruning to stop the dfs as soon as possible.
According to the hint, we can use Trie to help us stop the dfs earlier, here I just use some code I wrote for another problem. As before, lets list the exit condition and succesful conditions for this problem:
Exit conditions:

Out of bound;
Visited;
Prefix never show up in our Trie(which was built with all input words);

True conditon:

Words is in our Trie;

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Trie implementation in JavaScript */var TrieNode = function()&amp;#123;  // # of words end here   this.wordsCount = 0  // # of words will match the prefix  this.prefixMatches = 0  // all the node belong to this node  this.children = &amp;#123;&amp;#125;&amp;#125;var Trie = function()&amp;#123;  this.root = new TrieNode()&amp;#125;Trie.prototype.insert = function(word)&amp;#123;  // if not a word, return  if(word.length &amp;lt;=0) return  var node = this.root  var i = 0  // loop every character of the word and update associate node  while(i&amp;lt;word.length)&amp;#123;  if(!node.children.hasOwnProperty(word[i]))&amp;#123;    node.children[word[i]] = new TrieNode()  &amp;#125;  node = node.children[word[i]]   if(i == word.length-1)&amp;#123;    node.wordsCount ++  &amp;#125;else&amp;#123;    node.prefixMatches ++  &amp;#125;  i ++  &amp;#125;&amp;#125;Trie.prototype.startsWith = function(prefix)&amp;#123;  // if not a word, return  if(prefix.length &amp;lt;=0) return false  var node = this.root  var i = 0  // loop every character of the word and find whether there is any match  while(i&amp;lt;prefix.length)&amp;#123;  if(!node.children.hasOwnProperty(prefix[i]))&amp;#123;    return false  &amp;#125;  node = node.children[prefix[i]]   if(i == prefix.length-1 &amp;amp;&amp;amp; (node.prefixMatches !== 0 || node.wordsCount !== 0))&amp;#123;    return true  &amp;#125;  i ++  &amp;#125;  return false&amp;#125; Trie.prototype.search = function(word)&amp;#123;  // if not a word, return  if(word.length &amp;lt;=0) return false  var node = this.root  var i = 0  // loop every character of the word and find whether there is any match  while(i&amp;lt;word.length)&amp;#123;  if(!node.children.hasOwnProperty(word[i]))&amp;#123;    return false  &amp;#125;  node = node.children[word[i]]   if(i == word.length-1 &amp;amp;&amp;amp; node.wordsCount === 0)&amp;#123;    return false  &amp;#125;  i ++  &amp;#125;  return true&amp;#125;/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string[]&amp;#125; words * @return &amp;#123;string[]&amp;#125; */var findWords = function(board, words) &amp;#123;  var i,j, trie = new Trie(),output = new Set();  for(i = 0; i &amp;lt; words.length;i++)&amp;#123;    trie.insert(words[i])  &amp;#125;  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      dfs(board,i,j,0,'',trie,output)    &amp;#125;  &amp;#125;  var res = []  output.forEach( (v) =&amp;gt; &amp;#123;res.push(v)&amp;#125;)  return res&amp;#125;;/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string&amp;#125; word * @return &amp;#123;boolean&amp;#125; */var dfs = (board,x,y,str,trie,output) =&amp;gt;&amp;#123;  // the code is pretty much same with previous word search I, but store the fit words into output asap  if(x &amp;gt;= board.length || x &amp;lt; 0 || y &amp;gt;= board[x].length || y &amp;lt; 0) &amp;#123;    // exit condition 1 - out of bound     return false  &amp;#125;  if(board[x][y] == &quot;\0&quot;)&amp;#123;    // exit condition 2 - visited    return false  &amp;#125;  str += board[x][y];  // exit condition 2 - not in our trie tree  if(!trie.startsWith(str))&amp;#123;return false&amp;#125;  // match condition  if(trie.search(str))&amp;#123;output.add(str)&amp;#125;  var temp  = board[x][y];  board[x][y] = &quot;\0&quot;;  dfs(board,x+1,y,str,trie,output)  dfs(board,x,y+1,str,trie,output)  dfs(board,x,y-1,str,trie,output)  dfs(board,x-1,y,str,trie,output)  board[x][y] = temp;&amp;#125;
Runtime: 868 ms
This is so slow… that I even can not appear in the rumtime distribution of javascript….
Modified TrieAccording to this post: Java 15ms easiest solution. We actually don’t need the entire tree structure, we can modify the structure to speed up our answer for this problem.
Here is the code in JS:
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string[]&amp;#125; words * @return &amp;#123;string[]&amp;#125; */var findWords = function(board, words) &amp;#123;  var i,j,output=[], root = buildTrie(words);   // build the Trie with input words  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      dfs(board, i, j, root, output);    &amp;#125;  &amp;#125;  return output;&amp;#125;;var TrieNode = function()&amp;#123;  this.next = [];  // store next letter from 0 - 25 &amp;lt;= a - z  this.word = '';&amp;#125;var buildTrie = function(words)&amp;#123;  var i, root = new TrieNode(),j;  for(i = 0;i&amp;lt;words.length;i++)&amp;#123;    var node = root;    for(j = 0;j&amp;lt;words[i].length;j++)&amp;#123;      var idx = words[i][j].charCodeAt(0) - 97;   // hash index of the letter, all letters are lowercase      if(!node.next[idx])&amp;#123;        node.next[idx] = new TrieNode();      &amp;#125;      node = node.next[idx];  // move the node to the end    &amp;#125;    node.word = words[i];  // store the word in the end node  &amp;#125;  return root&amp;#125;var dfs = (board,i,j,node,output) =&amp;gt;&amp;#123;  var idx = board[i][j].charCodeAt(0) - 97;  // compute the hash index  if(board[i][j] == '#' || !node.next[idx]) return;  // exit condition: visited or not in Trie  node = node.next[idx];  if(node.word != &quot;&quot;)&amp;#123;    // successful condition    output.push(node.word);    node.word = &quot;&quot;;  // this is to remove the duplicates - genius!!  &amp;#125;  // same as before, backtracking  var temp = board[i][j];  board[i][j] = '#';  if(i &amp;gt; 0) dfs(board, i - 1, j ,node, output);   if(j &amp;gt; 0) dfs(board, i, j - 1, node, output);  if(i &amp;lt; board.length - 1) dfs(board, i + 1, j, node, output);   if(j &amp;lt; board[0].length - 1) dfs(board, i, j + 1, node, output);   board[i][j] = temp;&amp;#125;
Runtime: 204 ms
And I beat 100% of js submissions… Compared to previous answer.. it is unbelievable fast…
BTWHave you ever heard about the Word-Clock ? It is a beautiful clock using words represent the time instead of the finger and hands… It is gorgeous!!! Why I mention it ? Don’t you feel it is very similiar to what we did in this post ? Word search?
I will try to make a web version of this beautiful watch by using all these words search algorithms :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</title><link>http://taoalpha.me/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2016-01-19T23:44:09.000Z</pubDate><description>Comparison based sorting algorithmsWe have discussed all popular comparison based sorting algorithms:insertion sort and selection sort, bubble sort and merge sort, Quicksort and Heap Sort.
All these algorithms are great under most of conditions, but their lower bound is O(nlogn), they can not do better.
If for some reason, we want to achieve better than nLogn, we have to find some other ways.
About why the lower bound of all comparison based sorting algorithms is nlogn ? 
Why nlognFor any array with n elements, it has n! possible orders. Since we are using comparison based, suppose we are building a decision tree for all these possible orders, and h is the height of the decision tree and also is how many number of comparisons we need to get down to the leaves. Then we should have:
2^h &amp;gt;= n! which means: the total number of leaves should be enough to cover all possible orders of our array.
Then we would get h &amp;gt;= nlogn for approximation.
Non-Comparison based sorting algorithmsSo if we want to get over the nlogn, we have to ask help from some non-comparison based ways.
If you knew or heard about the sorting algorithms, you should know we have several famous non-comparison based sorting algorithms: counting sort, bucket sort and radix sort.
And lets talk about them today, one by one :)
Counting SortImage this situation: 
You have a deck of playing cards in random order(without jokers), and you want to sort them into the ascending order from A to K. What you gonna do ? Possibly you will count the cards and group them into 13 groups from A to K, and then combine these groups from A to K.
This is a classical counting sort. Once we are sure how many groups we have in our array or we know that the elements in our array are coming from a distribution from a to b. Then we can group them into (b - a + 1) buckets and loop over the array, put elements into proper buckets and then combine them.
Here is the code:1234567891011121314151617181920// counting sortcountingSort(list)&amp;#123;  var bucket = [],idx = 0;  // assign each element to its bucket  for(var i = 0;i&amp;lt;list.length;i++)&amp;#123;    bucket[list[i]] = bucket[list[i]] || 0    bucket[list[i]] ++  &amp;#125;  // now combine all the buckets  for(i = 0; i&amp;lt; bucket.length;i++)&amp;#123;    while(bucket[i] &amp;amp;&amp;amp; bucket[i] &amp;gt; 0)&amp;#123;      // skip empty buckets and loop over every elements in a bucket      list[idx++] = i;      bucket[i] --;    &amp;#125;  &amp;#125;  return list&amp;#125;
Bucket SortThe counting sort is amazing fast : O(n+k), k is the number of buckets we have. But it costs too much space, and if we don’t know the distribution of elements, it maybe have a lot of empty buckets which is a waste of space. 
Bucket sort is an optimization of counting sort, instead of only assigning same elements into one bucket, it will put several elements into one bucket but make sure the it is ascending from the point of buckets which means: for i,j buckets, if i &amp;lt; j, we know any elements in i will smaller than any elements in j.
By doing this, we can divide the entire array into a lot of small subarrays, and now we can just use any comparison based sorting algorithm to sort the small arrays.
Same as counting sort, if we have a wonderful distribution of our elements, it would be O(n + klogb), k is the number of buckets and b is the number of elements in one bucket, to sort the entire array. But the worst case, all elements assigned into the same buckets, it will degrade to the comparison based sorting algorithm we use, but only when you choose a really bad method to group.
1234567891011121314151617181920212223242526272829// bucketSortbucketSort(list,bucketCount)&amp;#123;  // only for numbers  var min = Math.min.apply(Math,list),  // get the min      buckets = [],      bucket_count = bucketCount || 200  // build the bucket and distribute the elements in the list  for(var i = 0;i&amp;lt;list.length;i++)&amp;#123;    // this is a simple hash function that will make sure the basic rule of bucket sort    var newIndex = Math.floor( (list[i] - min) / bucket_count );      buckets[newIndex] = buckets[newIndex] || []    buckets[newIndex].push(list[i])  &amp;#125;  // refill the elements into the list  var idx = 0  for(i = 0;i&amp;lt;buckets.length;i++)&amp;#123;    if(typeof buckets[i] !== &quot;undefined&quot;)&amp;#123;      // select those non-empty buckets      insertionSort(buckets[i]);  // use any sorting algorithm would be fine      // sort the elements in the bucket      for(var j = 0;j&amp;lt;buckets[i].length;j++)&amp;#123;        list[idx++] = buckets[i][j]      &amp;#125;    &amp;#125;  &amp;#125;  return list&amp;#125;
Radix SortCounting sort and Bucket sort are great, but they are too space-consuming and sometimes they are even slower than comparison based ones. Like if we have a really sparse array coming from 0 to n^2, then counting sort would down to O(n^2), and also if we don’t know the distribution of all elements in the array, we might choose an unefficient way to do the hash part for bucket sort, we could still get O(n^2).
Radix is here to help us out of this trouble. The idea of Radix Sort is to do digit by digit sort starting from least significant digit to most significant digit. Radix sort uses counting sort as a subroutine to sort.
For example: we have: [101, 203, 5, 87, 76, 48], using radix sort:

[101,203,5,76,87,48] &amp;lt;- last digits
[101,203,5,48,76,87] &amp;lt;- second last digits
[5,48,76,87,101,203] &amp;lt;- the first digits

Using zero when the number doesn’t have this digit.
Now lets show the code:
1234567891011121314151617181920212223242526272829303132333435363738394041// helper function to get the last nth digit of a numbervar getDigit = function(num,nth)&amp;#123;  // get last nth digit of a number  var ret = 0;  while(nth--)&amp;#123;    ret = num % 10    num = Math.floor((num - ret) / 10)  &amp;#125;  return ret&amp;#125;// radixSortradixSort(list)&amp;#123;  var max = Math.floor(Math.log10(Math.max.apply(Math,list))),        // get the length of digits of the max value in this array      digitBuckets = [],      idx = 0;  for(var i = 0;i&amp;lt;max+1;i++)&amp;#123;    // rebuild the digit buckets according to this digit    digitBuckets = []    for(var j = 0;j&amp;lt;list.length;j++)&amp;#123;      var digit = getDigit(list[j],i+1);      digitBuckets[digit] = digitBuckets[digit] || [];      digitBuckets[digit].push(list[j]);    &amp;#125;    // rebuild the list according to this digit    idx = 0    for(var t = 0; t&amp;lt; digitBuckets.length;t++)&amp;#123;      if(digitBuckets[t] &amp;amp;&amp;amp; digitBuckets[t].length &amp;gt; 0)&amp;#123;        for(j = 0;j&amp;lt;digitBuckets[t].length;j++)&amp;#123;          list[idx++] = digitBuckets[t][j];        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;  return list&amp;#125;
The time complexity for radix sort is : O(d*(n+b)), d is the number of digits the array has, b is the buckets we have, normal it is 10 for base 10 system.
Cool ha :)
BTWSince I combine radix sort with bucket sort and counting sort, so this is the last post about sorting algorithms. But for this serie, I think I will have another post talking about when we should use which algorithm.
See ya.
Oh, and also, I combine all these codes together and create a gist for it: Soting Algorithms in JS.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Quicksort and Heap Sort</title><link>http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2016-01-19T05:33:27.000Z</pubDate><description>Last time we have finished the four different sorting algorithms including : insertion sort and selection sort, bubble sort and merge sort.
Now let’s continue playing with another one or two.
Median Sort and QuicksortMedian SortSimiliar with merge sort, we still use divide and conquer, the basic approach for many problems, but what if we use some statistical information about the array that need to be sorted? Like the median of the array.
If we know the median, we can sort the array into 2 distinct subarrays of about half the size: left with all elements smaller than the median, and right with all elements bigger or equal to median. And we keep doing this for all subarrays, finally we will get a sorted array.
That gives us the MEDIAN SORT.
QuicksortMedian sort is a nice start, but it still has one problem: how to find the the median of an array? Before we atually put our efforts on solving this problem, we should consider about another problem: how about we use some other attributes instead of median? Our purpose is divide the array into two parts, we don’t need them to be the same size. By thinking this way, we may consider choose any value in the array and use this value as a separator and divide the array into subarrays.
This is quicksort, and the value we choose as a separator is called pivot.
Now let’s show the code:
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var quickSort = (list,left,right) =&amp;gt; &amp;#123;  var idx;  if(list.length &amp;lt;= 1)&amp;#123;    return list  &amp;#125;  // left and right  must be number, default value :  0 and list.length - 1  left = (left^0) !== left ? 0 : left  right = (right^0) !== right ? list.length-1 : right  // divide the array from left to right into two subarrays  // return the index of the separator  idx = partition(list,left,right)   if(left &amp;lt; idx - 1)&amp;#123;    // keep doing quicksort on left subarray until it can not be separated again    quickSort(list,left,idx - 1)  &amp;#125;  if(idx &amp;lt; right)&amp;#123;    // keep doing quicksort on right subarray until it can not be separated again    quickSort(list,idx,right)  &amp;#125;  return list&amp;#125;var partition = (list,begin,end) =&amp;gt; &amp;#123;  var pivot = Math.floor(Math.random()*(tail-head+1)+head), // random pivot index       pivot_value = list[pivot]; // pivot value  // divide into two subarrays using the pivot value with two pointers  while(begin &amp;lt;= end)&amp;#123;        // skip all 'good' ones in right    while(list[end]&amp;gt;pivot_value)&amp;#123;      end --    &amp;#125;    // skip all 'good' ones in left     while(list[begin]&amp;lt;pivot_value)&amp;#123;      begin ++    &amp;#125;    // swap the 'bad' pairs to make them 'good'    if(begin &amp;lt;= end)&amp;#123;      swap(list,begin,end)      begin ++      end --    &amp;#125;  &amp;#125;  // return the separator line  return begin&amp;#125;// swap functionvar swap = (list,first,second) =&amp;gt; &amp;#123;  var temp = list[first]  list[first] = list[second]  list[second] = temp&amp;#125;
With all comments, the code should be easy to understand.
Quicksort is famous and popular for its speed especially after linux start using it as the default sorting algorithm. Normally, if we know nothing about the distribution of our array and speed is the most important reason you consider about, then use quicksort.
In above example, we choose the pivot randomly. Normally, its good enough for using. But actually there are a lot of strategies and researches on how to choose a good pivot. Like always choose the first or last or middle, or use median, median-of-k…etc But normally, using randomly pivot will give you an average O(nlogn). If you want to learn more about these strategies, just google it :)
Heap SortBefore we go to the concept and code, we should know what is a heap:
a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.
In a max heap, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.
WikiPediaHeap (data structure) - wikipedia
Got any inspirations ? Think this way: Max heap =&amp;gt; the head of the heap is the max of the array. This is true for any max heap, so we remove the max and rebuild a heap with rest elements, we get the second largest… Yeah, you got it ?! :)
Now what we need to do is using array represent the heap which is pretty much a array tree:
for any element with index - idx:

left child : idx*2 + 1
right child: idx*2 + 2

Show me the code !!!
123456789101112131415161718192021222324252627282930313233343536373839// heapSort - here we use max heapvar heapSort = (list) =&amp;gt; &amp;#123;  buildHeap(list);  // now we have the max value  for(var i = list.length-1;i&amp;gt;=1;i--)&amp;#123;    // always put max value to the end of the current heap    // so the end of the array will always be sorted and gradually expanded to the entire array    swap(list,0,i);     // since we change the head of the heap    // so we need redo the heap to get the new max of the heap    heapify(list,0,i);   &amp;#125;  return list&amp;#125;buildHeap(list)&amp;#123;  // start from the second last level of the tree which is the parent of the last element  var mid = Math.floor(list.length / 2) - 1;  for(var i = mid;i&amp;gt;=0;i--)&amp;#123;    // make sure every node of the tree is heapify    heapify(list,i,list.length)  &amp;#125;&amp;#125;heapify(list,idx,len)&amp;#123;  // len means the number of elements current heap has  var left = 2*idx + 1,      right = 2*idx + 2,      largest;  // temp value to store the index of largest element of this tree unit  largest = left &amp;lt; len &amp;amp;&amp;amp; list[left] &amp;gt; list[idx] ? left: idx;  largest = right &amp;lt; len &amp;amp;&amp;amp; list[right] &amp;gt; list[len] ? right : largest;  // if we have a new largest, swap it and redo heapify to make sure entire heap is correct  if(largest !== idx)&amp;#123;    swap(list,largest,idx)    heapify(list,largest,len)  &amp;#125;&amp;#125;// swap function - same as before
Heap Sort is really fast, sometimes it is even faster than quicksort since it will guarantee the O(nlogn) even in the worst case. But normally in average case, the quicksort is a little faster.
BTWI believe I still have 2 posts for this serie, one will talk about the radix, and the other will be the counting and bucket sort. See ya.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Insertion Sort and Selection Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-1/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2015-10-29T05:00:00.000Z</pubDate><description>Sorting AlgorithmAs the most important and fundamental algorithm, sorting algorithm is always the best start to learn algorithm.
Among all the different sorting algorithms, we have 10 algorithms which are used a lot in practice, and I will introduce all these ten algorithms one by one. 
Today we will talk about: Selection Sort and Insertion Sort.
Selection SortSelection Sort is one of the most fundamental sort algorithms you would learn from any book about algorithm. The method and theory based on is really easy and clear:

input: a list of numbers need to be sorted
procedures:
create a new list to save the sorted elements
select the minimum element from the input list and push it into the new list, and remove it from the input list
repeat the second step until we don’t have any more elements in input list


output: the list you created to save the sorted elements

Easy, huh ? Let’s calculate the cost: the average time complexity would be n^2/2 which would be O(n^2), since we need check the input list n times with n/2 elements to check every time; and since we are using a new list to save the output, it would be O(n) space.
Can we optimize it ? Yes and no. For time complexity, we can not do any optimization since it is the theory that selection sort is using, we have nothing to do with that. But for space complexity, we can do something.
We can actually do the sort in-place which means we can sort the list within the list and return the same list as the input except it is sorted.
In order to do that, we can change the procedures to:

input: a list of numbers need to be sorted
procedures:
start from the first element, we loop over the list from it to the end of the list and select the minimum element from the input list and swap it with it(start element);
repeat it until we reach the last element of the input list(now the start element and the end element would all be the last element)


output: the input list 

By doing this way, we just need two spaces, one is used to save the index of the minimum element, another is used during the swap to save the one of the value that need to be swapped later. The space complexity would be O(1).
1234567891011121314function selectionSort(list)&amp;#123;    for(var i = 0; i &amp;lt; list.length; i++)&amp;#123;      var min = i      for(var j = i+1;j&amp;lt;list.length; j++)&amp;#123;        if(list[min]&amp;gt;list[j])&amp;#123;          min = j        &amp;#125;      &amp;#125;      var temp = list[i]      list[i] = list[min]      list[min] = temp    &amp;#125;    return list  &amp;#125;
Selection Sort is easy but not efficient, since it always costs O(n^2) even your input list is sorted when you pass it in.
Insertion SortNow we come to insertion sort which would a little more efficient than selection sort.
The theory is: consider the left part of the input list as sorted, and insert the new element into the proper position, since if one element always means it is sorted, so we always can do that by starting from the second element.
The procedures:

start from the second element(if you don’t have second element, you are done);
compare every element in the left(sorted part), if it is greater than your start element, shift it to the right by 1, if it is less than your start element, insert your start element before it;
repeat until the end of the list;

Time Complexity: O(n) in the best case(the list is sorted already), O(n^2) in the worst case, on average, it would be similiar to selection sort with O(n^2).
Space Complexity: O(1)
Lets implement it into real code:
1234567891011121314function insertionSort(list)&amp;#123;  for(var i = 1; i &amp;lt; list.length;i++)&amp;#123;    var temp = list[i]    var j = i    while(j&amp;gt;0 &amp;amp;&amp;amp; list[j-1]&amp;gt;temp)&amp;#123;      list[j] = list[j-1]      j--    &amp;#125;    list[j] = temp    // use shift instead of swap can reduce the cost of writing -- nearly 50%    // if you use swap, it will slower than selectionSort  &amp;#125;  return list&amp;#125;
Some people may be used to achieve insertion sort by using the swap too. You can, you just need compare and swap it with previous one until it reaches the right position. But the cost would be high since you will double your writes with swap.

I actually calculate the time cost in javascript, most of time, if you use swap, your insertion sort would be slower than selection sort.

Special NoteIn general, insertion sort would be faster than selection sort if you implement it in right way. But in some special cases, you may find selection sort is faster.
The different between selection sort and insertion sort:

selection sort reads the list a lot(n  (n+1) / 2, n is the length of the list) but only writes into the list a few times(= 2  (the length of your list));
insertion sort reads the list a lot too, but fewer than the selection sort(the worst case would be same with selection, best case would be equal to the length of the list), and meantime, it will write into the list much more times than selection sort(nearly the same with reading times);

So if it costs much more on reading instead of writing, you may consider choosing selection sort instead of insertion sort.
SummaryThat’s all I think you should know about selection sort and insertion sort. Next post I will discuss about bubble sort and merge sort with you. See ya!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Bubble Sort and Merge Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-2/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2015-10-29T08:00:00.000Z</pubDate><description>IntroductionBubble sort is really cool but not so useful, it seems that you will never use it… But merge sort is really cool since it is really fast.
Bubble SortSo what is bubble sort, according to wikipedia:

Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. 

The whole process of sorting is like the bigger element “bubble” to the end of the list.

Input: A list of numbers with random order
Procedures:
Start from the head of the list, and compare every two adjacent numbers and swap them if they are in wrong order;
Record whether you did any swaps or not, if no, your list has been sorted, otherwise, you need to step 1 again;


Output: A sorted list

If you like, you can do a small optimization to the procedures above: since every iteration we will make sure the bigger element will “bubble” to the end of the list, so everytime we don’t need to check the last elements(they are already in ordered), and we will reduce the length for each iteration.
Here is a nice gif from wikipedia: 
The time complexity for bubble sort would be : O(n^2) for worst case, O(n) for best case, and O(n^2) on average.
The space complexity for bubble sort would be O(1) since we only need one space used to do the swap.
Now lets do the code:
1234567891011121314151617181920// bubbleSortfunction bubbleSort(list)&amp;#123;  var swapped  var len = list.length  do&amp;#123;    swapped = false    for(var j = 0;j&amp;lt; len-1;j++)&amp;#123;      reads += 2      if(list[j]&amp;gt;list[j+1])&amp;#123;        this.swap(list,j,j+1)        swapped = true        writes += 2      &amp;#125;    &amp;#125;    len = len - 1    // since everytime we will move the largest element to the end of the list, we can reduce the number of iteration without considering the last element every iteration  &amp;#125;while(swapped)  return list&amp;#125;
Merge SortNow we met all three different kinds of sorting, all of them have a O(n^2) of time complexity on average.
Lets do something faster: Merge Sort.
Imagine you separate your list into several really small lists with only one element or zero element in each of them. Then you merge every two small lists into one sorted list, and keep doing it repeatly.(it’s easy because you are merging two sorted lists)
The whole procedures will be:

Split the list recursively;
Merge the small lists until you merge them all;

Since we always split by half, the number of small lists we will have would be log(n), and the total cost would be close to (n / 2 * log(n)) on average(since we have at least 1 element list to merge with zero one, at most n/2 elements list to merge with n/2 elements). So the time complexity would be O(nlog(n)) all the time, and the space complexity would be O(n) since we will save origin input list with n small lists.
1234567891011121314151617181920// mergeSortfunction mergeSort(list)&amp;#123;  if(list.length &amp;lt;= 1) return list  var mid = Math.floor(list.length / 2)  return merge(mergeSort(list.slice(0,mid)),mergeSort(list.slice(mid)))&amp;#125;function merge(left,right)&amp;#123;  var nl = []  var il = 0, ir = 0  while(il&amp;lt;left.length &amp;amp;&amp;amp; ir&amp;lt;right.length)&amp;#123;    if(left[il] &amp;lt; right[ir])&amp;#123;      nl.push(left[il++])    &amp;#125;else&amp;#123;      nl.push(right[ir++])    &amp;#125;    // don't use shift because shift will actually cause a lot I/Os   &amp;#125;  nl = nl.concat(left.slice(il)).concat(right.slice(ir))  return nl&amp;#125;
SummaryMerge sort is kind useful, and if we don’t have quick sort which I will talk about next post, it would be a really good choice to do sorting. And even we have quick sort, merge sort still exists in many languages as part of their default sorting algorithm.
And also there are several optimizations for merge sort, if you are interested in, you can search it on google.
That’s all for today. Good night!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Substring Questions 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-substring-questions-1/</link><category>OJ</category><tag>LeetCode,Substring</tag><pubDate>2016-01-16T06:52:31.000Z</pubDate><description>3. Longest Substring Without Repeating CharactersQuestionGiven a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.
LeetCode3. Longest Substring Without Repeating Characters
Tags: Medium, String, Two Pointers, Hash Table
AnswersHash TableAt first, my idea is use a hashmap as a view window to tract all the letters of current substring, and everytime we found the repeated one, we just move the loop pointer to the last position of this repeated character, and continue looping to the end. But apparently it will cost much more than O(n) for the average case. So then I thought I don’t need the move the loop pointer back, just need a new pointer to indicate the start of the substring, and if I do that, I couldn’t empty the view window which is the hashmap since I will lose tract of the elements between the start and i, so I keep all elements in the hashmap, just make sure every valid repeated character is appeared after the current start pointer.
Here is the code:
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  if(s.length &amp;lt;=0)&amp;#123;return 0&amp;#125;  var view = &amp;#123;&amp;#125;, // store the current substring      max = 0, // store the max length      start = 0 // store the start of the current substring  for(var i = 0;i&amp;lt;s.length;i++)&amp;#123;    if(view[s[i]] &amp;amp;&amp;amp; view[s[i]] &amp;gt; start)&amp;#123;      max = Math.max(max,i-start)      // now we have a repeated element appeared in current substring      start = view[s[i]]    &amp;#125;    view[s[i]] = i+1  &amp;#125;  // in case no repeated element in this string  max = Math.max(max,i-start)  return max&amp;#125;;
Runtime: 376 ms
DPThis method is borrow from the discussion shortest O(n) DP solution with explanations. More concise!
12345678910111213141516171819202122232425262728293031323334353637/** * Solution (DP, O(n)): *  * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &amp;lt;character, index&amp;gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap *    we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k *    let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update *    entry in hashmap to mark the latest occurency of s[i+1]. *  * Since we scan the string for only once, and the 'm' will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. *//** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  var charIndex = &amp;#123;&amp;#125;  var longest = 0, m = 0;  for (var i = 0; i &amp;lt; s.length; i++) &amp;#123;    m = Math.max((typeof charIndex[s[i]] === &quot;undefined&quot; ? -1:charIndex[s[i]]) + 1, m);    // automatically takes care of -1 case    charIndex[s[i]] = i;    longest = Math.max(longest, i - m + 1);  &amp;#125;  return longest;&amp;#125;
Runtime: 376
5. Longest Palindromic SubstringQuestionGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
LeetCode5. Longest Palindromic Substring
Tags: Medium, String
Answerstwo pointersWe need to take advantage of the features of the palindrom: xxx|xxx which is start from the separator, it is symetric.
12345678910111213141516171819202122232425262728/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s  var start = 0,end = 1;  for(var i = 0;i&amp;lt;s.length;)&amp;#123;    if(s.length - i &amp;lt;= (end-start+1)/2) break; // if the number of elements left is less than half of length of current longest palindrome, then we can break safely    var left = i, right = i; // left is from separator to left; vice versa for right    // skil the duplicate number, set all duplicate numbers as the separator of the palindrom since duplicate numbers definitely are palindrom     while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; s[right] == s[right+1]) right ++ ;    // update the i to the right next to right, no need to loop the duplicate number    i = right + 1    // now expand the left and right, try to enlarge the palindrom    while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; left &amp;gt;0 &amp;amp;&amp;amp; s[left-1] == s[right+1])&amp;#123;      // be careful about the condition in there: use &amp;lt; and &amp;gt; because maybe have 'bbb', so the s[left-1] and s[right+1] both are undefined, and they are equal...      left --      right ++    &amp;#125;    // update the longest if it is    if((right - left +1) &amp;gt; (end - start))&amp;#123;      start = left      end = right + 1    &amp;#125;  &amp;#125;  return s.slice(start,end)&amp;#125;;
Runtime: 164 ms
Brute Force CheckBasic idea is loop over entire string, and everytime we loop to a new character, we check whether it would produce new palindrome of (current length + 1) or (current length + 2). From this post
123456789101112131415161718192021222324252627/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s;  var subs = '', currentLength = 1;  for(var i = 1;i&amp;lt;s.length;i++)&amp;#123;    if(isPalindrome(s,i-currentLength-1,i))&amp;#123;      //       subs = s.slice(i-currentLength-1,i+1)      currentLength += 2    &amp;#125;else if(isPalindrome(s,i-currentLength,i))&amp;#123;      subs = s.slice(i-currentLength,i+1)      currentLength += 1    &amp;#125;  &amp;#125;  return subs&amp;#125;var isPalindrome(s,begin,end) =&amp;gt; &amp;#123;  if(begin&amp;lt;0) return false;  while(begin &amp;lt; end)&amp;#123;    if(s[begin++] !== s[end--]) return false;  &amp;#125;  return true&amp;#125;
Runtime: 188 ms
And the detail explanations:

Example: “xxxbcbxxxxxa”, (x is random character, not all x are equal) now we are dealing with the last character ‘a’. The current longest palindrome is “bcb” with length 3.

check “xxxxa” so if it is palindrome we could get a new palindrome of length 5.
check “xxxa” so if it is palindrome we could get a new palindrome of length 4.
do NOT check “xxa” or any shorter string since the length of the new string is no bigger than current longest length.
do NOT check “xxxxxa” or any longer string because if “xxxxxa” is palindrome then “xxxx” got  from cutting off the head and tail is also palindrom. It has length &amp;gt; 3 which is impossible.’


Really smart!!!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Numbers 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-numbers-1/</link><category>OJ</category><tag>LeetCode,Numbers</tag><pubDate>2016-01-17T02:22:20.000Z</pubDate><description>2. Add Two NumbersQuestionYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)Output: 7 -&amp;gt; 0 -&amp;gt; 8
LeetCode2. Add Two Numbers
Tags: Medium, Linked List, Math
AnswersCommon parts firstThe idea is to add the common parts first and store the carry number produced every round a addition.
Then deal with the remain, just be careful about the carry.
Then if we still have a carry number, create a new node and add it to our result.
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; l1 * @param &amp;#123;ListNode&amp;#125; l2 * @return &amp;#123;ListNode&amp;#125; */var addTwoNumbers = function(l1, l2) &amp;#123;  var head = new ListNode(-1),      cur = head,      carry = 0;  while(l1 &amp;amp;&amp;amp; l2)&amp;#123;    var nodeVal = l1.val + l2.val + carry,node = new ListNode(0);    if(nodeVal &amp;gt;= 10)&amp;#123;      carry = 1      node.val = nodeVal % 10    &amp;#125;else&amp;#123;      carry = 0      node.val = nodeVal    &amp;#125;    cur.next = node    cur = node    l1 = l1.next    l2 = l2.next  &amp;#125;  // deal with the remain  var remain = l1 || l2  while(remain)&amp;#123;    if(remain.val + carry &amp;gt;= 10)&amp;#123;      remain.val = (remain.val + carry) % 10      carry = 1    &amp;#125;else&amp;#123;      remain.val += carry      carry = 0    &amp;#125;    cur.next = remain    cur = cur.next    remain = remain.next  &amp;#125;  // if no remain  if(carry&amp;gt;0)&amp;#123;      var temp = new ListNode(carry)      cur.next = temp  &amp;#125;  return head.next&amp;#125;;
Runtime : 304ms
All in one loopActually you can find that the main logic of our two while loops are the same, we can combine them:
123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; l1 * @param &amp;#123;ListNode&amp;#125; l2 * @return &amp;#123;ListNode&amp;#125; */var addTwoNumbers = function(l1, l2) &amp;#123;  var head = new ListNode(-1),      cur = head,      carry = 0;  while(l1 || l2)&amp;#123;    var l1val = (l1 &amp;amp;&amp;amp; l1.val) || 0    var l2val = (l2 &amp;amp;&amp;amp; l2.val) || 0    var nodeVal = l1val + l2val + carry,node = new ListNode(0);    if(nodeVal &amp;gt;= 10)&amp;#123;      carry = 1      node.val = nodeVal % 10    &amp;#125;else&amp;#123;      carry = 0      node.val = nodeVal    &amp;#125;    cur.next = node    cur = node    l1 = (l1 &amp;amp;&amp;amp; l1.next) || null    l2 = (l2 &amp;amp;&amp;amp; l2.next) || null  &amp;#125;  // if no remain  if(carry&amp;gt;0)&amp;#123;      var temp = new ListNode(carry)      cur.next = temp  &amp;#125;  return head.next&amp;#125;;
Runtime: 320ms
The two methods should be at the same time complexity.
9. Palindrome NumberQuestionDetermine whether an integer is a palindrome. Do this without extra space.
LeetCode9. Palindrome Number
Tags: Easy,Math
AnswersCan not understand what without extra space means… but we can figure out some O(1) space methods…
Head and Tail Comparator1234567891011121314/** * @param &amp;#123;number&amp;#125; x * @return &amp;#123;boolean&amp;#125; */var isPalindrome = function(x) &amp;#123;  if(x&amp;lt;0)&amp;#123;return false&amp;#125;  var numDigits = Math.floor(Math.log10(x)) + 1,i = 1;  while(i&amp;lt;=numDigits/2)&amp;#123;    if( (Math.floor(x % Math.pow(10,numDigits - i+1) / Math.pow(10,numDigits-i))) !=         (Math.floor(x % Math.pow(10,i) / Math.pow(10,i-1))) )&amp;#123; return false &amp;#125;    i += 1  &amp;#125;  return true&amp;#125;;
Runtime: 768 ms
MathIt is not a pure math problem, but if you know math well, you can figure out some way like this:

reduce the x into half
store the reduced half into another number
compair the two

12345678910111213/** * @param &amp;#123;number&amp;#125; x * @return &amp;#123;boolean&amp;#125; */var isPalindrome = function(x) &amp;#123;  if(x&amp;lt;0 || (x !== 0 &amp;amp;&amp;amp; x % 10 == 0)) return false;  var rev = 0; // reverse  while(x&amp;gt;rev)&amp;#123;    rev = rev * 10 + x % 10    x = Math.floor(x / 10)  &amp;#125;  return (x == rev || x == Math.floor(rev/10))&amp;#125;
Runtime: 684 ms
17. Letter Combinations of a Phone NumberQuestionGiven a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below.Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want.
LeetCode17. Letter Combinations of a Phone Number
Tags: Medium, String, Backtracking
AnswersDFS - recursion123456789101112131415161718192021222324/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  // mapper that store all number-letters  var output = []  helper(digits,[],output,mapper)  return output&amp;#125;var helper = (digits,result,output,mapper) =&amp;gt; &amp;#123;  if(digits.length == 0)&amp;#123;    output.push(result.join(''));    return  &amp;#125;  for(var i = 0;i&amp;lt;mapper[digits[0]].length;i++)&amp;#123;    result.push(mapper[digits[0]][i])    helper(digits.slice(1),result,output,mapper)    result.pop()  &amp;#125;&amp;#125;
Runtime: 152 ms
DFS - iteratorSame as before, just use iterator instead of recursion
1234567891011121314151617181920/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  var output = [&quot;&quot;]  for(var i = 0;i&amp;lt;digits.length;i++)&amp;#123;    var x = digits[i]    var temp = []    for(var j = 0;j&amp;lt;mapper[x].length;j++)&amp;#123;      for(var t = 0;t&amp;lt;output.length;t++)&amp;#123;        temp.push(output[t]+mapper[x][j])      &amp;#125;    &amp;#125;    output = temp  &amp;#125;  return output&amp;#125;
Runtime: 156 ms
That’s weird… iterator should be faster than recursion… maybe just so few test cases can not test the real difference between these two …
BFS - iteratorIf we consider previous one as a DFS method, then we can use BFS solve it too. Basic idea is the length of each the combination in our final output should be equal to the length of digits. And for every iteration, we use a new digit, and we also need to add every letters this digit represents to every existed combinations we have.
For example: ‘23’
initial =&amp;gt; [‘’]‘2’ =&amp;gt; [‘a’,’b’,’c’]// now add each element of ‘def’ to each of these three string‘3’ =&amp;gt; [‘cd’,’ce’,’cf’,’bd’,’be’,’bf’,’ad’,’ae’,’af’]
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  var output = [&quot;&quot;]  for(var i = 0;i&amp;lt;digits.length;i++)&amp;#123;    var x = digits[i]    while(output[output.length-1].length == i)&amp;#123;      // the length of every combination in the output should be equal to the the number of digits we used      var t = output.pop()      for(var j = 0;j&amp;lt;mapper[x].length;j++)&amp;#123;        output.unshift(t+mapper[x][j])        // need to use unshift since we need add the new letter to every existed element in the output      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
Runtime: 140 ms
That’s it ^_^
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Blur on Background</title><link>http://taoalpha.me/blog/2015/12/31/tech-blur-on-background/</link><category>tech</category><tag>Blur,CSS3</tag><pubDate>2015-12-31T08:09:10.000Z</pubDate><description>Today I finally made my first angularJS app which is a simple todo app connected with my First nodejs cli tool: baby. They share the same data set, so you can think it as the UI for baby todo part (I will build the UI for other nice features, one by one).
I really like the interface of the Papaly, especially the speed dial dashboard !! So I also use a large image and the crystal blur block on my design, here I just want to share something with you :)
BlurBlur is quite popular in Web Design, you can see them all the time. But how we do that from the point of coding part ? Before CSS3 introduced the filter, people just modify the images manually and make them blur before actually use them in the design, and now we have CSS3, we can just use filter.
We all know make a image blur is pretty simple, but how we make part of image blur, and even more, how we make part of image blur be dynamic ? This is what I gonna talk about today :)
Without CSS3Let’s do it old fashion first. You want create a box within which all background image should be blur, and also the box may move to any place or even can be moved by users. How to do that? Quite simple, we can use two images, one is normal, the other is blur one. 
Then what you should know is background-attachment which adds the magic.
12345678910111213141516171819202122232425262728293031323334353637383940/* background-attachment can specify the position of the background image * fixed : the background is fixed with regard to the viewport, so it won't move with the element * background-attachment: fixed; * background-size:100%; * keep size 100% to fit the viewprot */html,body&amp;#123;  width:100%;  height:100%;  margin:0px;&amp;#125;.imgBlur&amp;#123;  width:100%;  height:100%;  margin:auto;  background-image:url(&quot;http://www166.lunapic.com/editor/premade/o-blur.gif&quot;);// image without blur  background-size:100%;&amp;#125;div.blurBox&amp;#123;  width:50%;  margin:auto;  height:200px;  color:white;  padding:30px;  text-align:center;  display:table;&amp;#125;div.blurBox.withoutcss3&amp;#123;  background-attachment:fixed;  background-size:100%;  background-image:url(http://www166.lunapic.com/editor/premade/blur.gif);// image with blur   display:none;&amp;#125;.blurBox span&amp;#123;  display:table-cell;  vertical-align:middle;&amp;#125;
With CSS3With CSS3, we don’t need the second image, we can just use blur.
123456789101112131415161718192021/* z-index is to make sure the content of the box won't be blur */div.blurBox.withcss3&amp;#123;  z-index:1;&amp;#125;div.blurBox.withcss3:before&amp;#123;  width:100%;  display:block;  content:&quot; &quot;;  height:100%;  background-image:url(http://www166.lunapic.com/editor/premade/o-blur.gif);  // now we don't need blur image  background-attachment:fixed;  // still need this since we need use the blur on the image  position: absolute;  background-size:100%;   -webkit-filter: blur(3px);  filter:blur(3px);  z-index:-1;&amp;#125;
Here is the demo I made with codepen:
See the Pen LGbajd by taoalpha (@taoalpha) on CodePen.


Advance SkillsPretty cool ha! Combine with before and after and other cool stuffs,  you can achieve a lot amazing effects, even this one : Depth of field effect with SVG filters
See the Pen Depth of field effect with SVG filters by Vaughan Curd (@vcurd) on CodePen.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Add a reading progressbar to your blog</title><link>http://taoalpha.me/blog/2016/01/16/tech-add-a-reading-progressbar-to-your-blog/</link><category>tech</category><tag>JS,progressbar</tag><pubDate>2016-01-16T21:37:42.000Z</pubDate><description>Yesterday, I added airbnb blog to my subscriptions, and found an interesting feature on this blog: when you scroll down, there will be a progressbar on the top of the page showing the progress of your reading on this post. So I just added it to my blog :)
Actually the logic is pretty simple, you calculate the distance you have scroll down, and then divided by the height of your post area, fixed with some margins and offset, added some styles and html, you will get your own reading progressbar :) I don’t know whether airbnb using this method or not since I didn’t look their code…
1234567891011121314151617181920212223// with jQuery( () =&amp;gt; &amp;#123;  $(window).scroll( () =&amp;gt; &amp;#123;    // listen to the scroll event    if(window.scrollY &amp;gt; 220)&amp;#123;      // the distance between the top of the document and start of your post area, only show when you actually start reading :)      var percentage = Math.ceil( ( (window.scrollY - 200 + $(window).height()) / $('section.entry').height() )*100 )      // calculate the percentage of reading, here I minus the distance at the top but add the height of your screen to make sure it will hit 100 when scroll down to the bottom      if(percentage&amp;lt;=100)&amp;#123;        // show and update the progressbar        $('div#progressbar').fadeIn(300).find('span.text').text(percentage+&quot;% READ&quot;)        $('div#progressbar').fadeIn(300).find('span.bg').css(&amp;#123;width:percentage+&quot;%&quot;&amp;#125;)      &amp;#125;      // hide it when read 100%      if(percentage &amp;gt;= 100)&amp;#123;        $('div#progressbar').fadeOut(300)      &amp;#125;    &amp;#125;else&amp;#123;      // hide if you scroll up to the top      $('div#progressbar').fadeOut(300)    &amp;#125;  &amp;#125;)&amp;#125;)()
And then you just need a html snippet like this on your post page and add your own styles for them:
1div#progressbar&amp;#10;  span.bg&amp;#10;  span.text
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode NSum Problem</title><link>http://taoalpha.me/blog/2016/01/13/oj-oj-leetcode-nsum/</link><category>OJ</category><tag>HashTable,LeetCode</tag><pubDate>2016-01-14T01:19:20.000Z</pubDate><description>1. Two SumQuestionGiven an array of integers, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution.
Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2
LeetCode1. 2Sum
Tags: Array, Hash Table
AnswersIndexOfBefore we think about hashtable, the more strightforward idea is that we subtract the current number from the target and then check whether the result is in the rest of the list or not.
12345678910111213/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var secondIndexOffset = nums.slice(i+1,nums.length).indexOf(target - nums[i])    if(secondIndexOffset&amp;gt;-1)&amp;#123;      return [i+1,i+secondIndexOffset+2]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 456 ms
Or we use while to save some time:
123456789101112131415/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        return [i+1,j+1]      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 336 ms
hashtableThe previous answer can solve the problem but it is too slow, it is O(n^2) way too slow. We need to speed it up.
Since we can assume each input would have exactly one solution which means that there should not have duplicate number in the nums or the duplicate numbers wouldn’t affect the result, so we can use a hashtable store all the numbers and the index of them to speed up the process.
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var mapper = &amp;#123;&amp;#125;  for(var i =0;i&amp;lt;nums.length;i++)&amp;#123;    mapper[nums[i]] = i+1  &amp;#125;  for(i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var remain = target - nums[i]    if(mapper[remain] &amp;amp;&amp;amp; mapper[remain] -1 !== i)&amp;#123;      return [i+1,mapper[remain]]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 140 ms
Personal Follow Upif we can not assume that each input would have exactly one solution, then how to solve it?
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = []  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(i,j)      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
If we want get all possible and no duplicate combinations(using values instead of indices) of two sum:
1234567891011121314151617181920212223242526272829/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var i = 0, j = nums.length-1  var output = []  nums.sort( (a,b)=&amp;gt; a - b)  while(i&amp;lt;j)&amp;#123;    if(nums[i]+nums[j] == target)&amp;#123;      output.push([nums[i],nums[j]])      i ++      j --      // remove the duplicate values      while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;        i++      &amp;#125;      while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;        j--      &amp;#125;    &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;      j --     &amp;#125;else&amp;#123;      i ++    &amp;#125;  &amp;#125;  return output&amp;#125;
Use hash table:
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = [],nnums = [],amapper = &amp;#123;&amp;#125;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    if(!amapper[nums[i]])&amp;#123;      nnums.push(nums[i])      amapper[nums[i]] = 1    &amp;#125;else&amp;#123;      amapper[nums[i]] ++    &amp;#125;  &amp;#125;  // build the hash of all elements and remove the duplicates  // store all possible combinations  for(var i = 0;i&amp;lt;nnums.length;i++)&amp;#123;    for(var j = i+1;j&amp;lt;nnums.length;j++)&amp;#123;      var sum = nnums[i]+nnums[j]      if(sum == target)&amp;#123;        output.push([nnums[i],nnums[j]])      &amp;#125;    &amp;#125;  &amp;#125;  // consider about the special case that two sub elements are same  if(amapper[target/2] &amp;gt;=2)&amp;#123;output.push([target/2,target/2])&amp;#125;  return output&amp;#125;
Compared with the two pointers method, this one would be a little slower - test with replacing this one with previous one in the findNSum function below.
18. 4SumQuestionGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d). The solution set must not contain duplicate quadruplets.
For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
LeetCode18. 4Sum
Tags: Array, Hash Table, Two Pointers, Medium
Answersreduce to 2Sum123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[][]&amp;#125; */var fourSum = function(nums, target) &amp;#123;  // sort  nums.sort( (a,b)=&amp;gt; a - b)  var output = []  findNSum(nums,target,4,[],output)  return output&amp;#125;;var findNSum = (nums,target,N,result,output)=&amp;gt;&amp;#123;  // base exit case  if(nums.length &amp;lt; N || N &amp;lt; 2) return  // 2Sum like before but don't need to sort the list again  if(N==2)&amp;#123;    // can replace below with any one of these 2Sum ways    var i = 0, j = nums.length-1    while(i&amp;lt;j)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(result.concat([nums[i],nums[j]]))        i ++        j --        // remove the duplicate values        while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;          i++        &amp;#125;        while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;          j--        &amp;#125;      &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;        j --       &amp;#125;else&amp;#123;        i ++      &amp;#125;    &amp;#125;  &amp;#125;else&amp;#123;    for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;      if(i==0 || (i&amp;gt;0 &amp;amp;&amp;amp; nums[i-1] != nums[i]))&amp;#123;        // recursively call findNSum        findNSum(nums.slice(i+1,nums.length), target-nums[i],N-1,result.concat([nums[i]]),output)      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 328 ms
Since the nums is sorted, we can use pruning during the for loop to save a lot of time:
12// add this within the for loop before the recursionif(nums[i]*N &amp;gt; target || nums[nums.length-1]*N &amp;lt; target) break
Runtime: 228
Using Hash TableThink about using the hashtable store all value of two pairs, and then treat it like a twoSum problem, but will use a lot space.
SummaryAll NSum problems can be solved by the same way.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Dynamic scheduling crawler for FeedPusher</title><link>http://taoalpha.me/blog/2016/01/12/tech-dynamic-scheduling-crawler-for-feedpusher/</link><category>tech</category><tag>Crawler,FeedPusher,NodeJS</tag><pubDate>2016-01-12T08:12:44.000Z</pubDate><description>As I promised, I have been working on refactoring the feedpusher with pure JS/nodeJS from last week. Now I have set up the basic database struture and spider which has already been running for one week with 80 sites and 8k feeds stored into my mongodb on raspberry pi.
Today, I jsut set up a new process to crawl the updates which I called dynamic scheduling which means now the spider can decide whether this site needs to be recrawled this time or not by itself. Why? Most important reason is that as the number of sites goes bigger, the time it crawles all sites is longer, and also crawl every site everytime is not a good way.
Now I will explain how I do that with nodeJS.
TheoryOur purpose is let the spider decide when to crawl a specific website/rss link, or in another word, everytime the spider runs, it needs to decide which website should be recrawled this time.
What data I haveNow I have and I can store some data into my database that may be good for this purpose, but we want to use as few as possible, so I decide to use these two attributes:

lastCrawled: time I last crawled this website;
updateDuration: the duration between two continuous crawl of this site;

Dynamic SchedulingThe lastCrawled is pretty simple and we don’t have a lot things can do with it. But the updateDuration is the core of the dynamic scheduling, since we can increase it and tell the spider that this site needs a longer duration before next crawling and vice versa.
So the basic idea is:
The larger the updateDuration is, the longer the website get recrawled.
Rules
When to crawl: if current time minus the time lastCrawled is longer than the updateDuration, then the website needs to be recrawled;
Motivate: if this round of crawling got any updates(new feeds) of this website, then we decrease the updateDuration of this website which is like motivating this website because of the updates;
Penalize: if this round of crawling got no updates(new feeds) of this website, then we increase the updateDuration of this website which is like penalizing this website because of the later update than expected;

ResultsBased on these simple rules, the updateDuration of one site would be dynamic changing and will reflect the frequency of a website updates in some level.
CodingThe coding part is pretty stright forward, but since the spider need get a lot of data from the mongodb, so you might need a lot promises to make sure the order of different processes is under your control.
I will put the Pseudocode here, if you are interested in the real code, you can check my feedpusher code refactoring repo :)
PseudocodeThis is not a real pseudocode… but I believe you can bare with that :)
1234567891011121314151617181920212223242526272829303132333435363738394041424344// feed is the object of my core class I used for this spiderfeed.db.open((err, db) =&amp;gt;&amp;#123;  // connect with database  var allSites = [] // store all sites we crawled this time in order to update the lastCrawled and updateDuration later  // find all sites from the database  feed.findAllSites().then((data) =&amp;gt; &amp;#123;    var curTime = moment()    // Need use promise to make sure all finished before you update the lastCrawled and updateDuration    return Promise.all(data.filter( (v) =&amp;gt; &amp;#123;      // filter all sites that the time from lastCrawled has passed the updateDuration      return (((curTime - moment(v.lastCrawled)) / 3600 / 1000) &amp;gt; v.updateDuration)    &amp;#125;)    .map( (v) =&amp;gt;&amp;#123;      // crawl and store each feedUrl which is the link of the rss      allSites.push(v.feedUrl)      return feed.crawler(v.feedUrl)    &amp;#125;) )  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    // update the lastFCrawled for all sites    return feed.updateCrawled(allSites)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at crawler&quot;)    console.log(reason)    db.close()  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    console.log(feed.stats)    feed.updateDuration(allSites).then( () =&amp;gt; &amp;#123;      // Now update the updateDuration for all sites      db.close()    &amp;#125;,(reason)=&amp;gt;&amp;#123;      console.log(&quot;Broken at updatedDuration&quot;)      console.log(reason)      db.close()    &amp;#125;)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at updatedCrawled&quot;)    console.log(reason)    db.close()  &amp;#125;)&amp;#125;)
Yup! currently it works pretty good! :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>ES6 Quiz With Answer</title><link>http://taoalpha.me/blog/2016/01/11/tech-es6-quiz-with-answer/</link><category>tech</category><tag>ES6,JS,Quiz</tag><pubDate>2016-01-11T08:15:24.000Z</pubDate><description>Origin Post
@kangax’s ES6 quiz, explained@kangax created a new interesting quiz, this time devoted to ES6 (aka ES2015). I found this quiz very interesting and quite hard (made myself 3 mistakes on first pass).
Here we go with the explanations:
Question 1:123456(function(x, f = () =&amp;gt; x) &amp;#123;  var x;  var y = x;  x = 2;  return [x, y, f()];&amp;#125;)(1)

[2, 1, 1]
[2, undefined, 1]
[2, 1, 2]
[2, undefined, 2]

The most complex question for me in this quiz. I didn’t get it right initially until read the spec and clarified with @kangax. First I answered [2, undefined, 1], which is “almost correct”, except one subtle thing. The correct answer here is the first one, [2, 1, 1], and let’s see why.
As we know, parameters create extra scope in case of using default values.
Parameter f is always the function (the default value, since it’s not passed), and it captures x exactly from the parameters scope, that is 1.
Local variable x shadows the parameter with the same name, var x;. It’s hoisted, and is assigned default value… undefined? Yes, usually it would be assigned value undefined, but not in this case, and this is the subtle thing we mentioned. If there is a parameter with the same name, then the local binding is initialized not with undefined, but with the value (including default) of that parameter, that is 1.
So the variable y gets the value 1 as well, var y = x;.
Next assignment to local variable x happens, x = 2, and it gets value 2.
By the time of the return, we have x is 2, y is 1, and f() is also 1. It’s also a tricky part: since f was created in the scope of parameters, its x refers to the parameter x, which is still 1.
And the final return value is: [2, 1, 1].

Question 2:123456(function() &amp;#123;  return [    (() =&amp;gt; this.x).bind(&amp;#123; x: 'inner' &amp;#125;)(),    (() =&amp;gt; this.x)()  ]&amp;#125;).call(&amp;#123; x: 'outer' &amp;#125;);

[‘inner’, ‘outer’]
[‘outer’, ‘outer’]
[undefined, undefined]
Error

Arrow functions have lexical this value. This means, they inherit this value from the context they are defined. And later it stays unchangeable, even if explicitly bound or called in a different context.
In this case both arrow functions are created within the context of {x: &amp;#39;outer&amp;#39;}, and .bind({ x: &amp;#39;inner&amp;#39; }) applied on the first function doesn’t make difference.
So the answer is: [&amp;#39;outer&amp;#39;, &amp;#39;outer&amp;#39;].

Question 3:1let x, &amp;#123; x: y = 1 &amp;#125; = &amp;#123; x &amp;#125;; y;

undefined
1
{ x: 1 }
Error

Variable y will eventually have value 1 since:
First, let x defines x with the value undefined.
Then, destructuring assignment { x: y = 1 } = { x } on the right hand side has a short notation for an object literal: the {x} is equivalent to {x: x}, that is an object {x: undefined}.
Once it’s destructured the pattern { x: y = 1 }, we extract variable y, that corresponds to the property x. However, since property x is undefined, the default value 1 is assigned to it.
So the answer is: 1.

Question 4:1234567(function() &amp;#123;  let f = this ? class g &amp;#123; &amp;#125; : class h &amp;#123; &amp;#125;;  return [    typeof f,    typeof h  ];&amp;#125;)();

[“function”, “undefined”]
[“function”, “function”]
[“undefined”, “undefined”]
Error

This IIFE is executed with no explicit this value. In ES6 it means it will be undefined (the same as in strict mode in ES5).
So the variable f is bound to the class h {}. Its typeof is a &amp;quot;function&amp;quot;, since classes in ES6 is a syntactic sugar on top of the constructor functions.
However, the class h {} itself is created in the expression position, that means its name h is not added to the environment. And testing the typeof h should return &amp;quot;undefined&amp;quot;.
And the answer is: [&amp;quot;function&amp;quot;, &amp;quot;undefined&amp;quot;].

Question 5:1(typeof (new (class &amp;#123; class () &amp;#123;&amp;#125; &amp;#125;)))

“function”
“object”
“undefined”
Error

This is an obfuscated syntax playing, but let’s try to figure it out :)
First of all, since ES5 era, keywords are allowed as property names. So on a simple object example, it can look like:
123let foo = &amp;#123;  class: function() &amp;#123;&amp;#125;&amp;#125;;
And ES6 standardized concise method definitions, that allows dropping the : function part, so we get the:
123let foo = &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
This is exactly what corresponds to the inner class () {} – it’s a method inside a class.
The class itself is anonymous, so we can rewrite the example:
12345let c = class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;new c();
Now, instead of assigning to the varialbe c, we can instantiate it directly:
123new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
The result of a default class is always a simple object. And its typeof should return &amp;quot;object&amp;quot;:
123typeof (new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;);
And the answer is: &amp;quot;object&amp;quot;.

Quetion 6:1typeof (new (class F extends (String, Array) &amp;#123; &amp;#125;)).substring

“function”
“object”
“undefined”
Error

Here we have a similar obfuscated example (but we already figured out this inlined typeof, new, and class thing above ;)), though the interesting part is the value of the extends clause. It’s the: (String, Array).
The grouping operator always returns its last argument, so the (String, Array) is actually just Array.
So what we’ve got here is:
12345class F extends Array &amp;#123;&amp;#125;let f = new F();typeof f.substring; // &quot;undefined&quot;
Since array instances do not have substring method, and our extended class F didn’t provide it either, the answer is &amp;quot;undefined&amp;quot;.

Question 7:1[...[...'...']].length

1
3
6
Error

Here we deal with the spread operator. It allows to spread all the elements to the array. It can work with any iterable object.
Strings are iterable, meaning that we can iterate over their chars (in this case char by char). So the inner [...&amp;#39;...&amp;#39;] results to an array: [&amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;]:
12345let s = '...';let a = [...s];console.log(a); // ['.', '.', '.']
Array are iterable as well. So the outer spread is applied on our new array:
1234let result = [...a];console.log(result); // ['.', '.', '.']console.log(result.length); // 3
As we can see spreading the array happens element by element, so the resulting array just copied all the elements, and looks the same – with just 3 string dots.
And the answer is: 3.

Question 8:1typeof (function* f() &amp;#123; yield f &amp;#125;)().next().next()

“function”
“generator”
“object”
Error

In this example we encounter a generator function. When executed, they return a generator object:
1let g = (function* f() &amp;#123; yield f &amp;#125;)();
Generator objects have next method, that returns the next value at the yield position. The returned value has iterator protocol format:
1&amp;#123;value: &amp;#60;returned value&amp;#62;, done: boolean&amp;#125;;
So on first next() we get:
1g.next(); // &amp;#123;value: f, done: false&amp;#125;
As we see, the returned value itself doesn’t have method next(), so trying to call it as a chain would result to an error:
1g.next().next(); // error
Notice though, that we could normally call it as:
12g.next(); // &amp;#123;value: f, done: true&amp;#125;g.next(); // &amp;#123;value: undefined, done: true&amp;#125;
So the answer is: Error.

Question 9:1typeof (new class f() &amp;#123; [f]() &amp;#123; &amp;#125;, f: &amp;#123; &amp;#125; &amp;#125;)[`$&amp;#123;f&amp;#125;`]

“function”
“undefined”
“object”
Error

The obfuscated example results to a Syntax Error since class name f() is not correct.
The answer is Error.

Question 10:1typeof `$&amp;#123;&amp;#123;Object&amp;#125;&amp;#125;`.prototype

“function”
“undefined”
“object”
Error

This one is very tricky :)
First, we deal with template strings.
They are capable to render values of variables directly in the strings:
123let x = 10;console.log(`X is $&amp;#123;x&amp;#125;`); // &quot;X is 10&quot;
However, in the example we have something that looks a bit strange: it’s not ${Object} how it “should be”, but the $.
No, it’s not another special syntax of template strings, it’s still a value inside ${}, and the value is {Object}.
What is {Object}? Well, as we mentioned earlier above, ES6 has short notation for object literals, so in fact it’s just the: {Object: Object} – a simple object with the property named &amp;quot;Object&amp;quot;, and the value Object (the built-in Object constructor).
Now it’s becoming more clear:
1234let x = &amp;#123;Object: Object&amp;#125;;let s = `$&amp;#123;x&amp;#125;`;console.log(s); // &quot;[object Object]&quot;
See what’s happened? The ${x} is roughly equivalent to the:
12345'' + x;// or the same:x.toString(); // &quot;[object Object]&quot;
Now, the string &amp;quot;[object Object]&amp;quot; obviously doesn’t have property prototype:
123&quot;[object Object]&quot;.prototype; // undefinedtypeof &quot;[object Object]&quot;.prototype; // &quot;undefined&quot;
So the answer is: &amp;quot;undefined&amp;quot;.

Question 11:1((...x, xs)=&amp;gt;x)(1,2,3)

1
3
[1,2,3]
Error

This one is the simplest. Rest parameters can appear only at the last postion. In this case ...x goes as a first argument of an IIFE arrow function, so results to a Parse Error.
And the answer is: Error.

Question 12:12345let arr = [ ];for (let &amp;#123; x = 2, y &amp;#125; of [&amp;#123; x: 1 &amp;#125;, 2, &amp;#123; y &amp;#125;]) &amp;#123;  arr.push(x, y);&amp;#125;arr;u

[2, { x: 1 }, 2, 2, 2, { y }]
[{ x: 1 }, 2, { y }]
[1, undefined, 2, undefined, 2, undefined]
Error

Several topics combined here: destructuring assignment, default values, and for-of loop.
However, we can quickly identify it’s an error, because of two one thing:
EDIT 1: @fkling42 pointed out that the variable y is in the environment, but is not initialized yet (being under TDZ – Temportal Dead Zone), and that’s the reason why it cannot be accessed
EDIT 2: @getify pointed out, that value 2 actually normally passes RequireObjectCoercible check, and hence there would be no error in destructuring let { x = 2, y } = 2;.

{ y } is a short notation of {y: y} and will fail, since variable y doesn’t exist in the scope; The variable y is in the scope, but is under TDZ, so cannot be accessed
(we wouldn’t reach this, because of the frist error, but): trying to destructure 2 will fail too will not fail, since to object coercion will be normally applied.

So the answer is: Error.

Question 13:123456(function() &amp;#123;  if (false) &amp;#123;    let f = &amp;#123; g() =&amp;gt; 1 &amp;#125;;  &amp;#125;  return typeof f;&amp;#125;)();

“function”
“undefined”
“object”
Error

This example is only on attention, since it’s a syntax error: the arrow function =&amp;gt; cannot be defined in this way, since we have a an object with the g (consice) method.
And the answer is: Error.

ConclusionI like such tricky quiz questions, it’s always fun to track the runtime semantics and parsing process manually. Of course, most of the things here are far from practical production code, and are interesting mostly from the theoretical viewpoint. Still I found it enjoyable.
I’ll be glad to discuss all the questions in the comments.
Good luck with ES6 ;)
Written by: Dmitry Soshnikov
http://dmitrysoshnikov.com
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Scalable and Modular Architecture for CSS</title><link>http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/</link><category>read</category><tag>CSS,Modularity,SMACSS</tag><pubDate>2016-01-11T00:13:50.000Z</pubDate><description>Modularity of Web DevAs your project becomes more complex, its more difficult to maintain the code, no matter what kind of language you are using. That’s why we use OOP for most of the projects, by doing that, it saves you a lot of time and energy. Since web development becomes more popular, more and more people start focusing on this area and come up with some fantastic ideas about how to apply modularity or OOP on web development.
We all know that a basic website would contains three basic parts: HTML/CSS/JS. HTML is in charge of the struture, the CSS will focus on the appearance, and JS will give your website more animation(now css can do that too) and interaction. Among all these three parts, HTML is the easiest one, there is not so many things to talk about except the semantic tag, H5..etc, if you want to improve the modularity, most times HTML is not what you care most. Instead, CSS and JS are your primary concern.
Scalable and Modular Architecture for CSS is a nice book focus on applying modularity to CSS, and here is the notes I wrote down after I read it. About JS, we will talk about it later :) You can start with a nice and good coding style.
Reading NotesCategories of RulesJonathan Snook groups CSS rules into five types of categories:

Base: Base rules are the defaults. They are almost exclusively single ele- ment selectors but it could include attribute selectors, pseudo-class selectors, child selectors or sibling selectors. Essentially, a base style says that wherever this element is on the page, it should look like this;
You can use some reset frameworks out there, just be sure you know everything it does before you actually put it in your project;


Layout: Layout rules divide the page into sections. Layouts hold one or more modules together;
Generally, a Layout style only has a single selector: a single ID or class name;
Sometimes, you may have different layouts base on different settings like user preference, then you can use more than one selectors;


Modules: Modules are the reusable, modular parts of our design. They are the callouts, the sidebar sections, the product lists and so on;
Each Module should be designed to exist as a standalone component;
Avoid using IDs and ele- ment selectors, sticking only to class names;
Only include a selector that includes semantics. A span or div holds none. A heading has some. A class defined on an element has plenty;
If you do wish to use an element selector, it should be within one level of a class selector;


State rules: State rules are ways to describe how our modules or layouts will look when in a particular state. Is it hidden or expanded? Is it ac- tive or inactive? They are about describing how a module or layout looks on screens that are smaller or bigger. They are also about de- scribing how a module might look in different views like the home page or the inside page;
A state is something that augments and overrides all other styles;
States should be made to stand alone and are usually built of a single class selector, sometimes you can use !important to address the state;
In a case where a state rule is made for a specific module, the state class name should include the module name in it;


Theme rules: Theme rules are similar to state rules in that they describe how modules or layouts might look. Most sites don’t require a layer of theming but it is good to be aware of it;
Focus on general appearance of your website like colors, borders etc;



And also using proper name for different categories can be beneficial for immediately understanding which category a particular style belongs to and its role within the overall scope of the page. Here is a simple example:
123456789101112/* Example Module */.example &amp;#123; &amp;#125;/* Callout Module */.callout &amp;#123; &amp;#125;/* Callout Module with State */.callout.is-collapsed &amp;#123; &amp;#125;/* Form field module */.field &amp;#123; &amp;#125;/* jsExample is a subclass or variation of example */.example-jsExample &amp;#123; &amp;#125;/* Inline layout  */.l-inline &amp;#123; &amp;#125;
Tips
Minimizing the Depth: The depth of applicability is the number of generations that are affected by a given rule;
Two Goals of SMACSS: Increase semantics and decrease reliance on specific HTML;
How to separate the files in your project:
Place all Base rules into their own file;
Depending on the type of layouts you have, either place all of them into a single file or major layouts into separate files;
Put each module into its own file;
Depending on size of project, place sub-modules into their own file;
Place global states into their own file;
Place layout and module states, including media queries that affect those layouts and modules, into the module files;


Organize styles in the following order:
Box: display, float, position, left, top, height, width…
Border: border;
Background: background;
Text: font-family, font-size, text-transform, letter-spacing…
Others: others;


Be Consistent;

SummaryThis book is pretty short with all valueable content. Strongly recommend after you get familiar with all basic css concepts.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (2)</title><link>http://taoalpha.me/blog/2015/06/30/read-coffeescript-programming-with-jquery-rails-and-nodejs-2/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-30T04:00:00.000Z</pubDate><description>SummaryAfter learned the basic syntax of CoffeeScript, I re-wrote all my blog’s js files with CoffeeScript. I have to say, practice is the best way to learn and understand one skill. Especially for coding, if you just read the book and never write a single line by yourself, you will never become a master of it or you may stick in the beginner for ever.
Today we will finish the book. Talking about how to combine the CoffeeScript with some other web tools we use a lot: jQuery, Rails and Nodejs.
NotesHere I just ignored the second chapter about how to install the coffeescript and nodejs in your computer, if you need some help, feel free to comment below the blog or just visit the nodejs and coffeescript to find a way yourself.
jQueryjQuery is the most popular js module people used in their websites or webapps. And using jQuery with CoffeeScript is just like javascript. jQuery is javascript, after all.
Want to use CoffeeScript with jQuery? Just do it and follow the rules we learn from the basic syntax part. Here I list several examples and if you look it closely, you will find everything you have already known if you read the first chapter carefully. The author of the book shows us another complex examples: TodoMVC in CoffeeScript.
BTW: TodoMVC is a great project which shows you how to write a todo app in all kinds of tools and frameworks.
1234567891011121314151617181920212223242526272829303132333435363738394041$ -&amp;gt;  do some  do another### =&amp;gt;$(function() &amp;#123;  some();  return another();&amp;#125;);That's just like the $(document).ready(function()&amp;#123;&amp;#125;)#### A function using ajax to send mail, which is a new feature I will add to my blog in a few days :)@sendMail = (msg)-&amp;gt;  $.ajax    type: 'POST'    url: 'https://mandrillapp.com/api/1.0/messages/send.json'    data:      'key': ''      'message':        'from_email': msg.sender_mail        'from_name' : msg.sender_name        'to': [            &amp;#123;              'email': ''              'name': 'TaoAlpha'              'type': 'to'            &amp;#125;          ]        'autotext': 'true'        'subject': msg.subject        'html': msg.content  .done (response)-&amp;gt;    showAlert(&quot;success&quot;,&quot;Thanks for your contribution!&quot;)  .fail (data)-&amp;gt;    showAlert(&quot;fail&quot;,&quot;Sorry! Failed to send the email. Please retry!&quot;)# another function to get unique result from an array of objectsArray::getObjectUnique = (id) -&amp;gt;  a=b=[];  add = (data) -&amp;gt; b.push data[id];data  (add i for i in @ when b.indexOf(i[id]) == -1 )
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// You can see that you have saved a lot of keystrokes and the codes look more clean and beautiful.// Because coffeescript doesn't support declare global variables directly, and if we want to use the function in other script, we need to declare it into the `this` scope.this.sendMail = function(msg) &amp;#123;  return $.ajax(&amp;#123;    type: 'POST',    url: 'https://mandrillapp.com/api/1.0/messages/send.json',    data: &amp;#123;      'key': '',      'message': &amp;#123;        'from_email': msg.sender_mail,        'from_name': msg.sender_name,        'to': [          &amp;#123;            'email': '',            'name': 'TaoAlpha',            'type': 'to'          &amp;#125;        ],        'autotext': 'true',        'subject': msg.subject,        'html': msg.content      &amp;#125;    &amp;#125;  &amp;#125;).done(function(response) &amp;#123;    return showAlert(&quot;success&quot;, &quot;Thanks for your contribution!&quot;);  &amp;#125;).fail(function(data) &amp;#123;    return showAlert(&quot;fail&quot;, &quot;Sorry! Failed to send the email. Please retry!&quot;);  &amp;#125;);&amp;#125;;# get unque result for array of objectsArray.prototype.getObjectUnique = function(id) &amp;#123;  var a, add, b, i, j, len, results;  a = b = [];  add = function(data) &amp;#123;    b.push(data[id]);    return data;  &amp;#125;;  results = [];  for (j = 0, len = this.length; j &amp;lt; len; j++) &amp;#123;    i = this[j];    if (b.indexOf(i[id]) === -1) &amp;#123;      results.push(add(i));    &amp;#125;  &amp;#125;  return results;&amp;#125;;
RailsRuby on Rails is a web framework that came around in 2004. And it soon became quite popular. Actually many people believe that Rails saved the ruby…
Check this:How to download and install Rails if you haven’t installed it.
Rails’s principles
Convention over configuration


Rails is designed to assume that the programmer will follow certain known conventions, which if used, provide great benefit and much less need to configure the framework.That means that the framework makes assumptions on how a typical application should be built and structured and it doesn’t try to be overly flexible and configurable. This helps you spend less time on mundane tasks like configuring and wiring up an application architecture and more time on actually building your app.


Don’t repeat yourself, or DRY


Every piece of knowledge must have a single, unambiguous, and authoritative representation within a system.Rails strives to remove duplication and boilerplate wherever it can.

How to use Rails with CoffeeScriptLuckily, after Rails 3.1, you don’t need do anything to let Rails support CoffeeScript. It has already become part of rails! And also, rails has changed its default js library to jQuery.
So what you need to do if you want to use coffeescript with rails? Nothing but learn rails!
Just like the author said in the book: “If you haven’t done so already, I encourage you to spend some more time learning Rails as well as Ruby, and immersing yourself in the wonderful communities they support.”
Node.jsNode is fantastic. It changes something. Before node, javascript was mostly run inside browsers. Now it just came out and gave web developers a chance to become a full-stack!
Features of Node
Event-driven


The Node.js framework only allows non-blocking, asynchronous I/O. This means that any I/O operation that is accessing an external resource, such as the operating system, a database, or a network resource must happen asynchronously.


Fast and scalable


The V8 JavaScript engine(created by google and used in chrome) used by Node.js is highly optimized for performance, thus making Node.js applications very fast. The fact that Node is non-blocking will ensure that your applications will be able to handle many concurrent client requests without using a lot of system resources.


Node is not Rails


Rails strives to be a full-stack solution to building web applications, whereas Node.js is more of a low-level system for writing any type of fast and scalable network application.

Node and CoffeeScriptWant to write coffeescript in node? It’s easy, all you need is a module named CoffeeScript. And like many other languages, node has several frameworks people built for web development, like: Express.
The core about how to use coffeescript with nodejs is to use the --watch for coffee command in node. It will automatically compile all file end with coffee into js when there is a change made into these files.
And just like jQuery, you just follow the rules and write your code.
DigestCoffeeScript is a tool that can help you write js more quickly and elegant. And any platform or language you want to use coffeescript, what you need to do is following the coffeescript’s rules. There is no difference caused by platform or language.
That’s all. Thanks!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (1)</title><link>http://taoalpha.me/blog/2015/06/28/read-coffeescript-programming-with-jquery-rails-and-nodejs/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-28T04:00:00.000Z</pubDate><description>SummaryThe notes I took while I was learning the ‘CoffeeScript’. If you are a real beginner with ‘CoffeeScript’, I suggest you start with another book called “The Little Book on CoffeeScript”, it’s better for beginners. And after that, this one is definitely your best choice.
CoffeeScript is a language which complies to JavaScript. Like the sass or scss to css except that CoffeeScript is not compatible with javascript. So you can not mix the javascript syntax with the CoffeeScript.
This note is mainly about the fist chapter of the book, a nice introduction for CoffeeScript including the basic syntax.

And to improve my english, I think i will start writing english notes for the english books. ^_^

NotesCoffeeScript is pretty popular in the community of JavaScript for its simplicity, elegant and readable. Now let us dive into it.
Instead of  listing the keywords and statements used in CoffeeScript one by one, it would better we learn CoffeeScript from comparing the difference between the CoffeeScript and JavaScript.
CoffeeScript fix some ugly stuffs in JavaScript
CoffeeScript removes most of the semicolons and the curly braces which used a lot in JavaScript, gives us a clearly view of the code, but you can still use the semicolons if you want, and you still have to use the semicolons if you want to put multiple statements in single one;
CoffeeScript learns a lot from ruby and python. Like this one: it uses whitespace or indentation, more accurately, to delimit the code blocks instead of braces.
CoffeeScript removes a lot of parenthesis for many statements and functions, like if..else, while loops and functions with single string parameter. But this is optional, you can still use them if you want. Notice: you will need parenthesis if you want to call a function without any parameters)
Function: as the first class object in JavaScript, CoffeeScript also does a lot improvements for it.
If you write js, you will know that the syntax is really ugly when you want to write a anonymous function. Now you can make it pretty beautiful with CoffeeScript;
CoffeeScript also saves you a lot keystrokes for defining the functions;
so what are the rules?
Replace the function keyword with -&amp;gt;;
Drop the parenthesis if there is no argument for the function;
Put the arguments enclosed with parenthesis in front of the -&amp;gt;, and if the argument has a default value, you can set it in the parenthesis;
Drop the curly braces and use indentation for the function body;
Automatically return the last expression of the function, but if you need return something before, you still need to use the return;





1234567891011121314151617 -&amp;gt; alert 'hi there!'# the code above won't self-initiating, if you want to do that, you need use parenthesis or the `do` keyword like below:# (-&amp;gt; alert 'hi there!')()# do -&amp;gt; alert 'hi there!'square = (n=1) -&amp;gt; n * n# function using splats# this is an alternative way for using Array.prototype.slice()gpaScoreAverage = (scores...) -&amp;gt;  total = scores.reduce (a, b) -&amp;gt; a + b  total / scores.lengthalert gpaScoreAverage(65,78,81)scores = [78, 75, 79]alert gpaScoreAverage(scores...)
1234567891011121314151617181920212223242526272829303132333435var square;(function()&amp;#123;  return alert(&quot;hi there!&quot;);&amp;#125;);/* the code in comments above will compile to:(function()&amp;#123;  if (n == null) &amp;#123;    n = 1;  &amp;#125;  return alert(&quot;hi there!&quot;);&amp;#125;)();*/square = function(n) &amp;#123;  return n * n;&amp;#125;;// [].slice.call(arguments,0) ==&amp;gt;  Array.prototype.slice.call(arguments,0)var gpaScoreAverage, scores,  slice = [].slice;gpaScoreAverage = function() &amp;#123;  var scores, total;  scores = 1 &amp;lt;= arguments.length ? slice.call(arguments, 0) : [];  // get the single score value or a list of the scores  total = scores.reduce(function(a, b) &amp;#123;    return a + b;  &amp;#125;);  return total / scores.length;&amp;#125;;alert(gpaScoreAverage(65, 78, 81));scores = [78, 75, 79];alert(gpaScoreAverage.apply(null, scores));
CoffeeScript saves you a lot of keystrokes
CoffeeScript will declare the variables you need at the top of the function for you automatically. So that means you can’t create the global variables in a function like you can do in JavaScript, actually you can’t use the var keyword in CoffeeScript. &amp;lt;= many people agree that omitting the var keyword makes the variables become global is a really bad desgin…
Object:
CoffeeScript supports the class keyword, and it will create a closure to build the class;
Use the constructor to initialize some private properties, or just omit it;
Every function you define in a class will be added to the object as a prototype method;
Use @ as a shortcut for this;
fat arrow: When you want to use this in previous scope instead of the new scope, you need the fat arrow : =&amp;gt;;
Use super to call the parent’s method (same name, so just pass the parameter);
Use :: as a shortcut for .prototype, so you can extend your prototype as this:Vehicle::stop =-&amp;gt; alert &amp;#39;stop&amp;#39;;



123456789101112131415161718192021222324252627282930313233class Vehicle  # Use the constructor to initialize some private properties  # Use @ as this  constructor: -&amp;gt;    @c = 1  drive: (km) -&amp;gt;    alert &quot;Drove #&amp;#123;km&amp;#125; kilometres&quot;class Car extends Vehicle constructor: -&amp;gt;   @odometer = 0 drive: (km) -&amp;gt;   @odometer += km   super km name:&quot;John Doe&quot; driver: (msg) -&amp;gt;   @msg = msg whoisdriver: -&amp;gt;   @msg()car = new Carcar.drive 5alert &quot;Odometer is at #&amp;#123;car.odometer&amp;#125;&quot;class Person  constructor: (name)-&amp;gt;    @name = name    @mycar = new Car()    @mycar.driver =&amp;gt; alert &quot;#&amp;#123;@name&amp;#125;&quot;mike = new Person &quot;Mike&quot;# use `=&amp;gt;` to show mike's name instead of the default `john doe` set in Carmike.mycar.whoisdriver()
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var Car, Person, Vehicle, car, mike,  extend = function(child, parent) &amp;#123; for (var key in parent) &amp;#123; if (hasProp.call(parent, key)) child[key] = parent[key]; &amp;#125; function ctor() &amp;#123; this.constructor = child; &amp;#125; ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; &amp;#125;,  hasProp = &amp;#123;&amp;#125;.hasOwnProperty;Vehicle = (function() &amp;#123;  function Vehicle() &amp;#123;    this.c = 1;  &amp;#125;  Vehicle.prototype.drive = function(km) &amp;#123;    return alert(&quot;Drove &quot; + km + &quot; kilometres&quot;);  &amp;#125;;  return Vehicle;&amp;#125;)();Car = (function(superClass) &amp;#123;  extend(Car, superClass);  function Car() &amp;#123;    this.odometer = 0;  &amp;#125;  Car.prototype.drive = function(km) &amp;#123;    this.odometer += km;    return Car.__super__.drive.call(this, km);  &amp;#125;;  Car.prototype.name = &quot;John Doe&quot;;  Car.prototype.driver = function(msg) &amp;#123;    return this.msg = msg;  &amp;#125;;  Car.prototype.whoisdriver = function() &amp;#123;    return this.msg();  &amp;#125;;  return Car;&amp;#125;)(Vehicle);car = new Car;car.drive(5);alert(&quot;Odometer is at &quot; + car.odometer);Person = (function() &amp;#123;  function Person(name) &amp;#123;    this.name = name;    this.mycar = new Car();    this.mycar.driver((function(_this) &amp;#123;      return function() &amp;#123;        return alert(&quot;&quot; + _this.name);      &amp;#125;;    &amp;#125;)(this));  &amp;#125;  return Person;&amp;#125;)();mike = new Person(&quot;Mike&quot;);mike.mycar.whoisdriver();
Other Good Things
CoffeeScript will quote reserved words automatically if you use them in your literal object;
You can also drop the comma when you define your literal array or literal object only if you put one property per line, you can drop the braces for object, but you need them for array;
Use #{variable_name} to concatenate the string and variables instead of +, but only use them enclosing with double-quote, the single-quote strings are literal, borrowed from ruby;
CoffeeScript will always convert the == and != to === and !==;
Use the existential operator: ? to check whether a variable exists and has a value or not(means not null or undefined);
Also use the soak: ?. as a shortcut for ternary statement;
Support some new keywords like unless, the opposite to if;
Use plain english aliases for some of the logical operators: is for ===,isnt for !==,not for !,and for &amp;amp;&amp;amp;,or for ||,true can also be yes, or on,false can be no or off;
Support assign multiple values at once;
CoffeeScript replaces the case in switch with when ... then, so you can forget about the break, and it also replaces the default with else;
CoffeeScript supports the chained comparisions: 61 &amp;gt; a &amp;gt; 39;
You can use ### to comment multiple lines. The biggest difference between ### and # is former one will be part of generated javascript;

1234567891011121314151617b=1if a? &amp;amp;&amp;amp; b?  alert &quot;a.c equals to #&amp;#123;a?.c&amp;#125;&quot;[city, state, country] = [&quot;!2&quot;,&quot;24&quot;,&quot;2&quot;]# or function which returns an object with the same structure as you described before the `=`&amp;#123;address: &amp;#123;street: myStreet,room: myRoom&amp;#125;&amp;#125; = getAddress()### =&amp;gt;var b;b = 1;// since we declared the b before, we only need to check if b is null.if ((typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null) &amp;amp;&amp;amp; (b != null)) &amp;#123;  alert(&quot;a.c equals to &quot; + (typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null ? a.c : void 0));&amp;#125;var city, country, myRoom, myStreet, ref, ref1, state;ref = [&quot;!2&quot;, &quot;24&quot;, &quot;2&quot;], city = ref[0], state = ref[1], country = ref[2];ref1 = getAddress().address, myStreet = ref1.street, myRoom = ref1.room;###
Special for List
List: CoffeeScript borrowed a lot list comprehensions from python[ x*2 for x in object_name ] and ruby.
while: it works nearly the same as in javascript except that it has an opposite keyword in CoffeeScript: until and both of them can be used as expression and will return a array;
for: the standard statement is [action or mapping] for [selector] in [collection] when [condition] by [step]. Last by following with a number would affect the loop step(`i++``);
[f_number..l_number]: it will create a array with numbers between the fist number and the last number, you can use ...(3 dots) to make the array only contains the numbers in between;
of: for key-value pairs of an object, you can use of to loop them through;



1234567891011121314151617181920212223242526272829303132333435363738394041times = [0..2](n*times while times -= 1).pop()### =&amp;gt; var times; times = [0, 1, 2];((function() &amp;#123;  var results;  results = [];  while (times -= 1) &amp;#123;    results.push(n * times);  &amp;#125;  return results;&amp;#125;)()).pop();###alert x for x in flavors when x != 'h' by 2###=&amp;gt;var x, i, len;for (i = 0, len = flavors.length; i &amp;lt; len; i+=2) &amp;#123;  x = flavors[i];  if (x !== 'h') &amp;#123;    alert(x);  &amp;#125;&amp;#125;###ages = john: 25 peter: 26 joan: 23alert &quot;#&amp;#123;name&amp;#125; is #&amp;#123;age&amp;#125; years old&quot; for name, age of ages###=&amp;gt;var age, ages, name;ages = &amp;#123;  john: 25,  peter: 26,  joan: 23&amp;#125;;for (name in ages) &amp;#123;  age = ages[name];  alert(name + &quot; is &quot; + age + &quot; years old&quot;);&amp;#125;###
Digest
For JavaScript:
Every class in JS is a function object;
Only function object has the default prototype, so the normal objects like literal string, number or even string created from String(),any objects created by functions, they all don’t have the default prototype;
But every object has a default constructor which is exactly the function object who create it;


For CoffeeScript:
If there is only one line in the body, you can move it in front of the condition &amp;lt;= while/until/for/if...



Puzzle
Q1: In the second code example above, CoffeeScript create a default extend function for us:

123456789101112131415161718192021var extend = function(child, parent) &amp;#123;  for (var key in parent) &amp;#123;      if (hasProp.call(parent, key)) child[key] = parent[key];  &amp;#125;  // Start from here  function ctor() &amp;#123;      this.constructor = child;  &amp;#125;  ctor.prototype = parent.prototype;  child.prototype = new ctor();  // End  // Just cannot understand the codes above...  // Why we need another function as the child's prototype? We have already copied all the properties from parent, or we just need a beautiful prototype chain? `Car &amp;lt;= ctor() &amp;lt;= Vehicle() &amp;lt;= Object` compared to `Car &amp;lt;= Car &amp;lt;= Object()`.  // Then why not we just use the child.prototype = new parent() ??? we can still get a good prototype chain. `Car &amp;lt;= Vehicle &amp;lt;= Vehicle &amp;lt;= Object`.  child.__super__ = parent.prototype;  return child;&amp;#125;,hasProp = &amp;#123;&amp;#125;.hasOwnProperty;
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (5)</title><link>http://taoalpha.me/blog/2015/06/24/read-javascript-the-definitive-guide-5/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-24T08:00:00.000Z</pubDate><description>概述在十到十二章中, 第十章的正则表达式内容最为丰富, 也是目前应用即为广泛的内容之一. 不过这里也主要是结合js的应用, 实际上正则表达式本身就是一个很值得研究的话题, 有不少书都在谈这个话题, 我后面要读的书目中恰巧就有这么一本, 后面会更加详细的学习以下正则表达式的方方面面.
十一章算是非常前沿, 高端或者说冷门的点了, 随着浏览器的盛行以及技术的进步, 安全问题始终都是一个很重视的点, 而在这种攻防演练中也促进了js本身的进步, 而主流浏览器本身更是走在了js的最前沿. 各种新的属性都是由他们引入而逐渐成为标准的;
十二章主要是对走出浏览器的JS做了一个简单的介绍, 而NodeJS的大名在近几年在前后端, 全端领域都可谓是人尽皆知. 我也会在之后阅读相关书籍的时候做更详细的笔记记录.
阅读笔记Chapter 10 - Pattern Matching Regular Expressions
normal repetition characters:
{m,n} 匹配m-n次;
{m,} 匹配至少m次;
{m} 匹配恰好m次;
? 匹配0或1次;
+ 匹配1或多次;
* 匹配0或多次;


Nongreedy repetition:
??, +?, *? 在常规的匹配后加上?就能让匹配尽可能发生的短, 它会在允许范围内, 找到尽可能短的匹配;


Alternation, Grouping, Reference:
| 表示匹配前者或者后者;
(...) 成组, 以组的形式来使用*,+,?等, 同时会记录组的匹配以用于Reference;
(?:...) 只是成组, 不记录匹配, 不能用于reference, 也不算做reference的序号中去;
\n 引用, n表示序号, 从1开始, 代表之前第几个group的匹配, 用于匹配开头结尾相同且多样的有奇效:/([&amp;#39;&amp;quot;])[^&amp;#39;&amp;quot;]*\1/ 匹配单引号或者双引号内的内容;
需要注意的就是, reference不能用于[]的character class之中!


anchor characters:
^: 匹配开头;
$: 匹配结尾;
\b: 匹配词边界, /\bJava\b/ =&amp;gt; Java
\B: 匹配非词边界, /\B[Ss]cript\B/ =&amp;gt; JavaScript, postscript...
?=p: 表示内容需要匹配p规则,但是返回的命中中不包含这部分;
?!p: 表示内容不匹配p规则;


flags:
i: 大小写敏感, 即区分大小写;
g: 全局匹配, 默认是匹配首个;
m: 多行匹配;


String Methods for Pattern Matching:
search(): 返回匹配词的位置或者-1代表无返回;
replace(): 支持正则匹配替换, 同时支持替换时使用$n代表是正则匹配的引用, 比如text.replace(/&amp;quot;([^&amp;quot;]*)&amp;quot;/g, &amp;#39;“$1”&amp;#39;);即替换&amp;quot;&amp;quot;为“”;
match(): 返回包含了匹配的结果, 返回结构为数组格式;
split(): 接受正则匹配作为其分隔符, 比如: &amp;quot;1, 2, 3&amp;quot;.split(/\s*,\s*/); =&amp;gt; [&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;], 就去掉了本来直接split()多余的空格;


RegExp prototype method:
exec(): 基本等同match(), 不过接受的是string类型去匹配, 而由正则去调用, 当表达式加了全局flag后, exec()每次执行会记录其上次匹配的位置并从此开始新的匹配, 比如:var pattern = /Java/g;pattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).indexpattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).index就会相继输出0,28两个位置;
test(): 用以检测表达式是否匹配了传入的string, 其执行逻辑(g模式下记录上次匹配位置)和exec()一样;



Chapter 11 - JavaScript Subsets and Extensions本章主要介绍一些目前主流浏览器支持但是还没有写入JavaScript官方版本中的一些js语言的子集(非官方版本)和扩展属性:

subsets: 通常是为了确保不确定安全性的代码能够安全的运行而出现的(除了Crockford’s JavaScript: The Good Parts);
ADsafe, 最早一个因为安全因素设计的子集语言, 会禁止对绝大多数全局变量的访问;
dojox.secure: 算是Dojo toolkit的一个扩展;
Caja: 其包含了两个子集, 一个是Cajita, 比较严格, 类似ADsafe 和 dojox.secure; 还有个是Valija, 则比较接近如今ECMAScript 5的strict mode了;
Microsoft Web Sandbox;
FBJS: facebook使用的一个自己;通常子集都需要对应一个verifier, 来确保代码符合其要求;


extensions:
const: 声明常量, 比如: const pi = 3.14;;
let: 块变量声明, 相当于缩小版的var, 作用域仅存活在最近的一个块结构里, 你可以用{}来自行创建一个block;
destructing: 允许多变量结构化赋值: let [x,y] = [1,2];let [r,theta] = polar(1.0, 1.0); function polar(x,y){...};甚至这种all = [first,second] = [1,2,3,4]; 或者这种let transparent = {r:0.0, g:0.0, b:0.0, a:1.0}; let {r:red, g:green, b:blue} = transparent;;
for/each: 和for/in循环不同, for/each遍历对象的属性值而不是属性名, 且可操作类array对象;
for/in: 从js 1.7(mozilla的js引擎版本号)开始, for/in也不局限在array和常规object了, 只要是可循环的元素都可以使用了;
yield: 从python中引入的;
Array Comprehensions:  还是从Python中借用的, let evensquares = [x*x for (x in range(0,10)) if (x % 2 === 0)];
try/catch: 支持多catch;



Chapter 12 - Server-Side JavaScript随着js的发展, 慢慢的超出了其本身的作用域: 浏览器. 随着Google V8引擎为js包入了unix的常用API: files,processes,streams,sockets等, js开始走出浏览器进入server端了. 正式命名为Node.JS. 想来很多人可能都听过, 因为后面我的数目中也包含了相关的书, 且本章内容也没见过太多, 所以就一起留到以后吧~
参考文献:
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>像TED一样演讲</title><link>http://taoalpha.me/blog/2015/06/25/read-speaking-like-people-on-ted/</link><category>read</category><tag>reading notes,speaking</tag><pubDate>2015-06-25T09:00:00.000Z</pubDate><description>概要今天顺带读完了这本”像TED一样演讲”, 作者上一部和演讲相关的书是”乔布斯的魔力演讲”. 归纳了下书中的核心点, 记录分享给大家. 这一类的书干货其实能占到全书1/10就已经算不错了~ 所以一般看起来也比较快.
阅读笔记情感共鸣
释放你内心的热情 =&amp;gt; 热情可以传染;
掌握讲故事的艺术 =&amp;gt; 故事可以刺激并吸引人脑的注意力, 拉近你与听众的距离;
与演讲主题相关的个人故事;
与演讲主题相关的他人故事;
关于产品或者品牌的某个故事;


让演讲好像好友交谈一样自然;

制造新奇
给人们一个看世界的新视角;
设计让观众惊掉下巴的环节 =&amp;gt; 触发神经学家所说的讲情绪, 让记忆更加深刻;
用幽默给你的演讲加分;

令人难忘
严格遵守18分钟的时间规则 =&amp;gt; 有约束才有创造力;
抓住观众吸引力的魔法, 多感官体验 =&amp;gt; 让内容视觉化;
表现最真实的自己;

书中涉及到的TED(部分)
Bryan Stevenson: We need to talk about an injustice
Dan Ariely: Our buggy moral code
Truly sustainable economic development
Jennifer Granholm: A clean energy proposal – race to the top!
Amy Cuddy: Your body language shapes who you are
Robert Ballard: The astonishing hidden world of the deep ocean
Hans Rosling: The best stats you’ve ever seen
Mary Roach: 10 things you didn’t know about orgasm
Bill Gates: Mosquitos, malaria and education
Jill Bolte Taylor: My stroke of insight
Stephen Hawking: Questioning the universe
David Christian: The history of our world in 18 minutes

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (6)</title><link>http://taoalpha.me/blog/2015/06/25/read-javascript-the-definitive-guide-6/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-25T10:00:00.000Z</pubDate><description>概述正式进入本书第二部分的内容, 核心主要围绕在浏览器内的js. 包含了最基本的使用方式, 方法, 因浏览器而增加的各种属性方法, 操作css, dom的方法, 以及常用的一些js框架, 库等, 同时还包含了目前浏览器大热的安全领域.
阅读笔记Chapter 13 - JavaScript in Web Browsers
异步:
defer: 使浏览器在解析并加载渲染完HTML的DOM后加载此js脚本;
async: 使浏览器在尽快执行js脚本, 但在下载js脚本时不停止DOM的解析, 优先级高于defer;
使用方式为在script中增加关键字即可: &amp;lt;script defer src=&amp;quot;deferred.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;;
注意在使用defer/async的时候, js中不能使用document.write();
document.readyState的变化过程: loading(async downloading, normal executing) =&amp;gt; interactive (defer/async executing) =&amp;gt; complete(defer/async done, event handlers invoked);


Compatibility Check:
按照目前的浏览器格局, 基本上一个浏览器就有着一种js的版本, 除了标准版本的基础功能之外, 所有的扩展功能, 各家与各家的实现方式都略有不同, 所以在使用过程中, 就需要我们考虑到兼容性的问题;
Can I Use…, 这是一个非常优秀的检测某个属性, 方法的浏览器支持度, 拿不准的都可以在这里进行查询确认, 其还支持css和html5的检测;
IE5的时候引入了一个Conditional Comments的技巧, 是通过特殊的html注释从而让浏览器识别其IE版本, 比如&amp;lt;!--[if lte IE 7]&amp;gt;&amp;lt;![endif]--&amp;gt;就代表IE7及以下, 而写在这个if里面的内容就会在IE7及以下的浏览器中被识别并作为页面html的一部分而提取出来(仅限IE浏览器), 其他的浏览器都会自动当做注释不理会此部分;
IE的JS也支持Conditional Comments, 比如/*@cc_on @if (@_jscript)...@end @*/, 这里面@cc_on...@*/是整个Conditional Comments, 而里面的@if (@_jscript)...@end则是判断部分, 其中@_jscript是IE自身js编译器的名称;


Accessibility:
对于身体原因而有不便的人, js的支持效果会大打折扣, 所以根据这部分人的情况而优化自身的网页结构, 目前也是网页设计的一大核心之一;


Security:
随着js的发展使用, 其危害性也日益提升;
目前的保障安全手段主要有:限制其功能,限制其使用范围和情景,敏感权限默认关闭虚人工开启;
The Same-Origin Policy: js只允许读取与当前执行环境域名相同域名下的windows属性, 那么怎么界定相同域名呢:
来自不同的网络服务器;
来自相同的网络服务器, 不同的端口;
同一网络服务器, 同一端口, 不同的http协议(http,https);
以上, 都认为是不同域名;


如何舒缓此规则:
document.domain: 考虑到同级子域名也会被禁止, 那么通过设定document.domain为同一母域名即可实现同级子域名的跨域;
Cross-Origin Resource Sharing: 通过http请求新增的Access-Control-Allow-Origin头部, 服务器就可以指定其允许跨域的程度了;
cross-document messaging: HTML5新增了一些很强大的API,cross-document messaging API就是其中之一, 它允许不同的document之间的js进行通讯;





Chapter 14 - The Window Object
Timers:
setTimeout(): 延时触发;
setInterval(): 定时循环执行;
clearTimeout(): 清除延时触发;
clearInterval(): 清除定时循环;


Location:
window.location === document.location 两者皆为当前页面url, 并随页面url变化而更新;
document.URL 也是指代加载后的当前页面, 但不随页面内动态变化引起的url变化而变化;
Location这个对象本身包含了多个属性分别指代url的不同部分:protocol表示网络协议, host, hostname通常都指示域名,前者包含端口, port表示端口, pathname表示以域名根目录为/的相对路径, search表示url中?以后的部分但不包含hash部分, hash则是表示url#以后的部分;
Location还包含了三个常用的函数:assign(),replace(),reload(), 其中前两者功能都一样, 都是用以加载新页面的, 不过replace()加载的同时将当前页面从history中去除了(就是不能后退后之前页面了), 而assign()还保留着; reload()就更不用说了, 只是单纯的重载页面;


History:
back(),forward(): 等价于浏览器的后退,前进按钮;
go(n): 接受数字作为参数, 表示向前或者后退n个页面;
如果页面中有iframe, 那么其history会自动合并到主界面的history中;


Navigator:
appName: 浏览器的名称;
appVersion: 浏览器版本号;
userAgent: 用户代理, 对应HTTP的USER-AGENT;
platform: 操作系统;
onLine: 是否连通网络, HTML5支持;
geolocation: 用户地理位置信息, HTML5支持;
javaEnabled(): 对Java扩展的支持, 非标准;
cookiesEnabled(): 能够设置cookie, 非标准;


Screen:
width,height: 当前屏幕的长宽尺寸;
availWidth,availHeight: 去除功能区等部分之后的实际展现内容的屏幕尺寸;
colorDepth: 显示屏幕的bits-per-pixel;


Dialog Boxes:
alert(): 弹出对话框, 展示传入的信息;
confirm(): 自带OK,Cancel按钮的对话框, 返回对应的boolean值;
prompt(): 附带输入框, 返回输入的值;
上述三个类型的对话框的样式结构都无法调整, 是浏览器默认设定的;
showModalDialog(): 则更加复杂, 它可以支持弹出一个页面, 其接受的第一个参数即为页面的url, 后面的参数则是弹出窗口的属性; 在chromium中已经被禁止了


onerror handler:
用于处理错误信息的, 你完全可以定制这个函数来更好的显示js中的错误信息;


Document Elements As Window Properties:
当一个html元素被赋予了id时, 其id对应名称的全局变量不存在时, 其自动转为全局变量, 属性名称即为id名, 但如果id名已经被使用, 则不生效;
对于&amp;lt;a&amp;gt; &amp;lt;applet&amp;gt; &amp;lt;area&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;form&amp;gt; &amp;lt;frame&amp;gt; &amp;lt;frameset&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;img&amp;gt; &amp;lt;object&amp;gt;这样的元素, 其name值和id效果是一样的, 且name值支持多个元素相同, 会自动生成类array形式, 对于iframe, 对应的属性会指向其内嵌窗口的window对象;


Multiple Windows and Frames:
通过js打开的新窗口都可以被js获取到, 并进行操作, 但是需要符合same-origin的原则;
frame嵌入的窗口可以通过parent.frames属性来获取, 也可以通过其自带的contentWindow来获取;



谜题
Q: 在测试same-origin的时候, 发现有些网站可以设定子域名的document.domain为母域名, 有些不能? 比如在google的搜索结果页, 就可以, 但是在github pages中想要设置为github.io就不可以, 会出现&amp;#39;github.io&amp;#39; is a top-level domain.这样的错误?

参考资料
JavaScript the Definitive Guide 6th edition
Can I Use …
host and hostname

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (7)</title><link>http://taoalpha.me/blog/2015/06/26/read-javascript-the-definitive-guide-7/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-26T06:00:00.000Z</pubDate><description>概述阅读笔记Chapter 15 - Scripting Documents
Selecting:
document.getElementById(id): 通过id, 一个id对应一个元素;
document.getElementsByName(name): 通过name, 可多个;
document.getElementsByTagName(tagname): 通过标签名;
document.getElementsByClassName(class_name): 通过类名;
querySelectorAll(css_selector): 通过css的选择器, 返回所有匹配;
querySelector(css_selector): 返回首个匹配;


Trees of Nodes:
parentNode: 父节点;
childNodes: 子节点;
firstChild, lastChild: 首个或者最后一个子节点;
nextSibling, previousSibling: 下一或者上一兄弟姐妹节点;
nodeType: 节点类型, Document 节点返回9, 元素节点返回1, 文本节点返回3,注释节点返回8, DocumentFragment节点返回11;
nodeValue: 当前节点的文本内容;
nodeName: 标签名, 大写;


Trees of Elements: 忽略所有的文本节点和注释节点;
firstElementChild, lastElementChild: 返回首个或者最后一个元素节点;
nextElementSibling, previousElementSibling
childElementCount: 返回子元素节点的个数;


Attributes of Elements:
getAttribute()
setAttribute()
hasAttribute()
removeAttribute()


Dataset Attributes: 由HTML5引入, 所有带data-前缀的属性都算是合法的html元素属性.
Element Content:
innerHTML
outerHTML: 包含匹配元素自身标签;
insertAdjacentHTML(): 允许指定插入位置beforebegin, afterbegin, beforeend or afterend;
textContent: IE不支持
innerText: IE支持, 功能同上;


Creating,Inserting, and Deleting Nodes
document.createElement(tag_name)
document.createTextNode(text): 创建文本节点;
document.createComment(text): 创建注释节点;
document.createDocumentFragment(): 创建孤立节点;
node_name.cloneNode(): 复制当前节点;
element_node.appendChild(element_node_2): 由后插入;
element_node.insertBefore(element_node_2): 由前插入;
removeChild(): 移除当前节点n.parentNode.removeChild(n);;
replaceChild(): 替换


DocumentFragment: 孤立节点, 其没有母节点(null), 当appendChild()等操作针对其时, 操作执行对象自动变为其所有子节点, 且操作完成后, 其自身为空;
viewport: 表示实际展示内容的窗口, 在顶层网页中为去除浏览器菜单等等之外的部分, 而在iframe中则为iframe定义的frame大小;
document: 表示页面内容的窗口, 通常都大于viewport;
getBoundingClientRect(): 返回节点的长宽,上下左右边界属性width,height,top,left,bottom,right, 返回的结果是基于viewport的;
document.elementFromPoint(): 返回x,y处的元素节点 - 根据z-index, 从外到内的返回;
scroll(), scrollTo(), scrollBy(): 窗口滚动控制, 最后的scrollBy()传入的x,y表示在原有的基础上的增加值;
scrollIntoView(): 滚动到某个节点;
document.forms: 获取页面中所有form元素;
其他document属性:
cookie
domain
lastModified: 修改时间;
location: 等同于window.location
referrer
title
URL: 之前提到过, 其只保存打开时的当前链接, 不随页面内的动态变化而变化;



Chapter 16 - Scripting CSS
js可以通过node.style来访问元素样式属性, 可以获取, 赋予; 而通过更加复杂的函数变化, 就可以创造出一些很棒的动效来, 在css3之前, 所有的非gif或者flash动效基本都是通过js实现的.
window.getComputedStyle(element,&amp;quot;null or :first-line etc&amp;quot;)则可以获取某个元素(或者某个元素的伪类)的所有样式属性, 同时获取的值都会自动转为标准的绝对值(比如设定的百分比也会自动计算出来返回),但是其不能赋予;
disableStylesheet()可以禁止某个元素的所有样式, 如果传入的是数字, 那么会按照document.styleSheets的顺序查找, 如果是string, 则作为css selector查询对应的元素;
insertRule(rules,insert_index), deleteRule(rules) 即插入整条的结构化的css语句, IE下对应的函数为addRule(),removeRule();
document.createStyleSheet则可以创建一个新的样式表, 等价于在head里面创建一个style标签;

Chapter 17 - Handling Events
Events的类型
Device-dependent input events:mousedown, mousemove, mouseup, keydown, keypress, keyup, touchmove, gesturechange;
Device-independent input events: click
User interface events: focus, change
State-change events: loadstart, progress, loadend
API-specific events: dragstart, dragenter, dragover, drop, waiting, playing, seeking, volumechange etc
Timers and error handlers;


Handlers:
Event Handler Attributes: onclick=&amp;quot;&amp;quot;,window.onload = f();
addEventListener(event_name,function,[capturing event handler]): 添加事件, 最后的capturing通常为false;
removeEventListener(): 和上面的add相反;
stopPropagation(): js的事件触发是沿着DOM树向上传递的, 而通过stopPropagation()就能抑制这一环节;
preventDefault(): 很多元素有其自身的事件属性, 比如a标签的跳转, form元素的提交, 当我们想要取消其默认事件的发生时, 可以使用此函数来阻止其发生;



总的来说, 这一章内容其实很丰富, 但是其内容多数都是建立在之前的基本内容之上的. 着重需要知道的就是各种不同的事件, 其支持的元素, 类型以及触发的方式即可. 此类用法主要还是多用多练, 可以试试不同的event都包含那些属性~哈哈
Chapter 18 - Scripted HTTP
XMLHttpRequest:
Ajax: 由js端发起, 通过http请求和服务端交互;
Comet: 由服务端发起, js如果需要反应则使用Ajax回应, 通常由EventSource对象处理;
标准流程:new XMLHttpRequest()=&amp;gt;open(&amp;#39;type of request&amp;#39;, url,[],[username],[userpassword])=&amp;gt;setRequestHeader()=&amp;gt;send([content_body])&amp;lt;=onreadystatechange&amp;lt;=customized handler
通常GET类型的请求我们会通过encodeURIComponent来进行url拼接, 直接在url中体现, send()的时候就不用传值了;
POST类型的请求通常以json格式传递, 我们需要在send()中传入JSON.stringify()的数据, 当然如果是XML的POST, 那么直接传入对应的doc即可, 而像file这类的文件实体, 也是直接传入对应的实体即可;
起中Header部分我们只能自行设定部分, 而Content-Length,Date,Referer,User-Agent等等都由浏览器自动帮我们填上了;
readyState: UNSENT 0(open()还没执行); OPENED 1(open()已经执行);HEADERS_RECEIVED 2(headers已被接收),LOADING 3(正在接受返回),DONE 4(完毕).
XMLHttpRequest对象有一个onprogress的属性可以用来检测其执行进度, 它对应的属性值中包含了lengthComputable, loaded,total, 通过这三个就可以做一个简单的进度条跟踪请求的进度了;
如果是上传行为, 其onprogress属性存在于XMLHttpRequest_Object.upload.onprogress之中;
abort(): 用来取消请求;


EventSource:
标准流程: new EventSource(&amp;quot;url_to_server_file&amp;quot;) =&amp;gt; onmessage



Chapter 19 - The jQuery LibraryjQuery流行度的一大证据之一! 哈哈 我计划抽时间好好读一下jQuery的源码, 所以这里只是大概扫了一遍, 基本也都是应用层面的, 多数我差不多都使用过~哈哈
Chapter 20 - Client-Side Storage我在早先做chrome插件详见我的portfolio的时候, 写过一篇专门介绍web存储的文章. 恩, 当时写了不少patch系列, 哈哈, 改天写个脚本全部导出来转移过来.
恩
参考资料
JavaScript the Definitive Guide 6th edition 我现在就去写导入工具… 今天就到这里吧, 明天算是最后一篇就能完结本书啦~

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (8)</title><link>http://taoalpha.me/blog/2015/06/27/read-javascript-the-definitive-guide-8/</link><category>read</category><tag>js,reding notes</tag><pubDate>2015-06-27T12:00:00.000Z</pubDate><description>概述先说题外话: 昨天读到中途转去忙把以前的旧文章移植过来, 昨夜就已完成, 主要通过python解析了导出来的xml文本, 然后获取对应的时间信息和url信息组成符合jekyll规则的文件名, 再利用文本拼接出每个文件中固有的头和主体, 本来计划用html2text来把每个博文转为markdown, 不过后来源码有些问题, 对部分博文识别不好, 我也没时间细改, 所以就干脆拼接了html到主体中去.
主要导入了当初写的Patch系列和针对UX写的翻译系列. 分别归类到了Tech和DandP目录下. 有兴趣的可查看之~
今天来继续完结JavaScript: the Definitive Guide一书.
阅读笔记Chapter 20 - Client-side Storage
application cache:
为了丰富web app的功能, 或者说让web app更加的像native app, 就有了application cache这个机制, 从而让离线对于web app来说成为了可能;
application cache存储所有的静态格式, 包含html,css,javascript,images等等, 所有和web运行相关的资源文件;
application cache不作为常规cache而被轻易清理掉, 它会一直保持直到被要求删除或者用户手动删除;
Manifest: 为了能够让浏览器将网页存储到application cache里, 我们需要一个manifest文件, 并将之引入到html的head中&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;
此文件必须以CACHE MANIFEST为起始行;
列出所有需要加入application cache里的文件, 用相对路径, 相对与manifest文件而言;
#表示注释, 空行自动忽略;
此文件生效的前提是其MIME属性为text/cache-manifest, 即Content-Type这个header属性, 通常你需要自行在server中添加对应的规则;
如果网页由多个html组成, 则每个html都需要使用&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;声明, 指向同一个appcache文件即可;
一旦缓存, 则所有资源文件都从缓存中获取, 未列出的资源不予加载;


Complex Manifest:
manifest支持复杂规则, 其支持多个section, 包含了NETWORK:,FALLBACK:这两类, 还要加上默认的CACHE:;
NETWORK:: 所有不予cache必须要从网络获取的资源, 可以设定路径, 支持通配符*;
FALLBACK:: 如其名, 优先从网络获取, 无法获取时从本地获取, 所以其每行指定两个url;


Update:
对于Application Cache而言, 其更新主要依照manifest, 浏览器会自动在情况允许时帮助你查看manifest是否更新, 如有, 则重新缓存所有文件;
注意: 浏览器不会自动帮你查看缓存的文件是否更新, 只查看manifest;
通常可以使用#加一行version的注释行来强制更新;
applicationCache.onupdateready: application cache提供了状态函数来指示其更新的进度, 你可以针对其加以操作, 还包含onchecking,onnoupdate,ondownloading,onprogress,oncached,onerror,onobsolete;
除了上述事件外, 还可以通过applicationCache.status来探测其状态: ApplicationCache.UNCACHED =&amp;gt; (0),ApplicationCache.IDLE =&amp;gt; (1),ApplicationCache.CHECKING =&amp;gt; (2),ApplicationCache.DOWNLOADING =&amp;gt; (3),ApplicationCache.UPDATEREADY =&amp;gt; (4),ApplicationCache.OBSOLETE =&amp;gt; (5);
swapCache(): 清楚旧或者废弃的缓存;


Delete:
很简单, 删除manifest, 去掉html中的引用即可;





12345678910111213CACHE MANIFEST# appVersion: 1CACHE:myapp.htmlmyapp.cssmyapp.jsFALLBACK:videos/ offline_help.htmlNETWORK:cgi/
这就算是一个最基本的manifest了.
Chapter 21 - Scripted Media and Graphics
Images:
onmouseover: 鼠标hover移入事件;
onmouseout: 鼠标hover移出事件;
new Image(): 通过创建一个Image对象, 可以赋予其src属性从而实现预加载的功能;


Audio
(new Audio()).canPlayType(type): 检测某种类型的文件是否能播放;
play(): 播放;
initialTime: 初始播放进度;
duration: 文件总时长;
currentTime: 当前播放进度;
muted: boolean, 是否静音;
volume: 音量值;
controls: boolean, 是否显示控件;
loop: boolean, 是否循环;
preload: 是否预加载以及预加载类型, metadata表示加载时长,帧速等, auto表示尽可能预加载更多的内容, none什么都不预加载;
autoplay: boolean, 是否自动播放;
playbackRate: 播放速度(1.0 == normal speed);
readyState: 加载情况(0,1,2,3,4)=&amp;gt;(尚未加载, 已加载但当前位置未加载, 当前位置已开始加载但是不足以开始播放(下一帧还没加载好),已加载且足够播放但是不足以播放到结尾,加载基本足够可以播放至结束)
networkState: 当前媒体文件使用网络的情况(0,1,2,3)=&amp;gt;(还没开始, 没开始但可能已经加载完或者预加载设置为none, 正在使用中, 无法找到资源);
error: 错误信息(1,2,3,4)=&amp;gt;(用户手动停止, 类型正确网络不通畅, encoding问题, 类型不支持)


Video



SVG: Scalable Vector Graphics

SVG算是一种xml格式的矢量图类型;
最新的主流浏览器基本都支持直接在img中嵌入svg, 部分老的浏览器依然只支持使用object标签: &amp;lt;object data=&amp;quot;sample.svg&amp;quot; type=&amp;quot;image/svg+xml&amp;quot; width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;/&amp;gt;
一定程度上SVG很像canvas, 不过它是通过XML的属性来实现的(比如通过&amp;lt;line x1=&amp;#39;50&amp;#39; y1=&amp;#39;5.000&amp;#39; x2=&amp;#39;50.00&amp;#39; y2=&amp;#39;10.00&amp;#39;/&amp;gt;来画线);


Canvas

作为HTML5引入的一个可谓是最重要的标签之一, canvas的存在极大的丰富了网络的表现形式;
canvas和js的关系紧密, 因为其绘画的实现方式就是通过js;
canvas.getContext(&amp;#39;2d&amp;#39;/&amp;#39;3d&amp;#39;): 通过它创建的对象就可以在画布上尽情挥洒了;
很多canvas的函数本质都是数学坐标的公式运算!



我会在后面阅读的HTML5 Canvas中更加详细的研究canvas的各种用法~ 敬请期待~
  
Chapter 22 - HTML5 APIs
Geolocation:
navigator.geolocation.getCurrentPosition()
navigator.geolocation.watchPosition(): 在用户位置变化时唤醒;
navigator.geolocation.clearWatch()
实例 codepen


History Management:
pushState()
replaceState()
实例 codepen


Cross-Origin Messaging:
postMessage()
onmessage()
实例 codepen


Web Workers:
通常来说, js的执行是单线程的, 不支持多线程, 利用Worker可以稍稍的模拟下多线程;
Worker开启的执行不能对window和Dom有任何的操作, 和主线程只能通过postMessage()来交互;
Worker对象的工作域是WorkerGlobalScope, 完全和主线程工作域不同;
Worker支持importScripts来引入其需要的js库;
实例 codepen - 因为跨域问题, 所以这里不能执行, 不过代码很简单, 很好理解, 有兴趣的可以download到本地测试


Typed Arrays and ArrayBuffers:
HTML5 的数组类型变的更加强大, 开始出现类似Int8Array(),Uint8Array()等多种新形式;
实例 codepen


Blobs:
算是存储的一种新形势, 浏览器通常可以存储Blobs到内存或者硬盘中, blobs本身更是可以代表任何数据, 以二进制的形式;
实例 codepen


The Filesystem API: 开启本地文件交互时代;
实例 codepen


Client-Side Databases: 主要为IndexedDB;
实例 codepen


Web Sockets: 一种相对http来说的新网络协议;
实例 codepen



上面针对HTML 5的各个API给出了一个对应的实例, 毕竟看着具体的代码和例子才有意思哈哈
参考资料
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (2)</title><link>http://taoalpha.me/blog/2015/06/18/read-javascript-the-definitive-guide-2/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-18T10:00:00.000Z</pubDate><description>概述作为JS中的一等公民, function(函数)始终是JS的核心中的核心. 所以这里单独用一篇笔记来记录JavaScript: the definitive Guide一书第八章的内容. 主要介绍了函数的定义, 作用域, 参数, 声明以及执行等基础知识, 另外也着重介绍了其高级用法中的closure. 我将自己觉得重要的, 值得记录的部分都作为心得摘抄如下:
心得arguments对象对每一个function而言, 都自动会有一个内置的arguments对象, 用它就可以访问传入的参数了. 通常来说arguments对象我们只会用在不定长传参的函数上, 但arguments本身带有的一个函数却是可以在某些时刻发挥重要作用的~ 这个函数就是callee函数:
12345678// 递归自我调用函数在解决一些问题的时候是很常用的, 而通常情况下我们都会在函数内调用本函数名即可, 但是如果我们需要实现自我调用的函数正好是一个无名函数呢?// arguments.callee 即调用当前执行的函数function(x)&amp;#123;return x*arguments.callee(x-1)&amp;#125;// 如上, 就实现了一个很简单的&amp;gt;2阶乘计算了
需要特别注意的就是callee作为arguments对象的一个方法, 是可以跟随arguments作为参数传递的, 而且其作为参数的时候保持其所指代函数不变.
既然说到arguments, 就多说两句喽. 首先arguments算是一个类array的object. 它本身具有array的一些特性, 比如可以直接调用length函数(通常的object是不能通过.length直接调用获取长度的, 需要使用Object.keys(object_name).length才能获得). 但是它本身和array.length有很大的差别, 其中最大的一个差别就是: 无法通过.length直接更改数组长度.
123456var a = [1,3,4]a.length = 5console.log(a)// output: [1,3,4,undefined x 2](function(x)&amp;#123;arguments.length = 5;console.log(arguments)&amp;#125;)(10,1,2)// output: [10,1,2]
可以看到通过对arguments.length直接赋值, 并不会影响其本身的长度, 这一点和array本身有很大的差别.
PS. 上述示例是增加长度, 其实缩减长度也是一样的, 多余的元素会被自动删除. 所以, 通过直接向array.length赋值也算是一个修改array长度的方法喽~
PSS. 通常如果一个函数接受参数比较多的时候, 为了预防因为参数顺序而产生的问题, 可以采取传json格式的object作为参数, 这样就能够通过key而不根据顺序获取参数了.
Function的property请先看下述代码:
1234567891011f.temp = &quot;test&quot;function f(x)&amp;#123;  console.log(arguments.length);  console.log(arguments.callee.length);  console.log(f.temp);&amp;#125;f(1,2)// output: 2 1 &quot;test&quot;
首先, 我们看一下我们前两个输出值:
  如上所述,arguments.length即代表传入参数的数量, 我们传入了两个参数, 所以这里输出2, 没有任何问题. 那么后面的arguments.callee.length又是什么呢? 为什么它输出的是1呢? 
  根据之前的介绍, 我们当知道arguments.callee是代指当前的函数f(), 那么对应的arguments.callee.length即我们的函数f的length了. 对于Function这个对象而言, 它所拥有的length这一属性特指其声明的参数数量, 我们应该知道JavaScript作为一个很宽松的语言, 其函数定义后接受的参数是不定长的, 即便传入参数与函数声明的参数不相等也是不会抛出异常的, 那么有时候我们需要获取确保函数接受的参数和其声明的参数数量一致, 就可以使用函数自身的length属性来实现;
其次, 我们自定义了一个f的属性temp, 但是我们实在函数定义之前赋予这个属性的, 为什么依然能够在函数运行中输出呢? 
  这主要是因为js的执行顺序所致. js在载入执行过程中, 首先会将内部声明的函数都定义之后才会正式由上至下的逐次执行. 所以这里虽然我们把f.temp写在了函数定义之前, 但是js执行过程中, 还是首先定义了函数f, 接着才开始运行我们的f.temp赋值语句. 自然就不会报错说f没有定义了~
PS. 其实不止是Function, 即便是普通的变量声明, 也是编译和执行分开进行的, 比如var a = 2;也是拆解为var a; a = 2两步执行的, 而声明都是发生在编译过程, 待编译过程全部结束后, 才会由上到下一次执行, 这也是为什么, 单纯的声明可以出现在代码的任意部位都不会影响其所在作用域的生效, 不会爆出not defined的错误;
reserved word, identifier, keyword这三个作为基础知识, 可以说是每门语言都共通的概念,  但很多时候我们都不会用到或者不会特意去区分这三个名词, 而最近因为看原版书, 经常会出现三个词的交叉, 所以这里特别google了以下, 试图总结下三者的区别:

identifier: 通常我们把我们定义的变量名, 函数名, 类名, 标签名,宏定义名, 类型名等称为identifier, 取其标识之意, 用以作为其名称以便代用;
reserved word: 与identifier相对, reserved word则是指由语言规定而保留的一些词, 这些词有着特定的用途而不能被用作identifier;
keyword: 作为语言语法的组成部分之一, keyword通常都会有着特定的含义, 绝大多数的keyword都是reserved word, 但也有少量语法中存在keyword不是reserved word的情况, 比如fortran就没有reserved word的概念, 它的所有keyword都可以用作identifier;

reserved word和keyword确实在很大程度上是共同的, 除了上述说的类似fortran语言这种情况外, 也存在reserved word不是keyword的情况, 比如java中的goto就是一个reserved word, 但本身又不是一个keyword, 所以可以说goto这个词基本在java中是完全废弃的~ 那他们为啥要定义这个goto呢?? 有一种说法是这样情况通常是为未来版本预留的~ 还有一种说法是JVM作者James Gosling最初加了goto的支持, 但后来发现完全没必要, 就又去掉了, 但是为了兼容性问题,也一直没有把goto从reserved word此表中删去.
PS. 很多时候也有人完全不区分reserved word和keyword的区别, 完全等同二者为”不能用来做identifier的词”.
closure - 闭包在javascript中, 一个function由两部分组成: 函数执行的代码以及代码执行的环境. 而这两个组合到一起后也有个专属的名称, 即closure. 不过单独一个独立函数的closure并没有什么值得说的意义, 因为其执行的环境, 即我们称之为scope的东西, 随着函数的执行开始与结束会自动的被创建并清理掉, 所以通常情况下closure都单指在嵌套函数中. 当存在嵌套的函数时, 并且函数之外存在一个reference指向函数的话, 事情就变得好玩多了:
12345678910111213141516171819202122232425262728function f()&amp;#123;  var id = 1;  return function()&amp;#123;console.log(id++)&amp;#125;&amp;#125;f()();f()();f()()// output: 1,1,1// 每次我们调用`f()`,都会自动创建一个包含了其局部变量`id`的对象, 而嵌套的函数`f()()`会自动继承母函数的作用域;// 但每次随着调用结束, 因为没有任何外部引用, 所以创建的对象都会自动的被回收, 如此就导致每次调用`f()()`都会输出1了;var k = f();k();k();k()// output: 1,2,3// 同样是调用`f()`, 但是我们首先引入了一个新的变量`k`引用`f()`函数; // 这样随着`f()`的调用和结束, 其创建的`call`对象(即包含了局部变量id的那个对象)就因为还存在外部引用而得以保留// 所以后面连续调用`k()`的过程中, 本身的嵌套函数就始终共享着`call`对象的作用域, 如此每次输出的时候都是先获取了局部变量id, 然后在执行`id++`,所以输出为1,2,3// 不喜欢`f()()`这种调用方式, 也不想单独创建新变量来增加引用? 当然可以, 只需要借助下`anonymous function`即可:var f = (function()&amp;#123;    var id = 1;    return function()&amp;#123;console.log(id++)&amp;#125;  &amp;#125;)();f();f();f()// output: 1,2,3// `anonymous function`是自执行的函数, 这里相当于把之前的`var k = f()`以及`f()`的声明定义合二为一了.
可以说上述基本就是closure最基本的内容了, 而closure作为js的高级用法之一, 掌握了它, 你就能做很多有意思的操作了. 一个简单的例子就是: 你可以参照closure的原理来模拟实现浏览器探查元素(inspector)的breakpoint功能.
因为原作trimpath上的文章已经无法访问, 所以转载了一个类似的如下, 略作了简单的修改(加了几句更友好的提示和显示每一步的运算结果):
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// This function implements a breakpoint. It repeatedly prompts the user// for an expression, evaluates it with the supplied self-inspecting closure,// and displays the result.  It is the closure that provides access to the// scope to be inspected, so each function must supply its own closure.// // Inspired by Steve Yen's breakpoint() function at// http://trimpath.com/project/wiki/TrimBreakpoint//function inspect(inspector, title) &amp;#123;    var expression, result;    // You can use a breakpoint to turn off subsequent breakpoints by    // creating a property named &quot;ignore&quot; on this function.    if (&quot;ignore&quot; in arguments.callee) return;    while(true) &amp;#123;        // Figure out how to prompt the user        var message = &quot;&quot;;        // If we were given a title, display that first        if (title) message = title + &quot;\n&quot;;        // If we've already evaluated an expression, display it and its value        if (expression) message += &quot;\n&quot; + expression + &quot; ==&amp;gt; &quot; + result + &quot;\n&quot;;        else expression = &quot;&quot;;        // We always display at least a basic prompt:        message += &quot;Enter an expression to evaluate, or just click cancel to see the next step of current calculation.&quot;;        // Get the user's input, displaying our prompt and using the        // last expression as the default value this time.        expression = prompt(message, expression);        // If the user didn't enter anything (or clicked Cancel),        // they're done and so we return, ending the breakpoint.        if (!expression) return;        // Otherwise, use the supplied closure to evaluate the expression        // in the scope that is being inspected.         // The result will be displayed on the next iteration.        result = inspector(expression);    &amp;#125;&amp;#125;function factorial(n) &amp;#123;        var inspector = function(x) &amp;#123;                return eval(x);        &amp;#125;        inspect (inspector, &quot;Entering factorial()&quot;);        var result = 1;        while (n &amp;gt; 1)&amp;#123;                result = result * n;                n--;                inspect(inspector, &quot;factorial() loop with current result:&quot;+result);        &amp;#125;        inspect(inspector, &quot;Exiting factorial()&quot;);        return result;&amp;#125;inspect(function (x) &amp;#123;return eval(x);&amp;#125;, 'Hello')factorial(5)// 通过closure, 它就可以检测factorial执行的各个环节, 从而更容易的找到你在不同环节的问题.
虽然closure让你可以写出更加复杂的js代码, 但是本身closure的使用还是要慎重的, 因为closure需要存储函数对象在内存中而不销毁, 所以如果函数主体庞大, 那么对于内存的压力和运行性能都是会有影响的~
Function constructor类似Array, String等都有着一个对应的类, 可以允许你通过new来创建对象. Function也有自己对应的Function()类, 可以通过:new Function()来创建函数, 其接收不定长参数, 最后一个参数始终作为函数运行主体. 不过通常来说这种方法定义函数远没有我们常用的function关键词来的方便, 所以使用上倒是少了很多~ 不过有几点还是值得注意的:

new ClassFunction() 是把function作为constructor的一种用法, 你可以简单的理解为: var cc = new ClassFunction(params) ==&amp;gt; var cc = new Object();ClassFunction.call(cc,params)
new Function()不接收函数名参数, 即其创建的都是anonymous function;
new Function()不继承作用域, 几遍其是在嵌套函数中定义, 也只继承global域, 不会继承上层函数的作用域;

谜题12345678910111213var name = &quot;The Window&quot;;var object = &amp;#123;  name : &quot;My Object&quot;,  getNameFunc : function()&amp;#123;    console.log(this);    return function()&amp;#123;      return this.name;    &amp;#125;;  &amp;#125;&amp;#125;;console.log(object.getNameFunc()());// output: Object&amp;#123;name:&quot;My Object&quot;&amp;#125;; &quot;The Window&quot;
上述定义中, 为什么嵌套函数没有继承上层函数的this呢? 反而继承了全局的this?
猜测解答: this这个关键字是个比较特殊的关键字, 它具有一个很有趣的特点就是: 当一个函数作为函数而不是方法来调用的时候, this指向的是全局对象, 只有当它是方法的时候, 其指向的才是所属对象; 题目来源阮一峰博客. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript 阅读阶梯清单</title><link>http://taoalpha.me/blog/2015/06/10/read-must-read-list-of-javascript/</link><category>read</category><tag>js</tag><pubDate>2015-06-10T09:00:00.000Z</pubDate><description>缘起今天翻完了Getting Good With JavaScript, 对于其精华浓缩的设计很欣赏, 很适合有一定无基础或者有一定基础但觉得野路子出身想要夯实一下的人读. 而在文末的Appendix A中作者提到的这个 Rey Bango’s Must-Read list of JavaScript 确实在是本书的又一大收获. 特转来分享~
基础入门所谓入门自然是以打牢基础为目的, 所以下列书都是以基础概念为主, 算是领路之书(考虑到国情需要, 我都尽可能替换为豆瓣链接了):

JavaScript: The Good Parts
Professional JavaScript for Web Developers (Wrox Programmer to Programmer)
ppk on JavaScript, 1/e
Beginning JavaScript with DOM Scripting and Ajax: From Novice to Professional (Beginning: from Novice to Professional) 
Eloquent JavaScript

初窥门径一旦你入了门, 就可以修炼中级秘术了~ 可以看到有两条中级秘术和入门级是一样的, 哈 这就和基础功打的够扎实, 基本拳脚也能当秘术使唤的~

Professional JavaScript for Web Developers (Wrox Programmer to Programmer) 
JavaScript: The Definitive Guide 
Eloquent JavaScript - Online 
DOM Scripting: Web Design with JavaScript and the Document Object Model

高手之路一旦确保自己有了一个牢靠的基础后, 我们就可以开启自己的高手之路了.

High Performance JavaScript (Build Faster Web Application Interfaces)
Object-Oriented JavaScript: Create scalable, reusable high-quality JavaScript applications and libraries
JavaScript Patterns
Pragmatic Guide to JavaScript
Pro JavaScript Techniques
JavaScript Rocks
Secrets of the JavaScript Ninja

造物主模式下面这些就是正儿八经的神级模式了… 当你已经把javascript里里外外摸得门清的时候, 就可以试试调整下面的了… 有一种去看汇编原理的感觉了… 开始研究底层源码了…

Standard ECMA-262 ECMAScript Language Specification 3rd edition (December 1999) – PDF File
Standard ECMA-262 ECMAScript Language Specification 5th edition (December 2009)

JS相关blog分享除了书籍之外, 作者还推荐了一些可以订阅查看的博客~ 我根据其目前存活情况, 主题变更情况简单筛选了下(多数都已经失效了)~

DailyJS - 强烈赞同, 很值得订阅!
JavaScript Weekly Newsletter
YUI Theatre
Rey Bango 作者本人哈哈

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (1)</title><link>http://taoalpha.me/blog/2015/06/17/read-reading-javascript-the-definitive-guide-1/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-17T10:00:00.000Z</pubDate><description>概述“JavaScript: the definitive guide”可谓是JS入门必读数目之一了. 今天正好读到第7章, 做一简单总结. 前7章的内容都集中在JS中的基本知识上, 包含了:

数据类型: 最简单的primitive datatypes: string, number, boolean , 两个空值类型: null, undefined(通常认为空值类型属于promitive的一种),以及稍微复杂点的: object类型;
变量问题: 变量规则, 变量作用域问题;
基础表达式和操作符: 操作符的优先级问题, 多操作数和单操作数以及执行顺序等;
陈述语句: 包含了if/for/while/do/with/switch(case)/break/continue/return/var/identifiers/empty statement等等;
Object: json格式object以及常规的array类型对象的分别介绍以及自身结构属性, 异同点等;

心得break/continue 后接 label:  break/continue是通常用于for/white/do等循环语句中用以做状态判断的, 但本身其还有另一种用法, 就是通过后接标记语句的用法来是break或者continue能针对标记语句操作, 比如下面这个跳出多层嵌套的例子:
12345678910test:&amp;#123;  for(var i = 0; i&amp;lt; 10; i++)&amp;#123;    for(var j = 0; j&amp;lt; i*5; j++)&amp;#123;      console.log(j);      if(j==3) break test;    &amp;#125;  &amp;#125;&amp;#125;// continue test; 也是同样的用法
但需要注意的即使:

continue 语句(带有或不带标签引用)只能用在循环中;
break 语句(不带标签引用),只能用在循环或 switch 中;

with 语句在js中经常涉及到变量作用域的问题, 而with语句的存在就是可以将某个object放入到其子语句的作用域链中, 什么意思呢? 首先通常来说, 在函数内, 其作用域链由全局作用域(全局对象)和本地作用域(local对象)组成, 我们在引用变量的时候就是在作用域链上逐个查询. 而with的作用就是把某个object插入到作用域链中去, 从而能够直接访问其子元素:
1234567891011a = &amp;#123;&quot;nae&quot;:&quot;hhh&quot;,&quot;test&quot;:&quot;results&quot;&amp;#125;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;nae = &quot;sl&quot;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;// 证明with引入的作用域甚至还在global域之上
不过呢, 通常很少人会去用with的, 因为它过于吃力不讨好了, 其对性能的影响是没有什么优化空间的, 与其使用with, 不如直接定义全局变量或者变量的简写(有一种with的用法是为了省略书写冗长的变量名)更为方便了.
sort内嵌比较函数:sort()本身作为array类型内置的几个函数之一, 默认通常是按照字母表来排序的, 但是其本身也是支持自定义排序规则的, 只需要我们把规则传入即可:
12345678910// 以数字序列为例var a = [12,3,5,8]a.sort()// output: [12,8,5,3]a.sort(function(a,b)&amp;#123;return a - b;// 返回&amp;lt;0, 则a排在b前面, &amp;gt;0 则b在前面, =0则表示相等;&amp;#125;)// output: [3,5,8,12]
利用这一方法你就可以定制你的排序规则了, 甚至可以按照奇偶性排序都可以做到~ 比如 偶数在前: return a % 2-b % 2; 哈哈
concat,slice,splice这三个函数分别都是对array类型的元素进行母串增减获取子串而出现的, 其中有几点需要注意的:

concat()函数支持数字多参数分别传入, 也支持数组传入的形式, 效果都是一样的, 但是concat()不支持递归解套, 即如果你传入的是多层嵌套的数组, concat()只会解套一次; 此外, concat()的操作是不影响母串的;
slice和splice都可以用于获取子数组使用的, 其区别主要有两点, slice()接受的两个参数都代表的是index, 分别是起始次序到终止元素次序, 取子串时计算首位参数的元素,不计算第二位参数所代表的元素, 而splice则传入的两个参数分别是起始元素次序和要截取元素个数,即同样都是(1,2), 后者代表截取第二个元素起始共计两个元素的子串, 前者则只获取第二个元素; 此外, slice()返回子串而不修改原数组, splice()则会在返回子串的同时修改原数组(原数组为去除子串的结果);
splice()除了可以用获取子串外, 还能用于给母串添加元素. splice()可以接受超过2个参数, 从第三个参数起, 多出来的参数都是作为插入元素的, 执行的顺序则是删减完后当前位置插入, 即splice(2,2,1,3,4)表示的就是删掉第三个元素开始共计两个元素, 然后在同样的位置插入1,3,4三个元素, 同时, splice()也接受数组传入, 但是它不主动进行解套;

除了splice(), 上面的sort()的操作也是针对a数组进行的操作, 其结果也是针对a生效的, 即a的值是会被改变的;
pop,push,shift,unshift除了splice()之外, 我们通常用于直接操作母串增减的就是pop,push,shift,unshift四个了, 下面简单介绍下四者的区别:

pop, push分别代表对母串最后一个元素的进出栈操作, pop是弹出最后一个元素, push则是在最后一个元素的后面继续压入新元素, 同样也支持数组元素压入, 但是不自动解套;
shift, unshift和pop,push基本类似, 不同的地方在于操作的位置和后者相反, 是在栈头的位置, 即首位元素处; shift用于移出首位元素, unshift用于在首位增加元素, 接受数组, 也不自动解套, 同时多参数传入时, 作为整体一次性压入, 即unshift(2,3),压入后为[2,3,...].

这里比较独特的就是unshift多参数的压入问题了, 按我的预期其实是逐个元素压入, 这样顺序就是和传参相反, 但结果确实整体压入, 顺序与传参一致了~
谜题书中第七章介绍说在array中如果直接赋值的index是超限(&amp;gt;2^32-1), 负值或者对应表达式的结果是此类值时, 会自动转为string传入定义, 这就引发了一个问题: 一旦如此定义后, 此变量还是array吗?
我在console中简单的测试了下:
1234567891011121314151617181920var a = [1,2,3]// a.length == 3a[-1.2] = &quot;hehe&quot;a// output: [1,2,3]  where is a[-1.2] ?a[-1.2]// output: &quot;hehe&quot;  WTF???a.length// output: 3 ??console.log(a)// output: [1,2,3,-1.2:'hehe']console.log(a.length)// output: 3a instanceof Array// ouput: Truea[&quot;h&quot;] = &quot;hh&quot;a// output: [1,2,3]console.log(a)// output: [1,2,3,-1.2:&quot;hehe&quot;,h:&quot;hh&quot;]
问题: a依然还是一个Array(亦或者不是?), 但用json定义的方式赋值的那几个值还是有效的, 可获取的, 但是为什么直接print出来的时候没有这些值呢, 甚至长度都不包含定义的这几个指? 为什么console.log()可以打出来呢?
猜测解释: a最初被定义为array, 但是却被json方式传值, 存储到了其内存中, 但是调用a时依然按照array来打印, 所以会自动滤除掉不符合array的几个值(只会按照index来找值). 但是console.log()是打出来其存储内容, 所以就按照其内存存储形式打印出来了.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (3)</title><link>http://taoalpha.me/blog/2015/06/22/read-javascript-the-definitive-guide-3/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-22T04:00:00.000Z</pubDate><description>概述先说点不相关的… 为了更好的阅读, 所以以后读书笔记相关的博文都会分拆成4个部分:

概述: 算是阅读总结摘要以及类似这段话之类的声明介绍等等;
阅读笔记: 这部分主要以阅读过程中的记录为主, 会比较杂, 基本算是逐点记录, 评判相对主观;
心得: 这部分则主要为笔记的延伸, 算是对笔记的一种补充或者说自己的阅读理解消化所得, 有时候也会覆盖到一些使用架桥等等;
谜题: 这里主要记录一些没有完全理解的部分, 会加上自己的猜测解答, 当弄懂后会更新正解;

DONE.
本篇是博主重新翻阅了”JavaScript the Definitive Guide(第六版)”的前4章内容(之前 阅读笔记-2均是第五版的)后的读书笔记以及心得体会. 内容主要覆盖js的基本用法, 考虑到重复, 这里主要是在上两篇的基础上查漏补缺.
阅读笔记Chapter 2 - 基础知识JS能识别的whitespaces:
常规空格: \u0020 # 即url中常见的%20
Tab(制表符): \u0009 # js中常见的\t
Vertical Tab: \u000B # \v
Form Feed(翻页/页码分隔符): \u000C # \f
Nonbreaking Space(不间断空格): \u00A0  # 通常在html中用来阻止默认连续多空格自动归一的性质(auto collapsing)而使用&amp;amp;nbsp;, 同时因为软件处理的需要, 使用&amp;amp;nbsp;能够防止相应的处理器将普通空格转为行分隔;
Byte order mark: \uFEFF
any character in Unicode category Zs

JS能识别的line terminators:
line feed: \u000A # \n
carriage return: \u000D # \r
line separator: \u2028
paragraph separator: \u2029

值得一说的是, js是支持unicode作为indentifier的合法字符的, 但是上述这些则不在其中.
JS的”Unicode Escape Sequences”类似”\u00E9”这种结构的字符在js都代表一种特殊的字符:”unicode”. 如果你在js中使用这些字符, js会自动将其编译为对应的字符(如果是在js的注释中, 则不会编译, 而是以ascii对待), 比如: 示例就会编译为”é”. 而在js中, 这种对等关系是支持的, 即 &amp;quot;\u00E9&amp;quot; === &amp;quot;é&amp;quot;是为真的.
但是一定要慎用… 因为unicode变化过多, 有时候输出看起来一样的字符, 其本质不一定一样: &amp;quot;e\u0301&amp;quot;的输出也是”é”, 但是它相当于是&amp;quot;e&amp;quot;+&amp;quot;\u0301&amp;quot;组成的.
JS中的&amp;quot;;&amp;quot;在JS中, &amp;quot;;&amp;quot;作为语句结尾并不是必须的, 只有当多语句同行的时候, &amp;quot;;&amp;quot;才是必须的. 当你没有&amp;quot;;&amp;quot;的时候, js会自动为你添加合适的&amp;quot;;&amp;quot;. 通常它会自动将它没有&amp;quot;;&amp;quot;无法解析代码时候遇到的换行处加以&amp;quot;;&amp;quot;(除了类似return,break, ++, –等, 它会自动将其后的行分隔符作为&amp;quot;;&amp;quot;对待.):
1234567var aa=3console.log(a)// output: 3// js在第一个换行处识别了其语句分割的意义, 但是在 a = 3 的两个分割处都因为它可以识别合并后的语句所以没有作为`&quot;;&quot;`处理.
但是上述的成功不意味着js的智能, 更多时候如果我们不合适的使用&amp;quot;;&amp;quot;, 会造成很多奇怪的问题的, 比如以(, [, /, +, -为起始的语句很可能会被误认为是前一语句的延续. 所以通常来说, js的编码还是比较鼓励使用&amp;quot;;&amp;quot;作为语句结尾的.
Chapter 3 - 数据类型Number:
Global viriables: Infinity,NaN
Global Objects: Math,Number

Tips:

NaN 具有唯一性, 其不等于任意值, 包括它自己, 0/0会产生’NaN’, 但是0/0 != NaN, 如果需要判断一个变量是不是NaN, 需要使用isNaN()这个内置的函数;
Infinity &amp;lt;==&amp;gt; Number.POSITIVE_INFINITY &amp;lt;==&amp;gt; 1/0
-Infinity &amp;lt;==&amp;gt; Number.NEGATIVE_INFINITY &amp;lt;==&amp;gt; -1/0
Binary Floating-Point会导致小数级错误, 比如0.3-0.2 != 0.2-0.1, 这个属于计算机本身因为二进制编码的原因所致, 所以在比较数字大小的时候要格外小心;

String:
immutable ordered sequence of 16-bit values

Tips:

string的长度都是按照16-bit来计算的, 所以当如果一个字符超过了16-bit, 则会按照多的计算. 比如: e - \ud835\udc52, 就需要按照两个16bit计算, 即其长度应为:”2”
从ECMAScript 5之后就允许string跨行定义了, 只需要在换行的地方加上一个反斜杠\, 即可.
转义字符\如果加在普通字符前, 不会产生任何效果;
typeof null =&amp;gt; Object , typeof undefined =&amp;gt; undefined;
null == undefined, null!==undefined =&amp;gt; True

类型转换javascript是一个很宽松的语言, 我们不需要预先定义变量类型, 而在运算以及执行过程中, js也会自动的帮助我们进行类型转换, 当然为了更好的借助这一特点, 了解下图中的js转换类型的规则还是非常有必要的.

其中object转换 primitive datatype 的话, 一般会按照如下步骤进行:

首先会默认调用toString()函数, 你可以自行定义这一函数, 如果toString()返回结果正常, 则转换结束;
如果toString()未定义, 或者返回结果非primitive datatype的话, 会自动调用valueOf()函数, 同上一步;
而如果两个都没找到, 那么js将会抛出TypeError;

而根据要转换的是string还是number而交换1,2两步( string 的话先调用toString(), 且返回值必然会转为string; 如果是number的话, 则先找valueOf(), 返回结果为number). 当然至于boolean的话, 所有的object转换到boolean都是true.
Array转换string的时候默认的toString()就是一个join()调用~ Function的话, 则也可以自己定义toString()函数.
Tips:

x + “” // Same as String(x)
+x // Same as Number(x). You may also see x-0
!!x // Same as Boolean(x). Note double !
在ECMAScript 5的strict模式下, 所有变量君需要声明才能赋值, 否则会报错;

Chapter 4: Expressions and Operators
上图为按照优先级顺序排列下来的操作符(横线分隔的同一组块之间的级别相同).
Tips:

运算顺序不影响赋值顺序, 赋值顺序始终都是严格从左到右的, 比如:h = x+y+z, 那么赋值顺序始终都是h-&amp;gt;x-&amp;gt;y-&amp;gt;z; 通常情况下, 这一赋值顺序不会影响之后的计算顺序, 对结果基本没什么影响, 除了一种情况:
如果前变量的赋值会影响到后面变量的值的话, 比如共用同一个变量, 那么这种情况下, 赋值顺序就可能会对结果产生一定的影响了. 最简单的例子就是z = 2;y = function(){z = 3;return 1};, 因为y是一个函数, 而它的执行会改变z的值, 所以y()+z和z+y()的结果就是不相同的.

“+”运算符中的类型转换:

string优先, 只要有两个操作数中有一个是string或者是有toString()的object, 那么其都会按照string来进行链接运算;
除非两个都是非string, 才会进行加法运算;
当”+”作为单操作数时, 则意味着将操作数向number类型转换;


&amp;amp;&amp;amp;运算符如果第一个为false, 则不执行第二条判断, 所以可以用这个方法来代替if: (a==b) &amp;amp;&amp;amp; alert(&amp;quot;a equals b&amp;quot;)就相当于if(a==b) alert(&amp;quot;a equals b&amp;quot;).

!(p &amp;amp;&amp;amp; q) === !p || !q
!(p || q) === !p &amp;amp;&amp;amp; !q
a op= b 和 a = a op b通常是等价的, 除非a本身的重复赋值会有副作用, 比如 a[i++] += 1和a[i++] = a[i++] +1就不一样, 因为后者前后两个i不同了.
eval()函数会继承当前的scope, 除非eval()被赋予某个新的reference, 那样的话只会使用global的scope;
void操作数很少用到, 它是个单操作数的操作符, 其用法就是丢弃操作数的返回结果, 然后返回 undefined…

心得whitespaces 和 line terminators通常在js里面我们使用\s来统一代表所有其可以识别的whitespace, line terminators. 如下例:
1234567var k = 'asd \t asdasd \na asd \f asda dad\rasd\u2028asd\u2029\u00A0'k// output 里面有两个换行的符号, 我这里为了演示方便就不换行了k.replace(/\n/g,'-')// 同上,里面的&quot;\r&quot;我也不换行了k.replace(/\s/g,'-')// output: &quot;asd---asdasd--a-asd---asda-dad-asd-asd--&quot;
因为在console中输出的时候是不换行的, 所以有时候单单看console输出的话, 类似这种编码问题所致的错误就找不出来, 为了省事, 我们可以统一使用\s来代表所有此类符号.
谜题Q: 按照正常来说Number.MAX_VALUE加上一个数应该就会自动转为Infinity, 但实际上, 测试过程中发现, 只有当Number.MAX_VALUE加上一个足够大的数后才会等与Infinity, 这是为什么?
1234567Number.MAX_VALUE// output: 1.7976931348623157e+308Number.MAX_VALUE +1// output: 1.7976931348623157e+308...Number.MAX_VALUE + Math.pow(10,1000)// output: Infinity
正解: the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign.

IEEE 754
In the following two rounding-direction attributes, an infinitely precise result with magnitude at least bemax ( b − ½ b^(1-p) ) shall round to ∞ with no change in sign; here emax and p are determined by the destination format (see 3.3). With:

roundTiesToEven: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with an even least significant digit shall be delivered

roundTiesToAway: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with larger magnitude shall be delivered.



ECMAScript does not specify which of the round-to-nearest, but it doesn’t matter here because both gives the same result. The number in ECMAScript is “double”, in which

b = 2
emax = 1023
p = 53,

_so the result must be at least 2^1024 - 2^970 ~ 1.7976931348623158 × 10^308 in order to round to infinity. Otherwise it will just round to MAX_VALUE, because that is the closer than Infinity.Notice that MAX_VALUE = 21024 - 2971, so you need to add at least 2^971 - 2^970 = 2^970 ~ 9.979202 × 10^291 in order to get infinity._
Q: &amp;#39;0&amp;#39; == false 是 true, 为什么 null == false 就是 false呢?
猜测解释: ==这样的是比较value的, 而 null转换为boolean类型为false, 并不意味着两者的value是相同的. ==只会比较value, 而不会进行转换. 也即true, false两个boolean类型的其value也是1,0. 而null和undefined的value则不同, 前者为空, 后者为无.
参考资料:
JavaScript the Definitive Guide 6th edition
Unicode Property
List of Unicode Characters
编码历史介绍

</description><source>TaoAlpha</source><author>TaoALpha</author></item></channel></rss>