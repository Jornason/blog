<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TaoAlpha's Blog</title><link>http://taoalpha.me/blog</link><pubDate>2016-01-16T17:18:53.909Z</pubDate><description></description><language>en</language><generator>hexo</generator><item> <title>Blur on Background</title><link>http://taoalpha.me/blog/2015/12/31/tech-blur-on-background/</link><category>tech</category><tag>Blur,CSS3</tag><pubDate>2015-12-31T08:09:10.000Z</pubDate><description>Today I finally made my first angularJS app which is a simple todo app connected with my First nodejs cli tool: baby. They share the same data set, so you can think it as the UI for baby todo part (I will build the UI for other nice features, one by one).
I really like the interface of the Papaly, especially the speed dial dashboard !! So I also use a large image and the crystal blur block on my design, here I just want to share something with you :)
BlurBlur is quite popular in Web Design, you can see them all the time. But how we do that from the point of coding part ? Before CSS3 introduced the filter, people just modify the images manually and make them blur before actually use them in the design, and now we have CSS3, we can just use filter.
We all know make a image blur is pretty simple, but how we make part of image blur, and even more, how we make part of image blur be dynamic ? This is what I gonna talk about today :)
Without CSS3Let’s do it old fashion first. You want create a box within which all background image should be blur, and also the box may move to any place or even can be moved by users. How to do that? Quite simple, we can use two images, one is normal, the other is blur one. 
Then what you should know is background-attachment which adds the magic.
12345678910111213141516171819202122232425262728293031323334353637383940/* background-attachment can specify the position of the background image * fixed : the background is fixed with regard to the viewport, so it won't move with the element * background-attachment: fixed; * background-size:100%; * keep size 100% to fit the viewprot */html,body&amp;#123;  width:100%;  height:100%;  margin:0px;&amp;#125;.imgBlur&amp;#123;  width:100%;  height:100%;  margin:auto;  background-image:url(&quot;http://www166.lunapic.com/editor/premade/o-blur.gif&quot;);// image without blur  background-size:100%;&amp;#125;div.blurBox&amp;#123;  width:50%;  margin:auto;  height:200px;  color:white;  padding:30px;  text-align:center;  display:table;&amp;#125;div.blurBox.withoutcss3&amp;#123;  background-attachment:fixed;  background-size:100%;  background-image:url(http://www166.lunapic.com/editor/premade/blur.gif);// image with blur   display:none;&amp;#125;.blurBox span&amp;#123;  display:table-cell;  vertical-align:middle;&amp;#125;
With CSS3With CSS3, we don’t need the second image, we can just use blur.
123456789101112131415161718192021/* z-index is to make sure the content of the box won't be blur */div.blurBox.withcss3&amp;#123;  z-index:1;&amp;#125;div.blurBox.withcss3:before&amp;#123;  width:100%;  display:block;  content:&quot; &quot;;  height:100%;  background-image:url(http://www166.lunapic.com/editor/premade/o-blur.gif);  // now we don't need blur image  background-attachment:fixed;  // still need this since we need use the blur on the image  position: absolute;  background-size:100%;   -webkit-filter: blur(3px);  filter:blur(3px);  z-index:-1;&amp;#125;
Here is the demo I made with codepen:
See the Pen LGbajd by taoalpha (@taoalpha) on CodePen.


Advance SkillsPretty cool ha! Combine with before and after and other cool stuffs,  you can achieve a lot amazing effects, even this one : Depth of field effect with SVG filters
See the Pen Depth of field effect with SVG filters by Vaughan Curd (@vcurd) on CodePen.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Add a reading progressbar to your blog</title><link>http://taoalpha.me/blog/2016/01/16/tech-add-a-reading-progressbar-to-your-blog/</link><category>tech</category><tag>JS,progressbar</tag><pubDate>2016-01-16T21:37:42.000Z</pubDate><description>Yesterday, I added airbnb blog to my subscriptions, and found an interesting feature on this blog: when you scroll down, there will be a progressbar on the top of the page showing the progress of your reading on this post. So I just added it to my blog :)
Actually the logic is pretty simple, you calculate the distance you have scroll down, and then divided by the height of your post area, fixed with some margins and offset, added some styles and html, you will get your own reading progressbar :) I don’t know whether airbnb using this method or not since I didn’t look their code…
1234567891011121314151617181920212223// with jQuery( () =&amp;gt; &amp;#123;  $(window).scroll( () =&amp;gt; &amp;#123;    // listen to the scroll event    if(window.scrollY &amp;gt; 220)&amp;#123;      // the distance between the top of the document and start of your post area, only show when you actually start reading :)      var percentage = Math.ceil( ( (window.scrollY - 200 + $(window).height()) / $('section.entry').height() )*100 )      // calculate the percentage of reading, here I minus the distance at the top but add the height of your screen to make sure it will hit 100 when scroll down to the bottom      if(percentage&amp;lt;=100)&amp;#123;        // show and update the progressbar        $('div#progressbar').fadeIn(300).find('span.text').text(percentage+&quot;% READ&quot;)        $('div#progressbar').fadeIn(300).find('span.bg').css(&amp;#123;width:percentage+&quot;%&quot;&amp;#125;)      &amp;#125;      // hide it when read 100%      if(percentage &amp;gt;= 100)&amp;#123;        $('div#progressbar').fadeOut(300)      &amp;#125;    &amp;#125;else&amp;#123;      // hide if you scroll up to the top      $('div#progressbar').fadeOut(300)    &amp;#125;  &amp;#125;)&amp;#125;)()
And then you just need a html snippet like this on your post page and add your own styles for them:
1div#progressbar&amp;#10;  span.bg&amp;#10;  span.text
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Substring Questions 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-substring-questions-1/</link><category>OJ</category><tag>LeetCode,Substring</tag><pubDate>2016-01-16T06:52:31.000Z</pubDate><description>3. Longest Substring Without Repeating CharactersQuestionGiven a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.
LeetCode3. Longest Substring Without Repeating Characters
Tags: Medium, String, Two Pointers, Hash Table
AnswersHash TableAf first, my idea is use a hashmap as a view window to tract all the letters of current substring, and everytime we found the repeated one, we just move the loop pointer to the last position of this repeated character, and continue looping to the end. But apparently it will cost much more than O(n) for the average case. So then I thought I don’t need the move the loop pointer back, just need a new pointer to indicate the start of the substring, and if I do that, I couldn’t empty the view window which is the hashmap since I will lose tract of the elements between the start and i, so I keep all elements in the hashmap, just make sure every valid repeated character is appeared after the current start pointer.
Here is the code:
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  if(s.length &amp;lt;=0)&amp;#123;return 0&amp;#125;  var view = &amp;#123;&amp;#125;, // store the current substring      max = 0, // store the max length      start = 0 // store the start of the current substring  for(var i = 0;i&amp;lt;s.length;i++)&amp;#123;    if(view[s[i]] &amp;amp;&amp;amp; view[s[i]] &amp;gt; start)&amp;#123;      max = Math.max(max,i-start)      // now we have a repeated element appeared in current substring      start = view[s[i]]    &amp;#125;    view[s[i]] = i+1  &amp;#125;  // in case no repeated element in this string  max = Math.max(max,i-start)  return max&amp;#125;;
Runtime: 376 ms
DPThis method is borrow from the discussion shortest O(n) DP solution with explanations. More concise!
12345678910111213141516171819202122232425262728293031323334353637/** * Solution (DP, O(n)): *  * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &amp;lt;character, index&amp;gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap *    we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k *    let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update *    entry in hashmap to mark the latest occurency of s[i+1]. *  * Since we scan the string for only once, and the 'm' will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. *//** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  var charIndex = &amp;#123;&amp;#125;  var longest = 0, m = 0;  for (var i = 0; i &amp;lt; s.length; i++) &amp;#123;    m = Math.max((typeof charIndex[s[i]] === &quot;undefined&quot; ? -1:charIndex[s[i]]) + 1, m);    // automatically takes care of -1 case    charIndex[s[i]] = i;    longest = Math.max(longest, i - m + 1);  &amp;#125;  return longest;&amp;#125;
Runtime: 376
5. Longest Palindromic SubstringQuestionGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
LeetCode5. Longest Palindromic Substring
Tags: Medium, String
Answerstwo pointersWe need to take advantage of the features of the palindrom: xxx|xxx which is start from the separator, it is symetric.
12345678910111213141516171819202122232425262728/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s  var start = 0,end = 1;  for(var i = 0;i&amp;lt;s.length;)&amp;#123;    if(s.length - i &amp;lt;= (end-start+1)/2) break; // if the number of elements left is less than half of length of current longest palindrome, then we can break safely    var left = i, right = i; // left is from separator to left; vice versa for right    // skil the duplicate number, set all duplicate numbers as the separator of the palindrom since duplicate numbers definitely are palindrom     while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; s[right] == s[right+1]) right ++ ;    // update the i to the right next to right, no need to loop the duplicate number    i = right + 1    // now expand the left and right, try to enlarge the palindrom    while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; left &amp;gt;0 &amp;amp;&amp;amp; s[left-1] == s[right+1])&amp;#123;      // be careful about the condition in there: use &amp;lt; and &amp;gt; because maybe have 'bbb', so the s[left-1] and s[right+1] both are undefined, and they are equal...      left --      right ++    &amp;#125;    // update the longest if it is    if((right - left +1) &amp;gt; (end - start))&amp;#123;      start = left      end = right + 1    &amp;#125;  &amp;#125;  return s.slice(start,end)&amp;#125;;
Runtime: 164 ms
Brute Force CheckBasic idea is loop over entire string, and everytime we loop to a new character, we check whether it would produce new palindrome of (current length + 1) or (current length + 2). From this post
123456789101112131415161718192021222324252627/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s;  var subs = '', currentLength = 1;  for(var i = 1;i&amp;lt;s.length;i++)&amp;#123;    if(isPalindrome(s,i-currentLength-1,i))&amp;#123;      //       subs = s.slice(i-currentLength-1,i+1)      currentLength += 2    &amp;#125;else if(isPalindrome(s,i-currentLength,i))&amp;#123;      subs = s.slice(i-currentLength,i+1)      currentLength += 1    &amp;#125;  &amp;#125;  return subs&amp;#125;var isPalindrome(s,begin,end) =&amp;gt; &amp;#123;  if(begin&amp;lt;0) return false;  while(begin &amp;lt; end)&amp;#123;    if(s[begin++] !== s[end--]) return false;  &amp;#125;  return true&amp;#125;
Runtime: 188 ms
And the detail explanations:

Example: “xxxbcbxxxxxa”, (x is random character, not all x are equal) now we are dealing with the last character ‘a’. The current longest palindrome is “bcb” with length 3.

check “xxxxa” so if it is palindrome we could get a new palindrome of length 5.
check “xxxa” so if it is palindrome we could get a new palindrome of length 4.
do NOT check “xxa” or any shorter string since the length of the new string is no bigger than current longest length.
do NOT check “xxxxxa” or any longer string because if “xxxxxa” is palindrome then “xxxx” got  from cutting off the head and tail is also palindrom. It has length &amp;gt; 3 which is impossible.’


Really smart!!!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode NSum Problem</title><link>http://taoalpha.me/blog/2016/01/13/oj-oj-leetcode-nsum/</link><category>OJ</category><tag>HashTable,LeetCode</tag><pubDate>2016-01-14T01:19:20.000Z</pubDate><description>1. Two SumQuestionGiven an array of integers, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution.
Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2
LeetCode1. 2Sum
Tags: Array, Hash Table
AnswersIndexOfBefore we think about hashtable, the more strightforward idea is that we subtract the current number from the target and then check whether the result is in the rest of the list or not.
12345678910111213/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var secondIndexOffset = nums.slice(i+1,nums.length).indexOf(target - nums[i])    if(secondIndexOffset&amp;gt;-1)&amp;#123;      return [i+1,i+secondIndexOffset+2]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 456 ms
Or we use while to save some time:
123456789101112131415/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        return [i+1,j+1]      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 336 ms
hashtableThe previous answer can solve the problem but it is too slow, it is O(n^2) way too slow. We need to speed it up.
Since we can assume each input would have exactly one solution which means that there should not have duplicate number in the nums or the duplicate numbers wouldn’t affect the result, so we can use a hashtable store all the numbers and the index of them to speed up the process.
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var mapper = &amp;#123;&amp;#125;  for(var i =0;i&amp;lt;nums.length;i++)&amp;#123;    mapper[nums[i]] = i+1  &amp;#125;  for(i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var remain = target - nums[i]    if(mapper[remain] &amp;amp;&amp;amp; mapper[remain] -1 !== i)&amp;#123;      return [i+1,mapper[remain]]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 140 ms
Personal Follow Upif we can not assume that each input would have exactly one solution, then how to solve it?
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = []  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(i,j)      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
If we want get all possible and no duplicate combinations(using values instead of indices) of two sum:
1234567891011121314151617181920212223242526272829/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var i = 0, j = nums.length-1  var output = []  nums.sort( (a,b)=&amp;gt; a - b)  while(i&amp;lt;j)&amp;#123;    if(nums[i]+nums[j] == target)&amp;#123;      output.push([nums[i],nums[j]])      i ++      j --      // remove the duplicate values      while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;        i++      &amp;#125;      while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;        j--      &amp;#125;    &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;      j --     &amp;#125;else&amp;#123;      i ++    &amp;#125;  &amp;#125;  return output&amp;#125;
Use hash table:
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = [],nnums = [],amapper = &amp;#123;&amp;#125;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    if(!amapper[nums[i]])&amp;#123;      nnums.push(nums[i])      amapper[nums[i]] = 1    &amp;#125;else&amp;#123;      amapper[nums[i]] ++    &amp;#125;  &amp;#125;  // build the hash of all elements and remove the duplicates  // store all possible combinations  for(var i = 0;i&amp;lt;nnums.length;i++)&amp;#123;    for(var j = i+1;j&amp;lt;nnums.length;j++)&amp;#123;      var sum = nnums[i]+nnums[j]      if(sum == target)&amp;#123;        output.push([nnums[i],nnums[j]])      &amp;#125;    &amp;#125;  &amp;#125;  // consider about the special case that two sub elements are same  if(amapper[target/2] &amp;gt;=2)&amp;#123;output.push([target/2,target/2])&amp;#125;  return output&amp;#125;
Compared with the two pointers method, this one would be a little slower - test with replacing this one with previous one in the findNSum function below.
18. 4SumQuestionGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d). The solution set must not contain duplicate quadruplets.
For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
LeetCode18. 4Sum
Tags: Array, Hash Table, Two Pointers, Medium
Answersreduce to 2Sum123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[][]&amp;#125; */var fourSum = function(nums, target) &amp;#123;  // sort  nums.sort( (a,b)=&amp;gt; a - b)  var output = []  findNSum(nums,target,4,[],output)  return output&amp;#125;;var findNSum = (nums,target,N,result,output)=&amp;gt;&amp;#123;  // base exit case  if(nums.length &amp;lt; N || N &amp;lt; 2) return  // 2Sum like before but don't need to sort the list again  if(N==2)&amp;#123;    // can replace below with any one of these 2Sum ways    var i = 0, j = nums.length-1    while(i&amp;lt;j)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(result.concat([nums[i],nums[j]]))        i ++        j --        // remove the duplicate values        while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;          i++        &amp;#125;        while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;          j--        &amp;#125;      &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;        j --       &amp;#125;else&amp;#123;        i ++      &amp;#125;    &amp;#125;  &amp;#125;else&amp;#123;    for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;      if(i==0 || (i&amp;gt;0 &amp;amp;&amp;amp; nums[i-1] != nums[i]))&amp;#123;        // recursively call findNSum        findNSum(nums.slice(i+1,nums.length), target-nums[i],N-1,result.concat([nums[i]]),output)      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 328 ms
Since the nums is sorted, we can use pruning during the for loop to save a lot of time:
12// add this within the for loop before the recursionif(nums[i]*N &amp;gt; target || nums[nums.length-1]*N &amp;lt; target) break
Runtime: 228
Using Hash TableThink about using the hashtable store all value of two pairs, and then treat it like a twoSum problem, but will use a lot space.
SummaryAll NSum problems can be solved by the same way.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Dynamic scheduling crawler for FeedPusher</title><link>http://taoalpha.me/blog/2016/01/12/tech-dynamic-scheduling-crawler-for-feedpusher/</link><category>tech</category><tag>Crawler,FeedPusher,NodeJS</tag><pubDate>2016-01-12T08:12:44.000Z</pubDate><description>As I promised, I have been working on refactoring the feedpusher with pure JS/nodeJS from last week. Now I have set up the basic database struture and spider which has already been running for one week with 80 sites and 8k feeds stored into my mongodb on raspberry pi.
Today, I jsut set up a new process to crawl the updates which I called dynamic scheduling which means now the spider can decide whether this site needs to be recrawled this time or not by itself. Why? Most important reason is that as the number of sites goes bigger, the time it crawles all sites is longer, and also crawl every site everytime is not a good way.
Now I will explain how I do that with nodeJS.
TheoryOur purpose is let the spider decide when to crawl a specific website/rss link, or in another word, everytime the spider runs, it needs to decide which website should be recrawled this time.
What data I haveNow I have and I can store some data into my database that may be good for this purpose, but we want to use as few as possible, so I decide to use these two attributes:

lastCrawled: time I last crawled this website;
updateDuration: the duration between two continuous crawl of this site;

Dynamic SchedulingThe lastCrawled is pretty simple and we don’t have a lot things can do with it. But the updateDuration is the core of the dynamic scheduling, since we can increase it and tell the spider that this site needs a longer duration before next crawling and vice versa.
So the basic idea is:
The larger the updateDuration is, the longer the website get recrawled.
Rules
When to crawl: if current time minus the time lastCrawled is longer than the updateDuration, then the website needs to be recrawled;
Motivate: if this round of crawling got any updates(new feeds) of this website, then we decrease the updateDuration of this website which is like motivating this website because of the updates;
Penalize: if this round of crawling got no updates(new feeds) of this website, then we increase the updateDuration of this website which is like penalizing this website because of the later update than expected;

ResultsBased on these simple rules, the updateDuration of one site would be dynamic changing and will reflect the frequency of a website updates in some level.
CodingThe coding part is pretty stright forward, but since the spider need get a lot of data from the mongodb, so you might need a lot promises to make sure the order of different processes is under your control.
I will put the Pseudocode here, if you are interested in the real code, you can check my feedpusher code refactoring repo :)
PseudocodeThis is not a real pseudocode… but I believe you can bare with that :)
1234567891011121314151617181920212223242526272829303132333435363738394041424344// feed is the object of my core class I used for this spiderfeed.db.open((err, db) =&amp;gt;&amp;#123;  // connect with database  var allSites = [] // store all sites we crawled this time in order to update the lastCrawled and updateDuration later  // find all sites from the database  feed.findAllSites().then((data) =&amp;gt; &amp;#123;    var curTime = moment()    // Need use promise to make sure all finished before you update the lastCrawled and updateDuration    return Promise.all(data.filter( (v) =&amp;gt; &amp;#123;      // filter all sites that the time from lastCrawled has passed the updateDuration      return (((curTime - moment(v.lastCrawled)) / 3600 / 1000) &amp;gt; v.updateDuration)    &amp;#125;)    .map( (v) =&amp;gt;&amp;#123;      // crawl and store each feedUrl which is the link of the rss      allSites.push(v.feedUrl)      return feed.crawler(v.feedUrl)    &amp;#125;) )  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    // update the lastFCrawled for all sites    return feed.updateCrawled(allSites)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at crawler&quot;)    console.log(reason)    db.close()  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    console.log(feed.stats)    feed.updateDuration(allSites).then( () =&amp;gt; &amp;#123;      // Now update the updateDuration for all sites      db.close()    &amp;#125;,(reason)=&amp;gt;&amp;#123;      console.log(&quot;Broken at updatedDuration&quot;)      console.log(reason)      db.close()    &amp;#125;)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at updatedCrawled&quot;)    console.log(reason)    db.close()  &amp;#125;)&amp;#125;)
Yup! currently it works pretty good! :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>ES6 Quiz With Answer</title><link>http://taoalpha.me/blog/2016/01/11/tech-es6-quiz-with-answer/</link><category>tech</category><tag>ES6,JS,Quiz</tag><pubDate>2016-01-11T08:15:24.000Z</pubDate><description>Origin Post
@kangax’s ES6 quiz, explained@kangax created a new interesting quiz, this time devoted to ES6 (aka ES2015). I found this quiz very interesting and quite hard (made myself 3 mistakes on first pass).
Here we go with the explanations:
Question 1:123456(function(x, f = () =&amp;gt; x) &amp;#123;  var x;  var y = x;  x = 2;  return [x, y, f()];&amp;#125;)(1)

[2, 1, 1]
[2, undefined, 1]
[2, 1, 2]
[2, undefined, 2]

The most complex question for me in this quiz. I didn’t get it right initially until read the spec and clarified with @kangax. First I answered [2, undefined, 1], which is “almost correct”, except one subtle thing. The correct answer here is the first one, [2, 1, 1], and let’s see why.
As we know, parameters create extra scope in case of using default values.
Parameter f is always the function (the default value, since it’s not passed), and it captures x exactly from the parameters scope, that is 1.
Local variable x shadows the parameter with the same name, var x;. It’s hoisted, and is assigned default value… undefined? Yes, usually it would be assigned value undefined, but not in this case, and this is the subtle thing we mentioned. If there is a parameter with the same name, then the local binding is initialized not with undefined, but with the value (including default) of that parameter, that is 1.
So the variable y gets the value 1 as well, var y = x;.
Next assignment to local variable x happens, x = 2, and it gets value 2.
By the time of the return, we have x is 2, y is 1, and f() is also 1. It’s also a tricky part: since f was created in the scope of parameters, its x refers to the parameter x, which is still 1.
And the final return value is: [2, 1, 1].

Question 2:123456(function() &amp;#123;  return [    (() =&amp;gt; this.x).bind(&amp;#123; x: 'inner' &amp;#125;)(),    (() =&amp;gt; this.x)()  ]&amp;#125;).call(&amp;#123; x: 'outer' &amp;#125;);

[‘inner’, ‘outer’]
[‘outer’, ‘outer’]
[undefined, undefined]
Error

Arrow functions have lexical this value. This means, they inherit this value from the context they are defined. And later it stays unchangeable, even if explicitly bound or called in a different context.
In this case both arrow functions are created within the context of {x: &amp;#39;outer&amp;#39;}, and .bind({ x: &amp;#39;inner&amp;#39; }) applied on the first function doesn’t make difference.
So the answer is: [&amp;#39;outer&amp;#39;, &amp;#39;outer&amp;#39;].

Question 3:1let x, &amp;#123; x: y = 1 &amp;#125; = &amp;#123; x &amp;#125;; y;

undefined
1
{ x: 1 }
Error

Variable y will eventually have value 1 since:
First, let x defines x with the value undefined.
Then, destructuring assignment { x: y = 1 } = { x } on the right hand side has a short notation for an object literal: the {x} is equivalent to {x: x}, that is an object {x: undefined}.
Once it’s destructured the pattern { x: y = 1 }, we extract variable y, that corresponds to the property x. However, since property x is undefined, the default value 1 is assigned to it.
So the answer is: 1.

Question 4:1234567(function() &amp;#123;  let f = this ? class g &amp;#123; &amp;#125; : class h &amp;#123; &amp;#125;;  return [    typeof f,    typeof h  ];&amp;#125;)();

[“function”, “undefined”]
[“function”, “function”]
[“undefined”, “undefined”]
Error

This IIFE is executed with no explicit this value. In ES6 it means it will be undefined (the same as in strict mode in ES5).
So the variable f is bound to the class h {}. Its typeof is a &amp;quot;function&amp;quot;, since classes in ES6 is a syntactic sugar on top of the constructor functions.
However, the class h {} itself is created in the expression position, that means its name h is not added to the environment. And testing the typeof h should return &amp;quot;undefined&amp;quot;.
And the answer is: [&amp;quot;function&amp;quot;, &amp;quot;undefined&amp;quot;].

Question 5:1(typeof (new (class &amp;#123; class () &amp;#123;&amp;#125; &amp;#125;)))

“function”
“object”
“undefined”
Error

This is an obfuscated syntax playing, but let’s try to figure it out :)
First of all, since ES5 era, keywords are allowed as property names. So on a simple object example, it can look like:
123let foo = &amp;#123;  class: function() &amp;#123;&amp;#125;&amp;#125;;
And ES6 standardized concise method definitions, that allows dropping the : function part, so we get the:
123let foo = &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
This is exactly what corresponds to the inner class () {} – it’s a method inside a class.
The class itself is anonymous, so we can rewrite the example:
12345let c = class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;new c();
Now, instead of assigning to the varialbe c, we can instantiate it directly:
123new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
The result of a default class is always a simple object. And its typeof should return &amp;quot;object&amp;quot;:
123typeof (new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;);
And the answer is: &amp;quot;object&amp;quot;.

Quetion 6:1typeof (new (class F extends (String, Array) &amp;#123; &amp;#125;)).substring

“function”
“object”
“undefined”
Error

Here we have a similar obfuscated example (but we already figured out this inlined typeof, new, and class thing above ;)), though the interesting part is the value of the extends clause. It’s the: (String, Array).
The grouping operator always returns its last argument, so the (String, Array) is actually just Array.
So what we’ve got here is:
12345class F extends Array &amp;#123;&amp;#125;let f = new F();typeof f.substring; // &quot;undefined&quot;
Since array instances do not have substring method, and our extended class F didn’t provide it either, the answer is &amp;quot;undefined&amp;quot;.

Question 7:1[...[...'...']].length

1
3
6
Error

Here we deal with the spread operator. It allows to spread all the elements to the array. It can work with any iterable object.
Strings are iterable, meaning that we can iterate over their chars (in this case char by char). So the inner [...&amp;#39;...&amp;#39;] results to an array: [&amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;]:
12345let s = '...';let a = [...s];console.log(a); // ['.', '.', '.']
Array are iterable as well. So the outer spread is applied on our new array:
1234let result = [...a];console.log(result); // ['.', '.', '.']console.log(result.length); // 3
As we can see spreading the array happens element by element, so the resulting array just copied all the elements, and looks the same – with just 3 string dots.
And the answer is: 3.

Question 8:1typeof (function* f() &amp;#123; yield f &amp;#125;)().next().next()

“function”
“generator”
“object”
Error

In this example we encounter a generator function. When executed, they return a generator object:
1let g = (function* f() &amp;#123; yield f &amp;#125;)();
Generator objects have next method, that returns the next value at the yield position. The returned value has iterator protocol format:
1&amp;#123;value: &amp;#60;returned value&amp;#62;, done: boolean&amp;#125;;
So on first next() we get:
1g.next(); // &amp;#123;value: f, done: false&amp;#125;
As we see, the returned value itself doesn’t have method next(), so trying to call it as a chain would result to an error:
1g.next().next(); // error
Notice though, that we could normally call it as:
12g.next(); // &amp;#123;value: f, done: true&amp;#125;g.next(); // &amp;#123;value: undefined, done: true&amp;#125;
So the answer is: Error.

Question 9:1typeof (new class f() &amp;#123; [f]() &amp;#123; &amp;#125;, f: &amp;#123; &amp;#125; &amp;#125;)[`$&amp;#123;f&amp;#125;`]

“function”
“undefined”
“object”
Error

The obfuscated example results to a Syntax Error since class name f() is not correct.
The answer is Error.

Question 10:1typeof `$&amp;#123;&amp;#123;Object&amp;#125;&amp;#125;`.prototype

“function”
“undefined”
“object”
Error

This one is very tricky :)
First, we deal with template strings.
They are capable to render values of variables directly in the strings:
123let x = 10;console.log(`X is $&amp;#123;x&amp;#125;`); // &quot;X is 10&quot;
However, in the example we have something that looks a bit strange: it’s not ${Object} how it “should be”, but the $.
No, it’s not another special syntax of template strings, it’s still a value inside ${}, and the value is {Object}.
What is {Object}? Well, as we mentioned earlier above, ES6 has short notation for object literals, so in fact it’s just the: {Object: Object} – a simple object with the property named &amp;quot;Object&amp;quot;, and the value Object (the built-in Object constructor).
Now it’s becoming more clear:
1234let x = &amp;#123;Object: Object&amp;#125;;let s = `$&amp;#123;x&amp;#125;`;console.log(s); // &quot;[object Object]&quot;
See what’s happened? The ${x} is roughly equivalent to the:
12345'' + x;// or the same:x.toString(); // &quot;[object Object]&quot;
Now, the string &amp;quot;[object Object]&amp;quot; obviously doesn’t have property prototype:
123&quot;[object Object]&quot;.prototype; // undefinedtypeof &quot;[object Object]&quot;.prototype; // &quot;undefined&quot;
So the answer is: &amp;quot;undefined&amp;quot;.

Question 11:1((...x, xs)=&amp;gt;x)(1,2,3)

1
3
[1,2,3]
Error

This one is the simplest. Rest parameters can appear only at the last postion. In this case ...x goes as a first argument of an IIFE arrow function, so results to a Parse Error.
And the answer is: Error.

Question 12:12345let arr = [ ];for (let &amp;#123; x = 2, y &amp;#125; of [&amp;#123; x: 1 &amp;#125;, 2, &amp;#123; y &amp;#125;]) &amp;#123;  arr.push(x, y);&amp;#125;arr;u

[2, { x: 1 }, 2, 2, 2, { y }]
[{ x: 1 }, 2, { y }]
[1, undefined, 2, undefined, 2, undefined]
Error

Several topics combined here: destructuring assignment, default values, and for-of loop.
However, we can quickly identify it’s an error, because of two one thing:
EDIT 1: @fkling42 pointed out that the variable y is in the environment, but is not initialized yet (being under TDZ – Temportal Dead Zone), and that’s the reason why it cannot be accessed
EDIT 2: @getify pointed out, that value 2 actually normally passes RequireObjectCoercible check, and hence there would be no error in destructuring let { x = 2, y } = 2;.

{ y } is a short notation of {y: y} and will fail, since variable y doesn’t exist in the scope; The variable y is in the scope, but is under TDZ, so cannot be accessed
(we wouldn’t reach this, because of the frist error, but): trying to destructure 2 will fail too will not fail, since to object coercion will be normally applied.

So the answer is: Error.

Question 13:123456(function() &amp;#123;  if (false) &amp;#123;    let f = &amp;#123; g() =&amp;gt; 1 &amp;#125;;  &amp;#125;  return typeof f;&amp;#125;)();

“function”
“undefined”
“object”
Error

This example is only on attention, since it’s a syntax error: the arrow function =&amp;gt; cannot be defined in this way, since we have a an object with the g (consice) method.
And the answer is: Error.

ConclusionI like such tricky quiz questions, it’s always fun to track the runtime semantics and parsing process manually. Of course, most of the things here are far from practical production code, and are interesting mostly from the theoretical viewpoint. Still I found it enjoyable.
I’ll be glad to discuss all the questions in the comments.
Good luck with ES6 ;)
Written by: Dmitry Soshnikov
http://dmitrysoshnikov.com
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Scalable and Modular Architecture for CSS</title><link>http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/</link><category>read</category><tag>CSS,Modularity,SMACSS</tag><pubDate>2016-01-11T00:13:50.000Z</pubDate><description>Modularity of Web DevAs your project becomes more complex, its more difficult to maintain the code, no matter what kind of language you are using. That’s why we use OOP for most of the projects, by doing that, it saves you a lot of time and energy. Since web development becomes more popular, more and more people start focusing on this area and come up with some fantastic ideas about how to apply modularity or OOP on web development.
We all know that a basic website would contains three basic parts: HTML/CSS/JS. HTML is in charge of the struture, the CSS will focus on the appearance, and JS will give your website more animation(now css can do that too) and interaction. Among all these three parts, HTML is the easiest one, there is not so many things to talk about except the semantic tag, H5..etc, if you want to improve the modularity, most times HTML is not what you care most. Instead, CSS and JS are your primary concern.
Scalable and Modular Architecture for CSS is a nice book focus on applying modularity to CSS, and here is the notes I wrote down after I read it. About JS, we will talk about it later :) You can start with a nice and good coding style.
Reading NotesCategories of RulesJonathan Snook groups CSS rules into five types of categories:

Base: Base rules are the defaults. They are almost exclusively single ele- ment selectors but it could include attribute selectors, pseudo-class selectors, child selectors or sibling selectors. Essentially, a base style says that wherever this element is on the page, it should look like this;
You can use some reset frameworks out there, just be sure you know everything it does before you actually put it in your project;


Layout: Layout rules divide the page into sections. Layouts hold one or more modules together;
Generally, a Layout style only has a single selector: a single ID or class name;
Sometimes, you may have different layouts base on different settings like user preference, then you can use more than one selectors;


Modules: Modules are the reusable, modular parts of our design. They are the callouts, the sidebar sections, the product lists and so on;
Each Module should be designed to exist as a standalone component;
Avoid using IDs and ele- ment selectors, sticking only to class names;
Only include a selector that includes semantics. A span or div holds none. A heading has some. A class defined on an element has plenty;
If you do wish to use an element selector, it should be within one level of a class selector;


State rules: State rules are ways to describe how our modules or layouts will look when in a particular state. Is it hidden or expanded? Is it ac- tive or inactive? They are about describing how a module or layout looks on screens that are smaller or bigger. They are also about de- scribing how a module might look in different views like the home page or the inside page;
A state is something that augments and overrides all other styles;
States should be made to stand alone and are usually built of a single class selector, sometimes you can use !important to address the state;
In a case where a state rule is made for a specific module, the state class name should include the module name in it;


Theme rules: Theme rules are similar to state rules in that they describe how modules or layouts might look. Most sites don’t require a layer of theming but it is good to be aware of it;
Focus on general appearance of your website like colors, borders etc;



And also using proper name for different categories can be beneficial for immediately understanding which category a particular style belongs to and its role within the overall scope of the page. Here is a simple example:
123456789101112/* Example Module */.example &amp;#123; &amp;#125;/* Callout Module */.callout &amp;#123; &amp;#125;/* Callout Module with State */.callout.is-collapsed &amp;#123; &amp;#125;/* Form field module */.field &amp;#123; &amp;#125;/* jsExample is a subclass or variation of example */.example-jsExample &amp;#123; &amp;#125;/* Inline layout  */.l-inline &amp;#123; &amp;#125;
Tips
Minimizing the Depth: The depth of applicability is the number of generations that are affected by a given rule;
Two Goals of SMACSS: Increase semantics and decrease reliance on specific HTML;
How to separate the files in your project:
Place all Base rules into their own file;
Depending on the type of layouts you have, either place all of them into a single file or major layouts into separate files;
Put each module into its own file;
Depending on size of project, place sub-modules into their own file;
Place global states into their own file;
Place layout and module states, including media queries that affect those layouts and modules, into the module files;


Organize styles in the following order:
Box: display, float, position, left, top, height, width…
Border: border;
Background: background;
Text: font-family, font-size, text-transform, letter-spacing…
Others: others;


Be Consistent;

SummaryThis book is pretty short with all valueable content. Strongly recommend after you get familiar with all basic css concepts.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (2)</title><link>http://taoalpha.me/blog/2015/06/18/read-javascript-the-definitive-guide-2/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-18T10:00:00.000Z</pubDate><description>概述作为JS中的一等公民, function(函数)始终是JS的核心中的核心. 所以这里单独用一篇笔记来记录JavaScript: the definitive Guide一书第八章的内容. 主要介绍了函数的定义, 作用域, 参数, 声明以及执行等基础知识, 另外也着重介绍了其高级用法中的closure. 我将自己觉得重要的, 值得记录的部分都作为心得摘抄如下:
心得arguments对象对每一个function而言, 都自动会有一个内置的arguments对象, 用它就可以访问传入的参数了. 通常来说arguments对象我们只会用在不定长传参的函数上, 但arguments本身带有的一个函数却是可以在某些时刻发挥重要作用的~ 这个函数就是callee函数:
12345678// 递归自我调用函数在解决一些问题的时候是很常用的, 而通常情况下我们都会在函数内调用本函数名即可, 但是如果我们需要实现自我调用的函数正好是一个无名函数呢?// arguments.callee 即调用当前执行的函数function(x)&amp;#123;return x*arguments.callee(x-1)&amp;#125;// 如上, 就实现了一个很简单的&amp;gt;2阶乘计算了
需要特别注意的就是callee作为arguments对象的一个方法, 是可以跟随arguments作为参数传递的, 而且其作为参数的时候保持其所指代函数不变.
既然说到arguments, 就多说两句喽. 首先arguments算是一个类array的object. 它本身具有array的一些特性, 比如可以直接调用length函数(通常的object是不能通过.length直接调用获取长度的, 需要使用Object.keys(object_name).length才能获得). 但是它本身和array.length有很大的差别, 其中最大的一个差别就是: 无法通过.length直接更改数组长度.
123456var a = [1,3,4]a.length = 5console.log(a)// output: [1,3,4,undefined x 2](function(x)&amp;#123;arguments.length = 5;console.log(arguments)&amp;#125;)(10,1,2)// output: [10,1,2]
可以看到通过对arguments.length直接赋值, 并不会影响其本身的长度, 这一点和array本身有很大的差别.
PS. 上述示例是增加长度, 其实缩减长度也是一样的, 多余的元素会被自动删除. 所以, 通过直接向array.length赋值也算是一个修改array长度的方法喽~
PSS. 通常如果一个函数接受参数比较多的时候, 为了预防因为参数顺序而产生的问题, 可以采取传json格式的object作为参数, 这样就能够通过key而不根据顺序获取参数了.
Function的property请先看下述代码:
1234567891011f.temp = &quot;test&quot;function f(x)&amp;#123;  console.log(arguments.length);  console.log(arguments.callee.length);  console.log(f.temp);&amp;#125;f(1,2)// output: 2 1 &quot;test&quot;
首先, 我们看一下我们前两个输出值:
  如上所述,arguments.length即代表传入参数的数量, 我们传入了两个参数, 所以这里输出2, 没有任何问题. 那么后面的arguments.callee.length又是什么呢? 为什么它输出的是1呢? 
  根据之前的介绍, 我们当知道arguments.callee是代指当前的函数f(), 那么对应的arguments.callee.length即我们的函数f的length了. 对于Function这个对象而言, 它所拥有的length这一属性特指其声明的参数数量, 我们应该知道JavaScript作为一个很宽松的语言, 其函数定义后接受的参数是不定长的, 即便传入参数与函数声明的参数不相等也是不会抛出异常的, 那么有时候我们需要获取确保函数接受的参数和其声明的参数数量一致, 就可以使用函数自身的length属性来实现;
其次, 我们自定义了一个f的属性temp, 但是我们实在函数定义之前赋予这个属性的, 为什么依然能够在函数运行中输出呢? 
  这主要是因为js的执行顺序所致. js在载入执行过程中, 首先会将内部声明的函数都定义之后才会正式由上至下的逐次执行. 所以这里虽然我们把f.temp写在了函数定义之前, 但是js执行过程中, 还是首先定义了函数f, 接着才开始运行我们的f.temp赋值语句. 自然就不会报错说f没有定义了~
PS. 其实不止是Function, 即便是普通的变量声明, 也是编译和执行分开进行的, 比如var a = 2;也是拆解为var a; a = 2两步执行的, 而声明都是发生在编译过程, 待编译过程全部结束后, 才会由上到下一次执行, 这也是为什么, 单纯的声明可以出现在代码的任意部位都不会影响其所在作用域的生效, 不会爆出not defined的错误;
reserved word, identifier, keyword这三个作为基础知识, 可以说是每门语言都共通的概念,  但很多时候我们都不会用到或者不会特意去区分这三个名词, 而最近因为看原版书, 经常会出现三个词的交叉, 所以这里特别google了以下, 试图总结下三者的区别:

identifier: 通常我们把我们定义的变量名, 函数名, 类名, 标签名,宏定义名, 类型名等称为identifier, 取其标识之意, 用以作为其名称以便代用;
reserved word: 与identifier相对, reserved word则是指由语言规定而保留的一些词, 这些词有着特定的用途而不能被用作identifier;
keyword: 作为语言语法的组成部分之一, keyword通常都会有着特定的含义, 绝大多数的keyword都是reserved word, 但也有少量语法中存在keyword不是reserved word的情况, 比如fortran就没有reserved word的概念, 它的所有keyword都可以用作identifier;

reserved word和keyword确实在很大程度上是共同的, 除了上述说的类似fortran语言这种情况外, 也存在reserved word不是keyword的情况, 比如java中的goto就是一个reserved word, 但本身又不是一个keyword, 所以可以说goto这个词基本在java中是完全废弃的~ 那他们为啥要定义这个goto呢?? 有一种说法是这样情况通常是为未来版本预留的~ 还有一种说法是JVM作者James Gosling最初加了goto的支持, 但后来发现完全没必要, 就又去掉了, 但是为了兼容性问题,也一直没有把goto从reserved word此表中删去.
PS. 很多时候也有人完全不区分reserved word和keyword的区别, 完全等同二者为”不能用来做identifier的词”.
closure - 闭包在javascript中, 一个function由两部分组成: 函数执行的代码以及代码执行的环境. 而这两个组合到一起后也有个专属的名称, 即closure. 不过单独一个独立函数的closure并没有什么值得说的意义, 因为其执行的环境, 即我们称之为scope的东西, 随着函数的执行开始与结束会自动的被创建并清理掉, 所以通常情况下closure都单指在嵌套函数中. 当存在嵌套的函数时, 并且函数之外存在一个reference指向函数的话, 事情就变得好玩多了:
12345678910111213141516171819202122232425262728function f()&amp;#123;  var id = 1;  return function()&amp;#123;console.log(id++)&amp;#125;&amp;#125;f()();f()();f()()// output: 1,1,1// 每次我们调用`f()`,都会自动创建一个包含了其局部变量`id`的对象, 而嵌套的函数`f()()`会自动继承母函数的作用域;// 但每次随着调用结束, 因为没有任何外部引用, 所以创建的对象都会自动的被回收, 如此就导致每次调用`f()()`都会输出1了;var k = f();k();k();k()// output: 1,2,3// 同样是调用`f()`, 但是我们首先引入了一个新的变量`k`引用`f()`函数; // 这样随着`f()`的调用和结束, 其创建的`call`对象(即包含了局部变量id的那个对象)就因为还存在外部引用而得以保留// 所以后面连续调用`k()`的过程中, 本身的嵌套函数就始终共享着`call`对象的作用域, 如此每次输出的时候都是先获取了局部变量id, 然后在执行`id++`,所以输出为1,2,3// 不喜欢`f()()`这种调用方式, 也不想单独创建新变量来增加引用? 当然可以, 只需要借助下`anonymous function`即可:var f = (function()&amp;#123;    var id = 1;    return function()&amp;#123;console.log(id++)&amp;#125;  &amp;#125;)();f();f();f()// output: 1,2,3// `anonymous function`是自执行的函数, 这里相当于把之前的`var k = f()`以及`f()`的声明定义合二为一了.
可以说上述基本就是closure最基本的内容了, 而closure作为js的高级用法之一, 掌握了它, 你就能做很多有意思的操作了. 一个简单的例子就是: 你可以参照closure的原理来模拟实现浏览器探查元素(inspector)的breakpoint功能.
因为原作trimpath上的文章已经无法访问, 所以转载了一个类似的如下, 略作了简单的修改(加了几句更友好的提示和显示每一步的运算结果):
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// This function implements a breakpoint. It repeatedly prompts the user// for an expression, evaluates it with the supplied self-inspecting closure,// and displays the result.  It is the closure that provides access to the// scope to be inspected, so each function must supply its own closure.// // Inspired by Steve Yen's breakpoint() function at// http://trimpath.com/project/wiki/TrimBreakpoint//function inspect(inspector, title) &amp;#123;    var expression, result;    // You can use a breakpoint to turn off subsequent breakpoints by    // creating a property named &quot;ignore&quot; on this function.    if (&quot;ignore&quot; in arguments.callee) return;    while(true) &amp;#123;        // Figure out how to prompt the user        var message = &quot;&quot;;        // If we were given a title, display that first        if (title) message = title + &quot;\n&quot;;        // If we've already evaluated an expression, display it and its value        if (expression) message += &quot;\n&quot; + expression + &quot; ==&amp;gt; &quot; + result + &quot;\n&quot;;        else expression = &quot;&quot;;        // We always display at least a basic prompt:        message += &quot;Enter an expression to evaluate, or just click cancel to see the next step of current calculation.&quot;;        // Get the user's input, displaying our prompt and using the        // last expression as the default value this time.        expression = prompt(message, expression);        // If the user didn't enter anything (or clicked Cancel),        // they're done and so we return, ending the breakpoint.        if (!expression) return;        // Otherwise, use the supplied closure to evaluate the expression        // in the scope that is being inspected.         // The result will be displayed on the next iteration.        result = inspector(expression);    &amp;#125;&amp;#125;function factorial(n) &amp;#123;        var inspector = function(x) &amp;#123;                return eval(x);        &amp;#125;        inspect (inspector, &quot;Entering factorial()&quot;);        var result = 1;        while (n &amp;gt; 1)&amp;#123;                result = result * n;                n--;                inspect(inspector, &quot;factorial() loop with current result:&quot;+result);        &amp;#125;        inspect(inspector, &quot;Exiting factorial()&quot;);        return result;&amp;#125;inspect(function (x) &amp;#123;return eval(x);&amp;#125;, 'Hello')factorial(5)// 通过closure, 它就可以检测factorial执行的各个环节, 从而更容易的找到你在不同环节的问题.
虽然closure让你可以写出更加复杂的js代码, 但是本身closure的使用还是要慎重的, 因为closure需要存储函数对象在内存中而不销毁, 所以如果函数主体庞大, 那么对于内存的压力和运行性能都是会有影响的~
Function constructor类似Array, String等都有着一个对应的类, 可以允许你通过new来创建对象. Function也有自己对应的Function()类, 可以通过:new Function()来创建函数, 其接收不定长参数, 最后一个参数始终作为函数运行主体. 不过通常来说这种方法定义函数远没有我们常用的function关键词来的方便, 所以使用上倒是少了很多~ 不过有几点还是值得注意的:

new ClassFunction() 是把function作为constructor的一种用法, 你可以简单的理解为: var cc = new ClassFunction(params) ==&amp;gt; var cc = new Object();ClassFunction.call(cc,params)
new Function()不接收函数名参数, 即其创建的都是anonymous function;
new Function()不继承作用域, 几遍其是在嵌套函数中定义, 也只继承global域, 不会继承上层函数的作用域;

谜题12345678910111213var name = &quot;The Window&quot;;var object = &amp;#123;  name : &quot;My Object&quot;,  getNameFunc : function()&amp;#123;    console.log(this);    return function()&amp;#123;      return this.name;    &amp;#125;;  &amp;#125;&amp;#125;;console.log(object.getNameFunc()());// output: Object&amp;#123;name:&quot;My Object&quot;&amp;#125;; &quot;The Window&quot;
上述定义中, 为什么嵌套函数没有继承上层函数的this呢? 反而继承了全局的this?
猜测解答: this这个关键字是个比较特殊的关键字, 它具有一个很有趣的特点就是: 当一个函数作为函数而不是方法来调用的时候, this指向的是全局对象, 只有当它是方法的时候, 其指向的才是所属对象; 题目来源阮一峰博客. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (3)</title><link>http://taoalpha.me/blog/2015/06/22/read-javascript-the-definitive-guide-3/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-22T04:00:00.000Z</pubDate><description>概述先说点不相关的… 为了更好的阅读, 所以以后读书笔记相关的博文都会分拆成4个部分:

概述: 算是阅读总结摘要以及类似这段话之类的声明介绍等等;
阅读笔记: 这部分主要以阅读过程中的记录为主, 会比较杂, 基本算是逐点记录, 评判相对主观;
心得: 这部分则主要为笔记的延伸, 算是对笔记的一种补充或者说自己的阅读理解消化所得, 有时候也会覆盖到一些使用架桥等等;
谜题: 这里主要记录一些没有完全理解的部分, 会加上自己的猜测解答, 当弄懂后会更新正解;

DONE.
本篇是博主重新翻阅了”JavaScript the Definitive Guide(第六版)”的前4章内容(之前 阅读笔记-2均是第五版的)后的读书笔记以及心得体会. 内容主要覆盖js的基本用法, 考虑到重复, 这里主要是在上两篇的基础上查漏补缺.
阅读笔记Chapter 2 - 基础知识JS能识别的whitespaces:
常规空格: \u0020 # 即url中常见的%20
Tab(制表符): \u0009 # js中常见的\t
Vertical Tab: \u000B # \v
Form Feed(翻页/页码分隔符): \u000C # \f
Nonbreaking Space(不间断空格): \u00A0  # 通常在html中用来阻止默认连续多空格自动归一的性质(auto collapsing)而使用&amp;amp;nbsp;, 同时因为软件处理的需要, 使用&amp;amp;nbsp;能够防止相应的处理器将普通空格转为行分隔;
Byte order mark: \uFEFF
any character in Unicode category Zs

JS能识别的line terminators:
line feed: \u000A # \n
carriage return: \u000D # \r
line separator: \u2028
paragraph separator: \u2029

值得一说的是, js是支持unicode作为indentifier的合法字符的, 但是上述这些则不在其中.
JS的”Unicode Escape Sequences”类似”\u00E9”这种结构的字符在js都代表一种特殊的字符:”unicode”. 如果你在js中使用这些字符, js会自动将其编译为对应的字符(如果是在js的注释中, 则不会编译, 而是以ascii对待), 比如: 示例就会编译为”é”. 而在js中, 这种对等关系是支持的, 即 &amp;quot;\u00E9&amp;quot; === &amp;quot;é&amp;quot;是为真的.
但是一定要慎用… 因为unicode变化过多, 有时候输出看起来一样的字符, 其本质不一定一样: &amp;quot;e\u0301&amp;quot;的输出也是”é”, 但是它相当于是&amp;quot;e&amp;quot;+&amp;quot;\u0301&amp;quot;组成的.
JS中的&amp;quot;;&amp;quot;在JS中, &amp;quot;;&amp;quot;作为语句结尾并不是必须的, 只有当多语句同行的时候, &amp;quot;;&amp;quot;才是必须的. 当你没有&amp;quot;;&amp;quot;的时候, js会自动为你添加合适的&amp;quot;;&amp;quot;. 通常它会自动将它没有&amp;quot;;&amp;quot;无法解析代码时候遇到的换行处加以&amp;quot;;&amp;quot;(除了类似return,break, ++, –等, 它会自动将其后的行分隔符作为&amp;quot;;&amp;quot;对待.):
1234567var aa=3console.log(a)// output: 3// js在第一个换行处识别了其语句分割的意义, 但是在 a = 3 的两个分割处都因为它可以识别合并后的语句所以没有作为`&quot;;&quot;`处理.
但是上述的成功不意味着js的智能, 更多时候如果我们不合适的使用&amp;quot;;&amp;quot;, 会造成很多奇怪的问题的, 比如以(, [, /, +, -为起始的语句很可能会被误认为是前一语句的延续. 所以通常来说, js的编码还是比较鼓励使用&amp;quot;;&amp;quot;作为语句结尾的.
Chapter 3 - 数据类型Number:
Global viriables: Infinity,NaN
Global Objects: Math,Number

Tips:

NaN 具有唯一性, 其不等于任意值, 包括它自己, 0/0会产生’NaN’, 但是0/0 != NaN, 如果需要判断一个变量是不是NaN, 需要使用isNaN()这个内置的函数;
Infinity &amp;lt;==&amp;gt; Number.POSITIVE_INFINITY &amp;lt;==&amp;gt; 1/0
-Infinity &amp;lt;==&amp;gt; Number.NEGATIVE_INFINITY &amp;lt;==&amp;gt; -1/0
Binary Floating-Point会导致小数级错误, 比如0.3-0.2 != 0.2-0.1, 这个属于计算机本身因为二进制编码的原因所致, 所以在比较数字大小的时候要格外小心;

String:
immutable ordered sequence of 16-bit values

Tips:

string的长度都是按照16-bit来计算的, 所以当如果一个字符超过了16-bit, 则会按照多的计算. 比如: e - \ud835\udc52, 就需要按照两个16bit计算, 即其长度应为:”2”
从ECMAScript 5之后就允许string跨行定义了, 只需要在换行的地方加上一个反斜杠\, 即可.
转义字符\如果加在普通字符前, 不会产生任何效果;
typeof null =&amp;gt; Object , typeof undefined =&amp;gt; undefined;
null == undefined, null!==undefined =&amp;gt; True

类型转换javascript是一个很宽松的语言, 我们不需要预先定义变量类型, 而在运算以及执行过程中, js也会自动的帮助我们进行类型转换, 当然为了更好的借助这一特点, 了解下图中的js转换类型的规则还是非常有必要的.

其中object转换 primitive datatype 的话, 一般会按照如下步骤进行:

首先会默认调用toString()函数, 你可以自行定义这一函数, 如果toString()返回结果正常, 则转换结束;
如果toString()未定义, 或者返回结果非primitive datatype的话, 会自动调用valueOf()函数, 同上一步;
而如果两个都没找到, 那么js将会抛出TypeError;

而根据要转换的是string还是number而交换1,2两步( string 的话先调用toString(), 且返回值必然会转为string; 如果是number的话, 则先找valueOf(), 返回结果为number). 当然至于boolean的话, 所有的object转换到boolean都是true.
Array转换string的时候默认的toString()就是一个join()调用~ Function的话, 则也可以自己定义toString()函数.
Tips:

x + “” // Same as String(x)
+x // Same as Number(x). You may also see x-0
!!x // Same as Boolean(x). Note double !
在ECMAScript 5的strict模式下, 所有变量君需要声明才能赋值, 否则会报错;

Chapter 4: Expressions and Operators
上图为按照优先级顺序排列下来的操作符(横线分隔的同一组块之间的级别相同).
Tips:

运算顺序不影响赋值顺序, 赋值顺序始终都是严格从左到右的, 比如:h = x+y+z, 那么赋值顺序始终都是h-&amp;gt;x-&amp;gt;y-&amp;gt;z; 通常情况下, 这一赋值顺序不会影响之后的计算顺序, 对结果基本没什么影响, 除了一种情况:
如果前变量的赋值会影响到后面变量的值的话, 比如共用同一个变量, 那么这种情况下, 赋值顺序就可能会对结果产生一定的影响了. 最简单的例子就是z = 2;y = function(){z = 3;return 1};, 因为y是一个函数, 而它的执行会改变z的值, 所以y()+z和z+y()的结果就是不相同的.

“+”运算符中的类型转换:

string优先, 只要有两个操作数中有一个是string或者是有toString()的object, 那么其都会按照string来进行链接运算;
除非两个都是非string, 才会进行加法运算;
当”+”作为单操作数时, 则意味着将操作数向number类型转换;


&amp;amp;&amp;amp;运算符如果第一个为false, 则不执行第二条判断, 所以可以用这个方法来代替if: (a==b) &amp;amp;&amp;amp; alert(&amp;quot;a equals b&amp;quot;)就相当于if(a==b) alert(&amp;quot;a equals b&amp;quot;).

!(p &amp;amp;&amp;amp; q) === !p || !q
!(p || q) === !p &amp;amp;&amp;amp; !q
a op= b 和 a = a op b通常是等价的, 除非a本身的重复赋值会有副作用, 比如 a[i++] += 1和a[i++] = a[i++] +1就不一样, 因为后者前后两个i不同了.
eval()函数会继承当前的scope, 除非eval()被赋予某个新的reference, 那样的话只会使用global的scope;
void操作数很少用到, 它是个单操作数的操作符, 其用法就是丢弃操作数的返回结果, 然后返回 undefined…

心得whitespaces 和 line terminators通常在js里面我们使用\s来统一代表所有其可以识别的whitespace, line terminators. 如下例:
1234567var k = 'asd \t asdasd \na asd \f asda dad\rasd\u2028asd\u2029\u00A0'k// output 里面有两个换行的符号, 我这里为了演示方便就不换行了k.replace(/\n/g,'-')// 同上,里面的&quot;\r&quot;我也不换行了k.replace(/\s/g,'-')// output: &quot;asd---asdasd--a-asd---asda-dad-asd-asd--&quot;
因为在console中输出的时候是不换行的, 所以有时候单单看console输出的话, 类似这种编码问题所致的错误就找不出来, 为了省事, 我们可以统一使用\s来代表所有此类符号.
谜题Q: 按照正常来说Number.MAX_VALUE加上一个数应该就会自动转为Infinity, 但实际上, 测试过程中发现, 只有当Number.MAX_VALUE加上一个足够大的数后才会等与Infinity, 这是为什么?
1234567Number.MAX_VALUE// output: 1.7976931348623157e+308Number.MAX_VALUE +1// output: 1.7976931348623157e+308...Number.MAX_VALUE + Math.pow(10,1000)// output: Infinity
正解: the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign.

IEEE 754
In the following two rounding-direction attributes, an infinitely precise result with magnitude at least bemax ( b − ½ b^(1-p) ) shall round to ∞ with no change in sign; here emax and p are determined by the destination format (see 3.3). With:

roundTiesToEven: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with an even least significant digit shall be delivered

roundTiesToAway: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with larger magnitude shall be delivered.



ECMAScript does not specify which of the round-to-nearest, but it doesn’t matter here because both gives the same result. The number in ECMAScript is “double”, in which

b = 2
emax = 1023
p = 53,

_so the result must be at least 2^1024 - 2^970 ~ 1.7976931348623158 × 10^308 in order to round to infinity. Otherwise it will just round to MAX_VALUE, because that is the closer than Infinity.Notice that MAX_VALUE = 21024 - 2971, so you need to add at least 2^971 - 2^970 = 2^970 ~ 9.979202 × 10^291 in order to get infinity._
Q: &amp;#39;0&amp;#39; == false 是 true, 为什么 null == false 就是 false呢?
猜测解释: ==这样的是比较value的, 而 null转换为boolean类型为false, 并不意味着两者的value是相同的. ==只会比较value, 而不会进行转换. 也即true, false两个boolean类型的其value也是1,0. 而null和undefined的value则不同, 前者为空, 后者为无.
参考资料:
JavaScript the Definitive Guide 6th edition
Unicode Property
List of Unicode Characters
编码历史介绍

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (4)</title><link>http://taoalpha.me/blog/2015/06/23/read-javascript-the-definitive-guide-4/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-23T07:00:00.000Z</pubDate><description>概述第六版和第五版的最大区别在于ECMAScript 5的引入, 这是目前发布的最新的js版本, 有着最新的属性和函数, 目前主流浏览器基本都已经完全支持. 本文为阅读5-9章内容的笔记总结, 主要是覆盖了JS中的语句和典型对象.
阅读笔记Chapter 5 - Statements
switch/case中使用的是===进行比较判断的, 而不是==;
with带入scope chain的对象只有读取权限, 没有写入功能, 即with后, 可以获取其代入的对象, 但其内声明的变量都依然归于gloabl或者local之中;
debugger是ECMAScript 5引入的一个新的statement, 起主要作用是和浏览器结合使用, 用于创建断点以便查错使用;
use strict也是ECMAScript 5引入的, 严格来说不算statement而是directive, 不过两者很是相近; 其使用必须位于js整体的起始位置或者是一个function主体的起始位置;
use strict的使用会开启代码的strict mode, 为了提升效率, 错误追踪以及更好的安全性, 其语法要求会更加严格, 简单列举如下:
停用with语句;
所有变量必须声明才能调用;
所有独立声明的函数而非对象的方法定义的, 其this域都默认为undefined, 而函数如果通过apply,call调用, 其this域为传入对象;
对未声明变量的赋值或者不能写入的对象进行写入, 都会抛出异常;
eval调用会自动创建临时局部scope, 不再能直接对母域新建声明了;
arguments成为传入参数的硬拷贝, 和传入参数名之间不在绝对相等, 即改变一方不会引起另一方的改变, 同时停用其caller,callee方法;
delete用于变量, 函数或者函数参数的时候会抛出异常, 操作对象的某个未声明属性也会抛出异常;
对象(包括函数)创建中不能出现同名属性(参数);
直接声明的八进制数是不允许的(即0开头的数字);
eval,arguments作为keywords对待, 不能赋值, 或赋予其他变量, 也不能用于identifier;




Chapter 6 - Objects
Property Attributes (ECMAScript 5之后引入可自定义配置, 之前默认三者皆有.)
writable: 可赋值;
enumerable: 可递归;
configurable: 可配置 - 可删除也可修改;


Object Attributes
portotype: 指向当前对象的属性继承对象;
class: 指代对象所属类别;
extensible: 指示当前对象是否能够新增属性 (ECMAScript 5引入);


Object Categories and Property Types:
native object: js中内置的对象, 包含Arrays, functions, dates, regular expressions等;
host object: 由js运行环境所定义的对象, 比如常见的浏览器, 就包含了HTMLElement对象;
user-defined: 执行js代码的时候创建的对象;
own property: 直接由对象中定义的属性;
inherited property: 由对象的prototype object继承来的属性;


Prototype:
任何一个对象(除了Object.protytpe)的出现都必然包含了第二个对象的存在: new Array() =&amp;gt; Array.prototype;
Object.prototype是唯一一个没有母继承的对象了, 它是最顶部的类;
类似new Array() =&amp;gt; Array.prototype =&amp;gt; Object.prototype这样的两个prototype就组成了Array的prototype chain;
Object.create() 是ECMAScript 5引入的新的创建对象的方法, 其接受两个参数, 第一个参数会作为新建对象的prototype传入, 第二个则是用来描述新对象的属性的. 如果你传入null, 则新建对象是完全没有prototype的, 只有Object.create(Object.prototype)才是等价于我们常用的{} or new Object();
获取某个object的未定义属性将返回undefined, 但是获取undefined或者null的某个属性则会抛出异常;


getter &amp;amp;&amp;amp; setter
ECMAScript 5新引入的两个accessor properties, 分别对应某个属性的调用和赋值;
只有setter的属性只有写入权限, 只有getter的属性则是只读权限;


property attributes
value, writable, enumerable, and configurable
对应的accessor property: get, set, enumerable, and configurable
Object.getOwnPropertyDescriptor(object_name, property_name) 获取某个属性的特征描述;
Object.defineProperty(object_name, property_name,{property_attribute:attribute_value}) 对某个属性设定其特征描述;



下例即为利用Object.defineProperty自定义的一个extend()函数:
123456789101112131415161718192021222324252627282930// Example 6-3. Copying property attributes/** Add a nonenumerable extend() method to Object.prototype.* This method extends the object on which it is called by copying properties* from the object passed as its argument. All property attributes are* copied, not just the property value. All own properties (even non-* enumerable ones) of the argument object are copied unless a property* with the same name already exists in the target object. */Object.defineProperty(Object.prototype,  &quot;extend&quot;,  &amp;#123;    writable: true,    enumerable: false,    configurable: true,    value: function(o) &amp;#123;      // Define Object.prototype.extend      // Make it nonenumerable      // Its value is this function      // Get all own props, even nonenumerable ones      var names = Object.getOwnPropertyNames(o); // Loop through them      for(var i = 0; i &amp;lt; names.length; i++) &amp;#123;        // Skip props already in this object        if (names[i] in this) continue;        // Get property description from o        var desc = Object.getOwnPropertyDescriptor(o,names[i]);        // Use it to create property on this Object.defineProperty(this, names[i], desc);      &amp;#125;    &amp;#125;  &amp;#125;);

Object Attributes;
Object.getPrototypeOf() ECMAScript 5引入, 可用于获取某个对象的prototype;
p.isPrototypeOf() 同上, 用于判断某个对象是否为另一个对象的prototype;
Object.isExtensible(),Object.preventExtensions()则分别是用于判断一个object是否是可扩展的, 以及禁止其可扩展性的(此操作不可复原);
Object.seal()类似Object.preventExtensions(), 不过它同时禁掉了properties的configurable属性,Object.isSealed()则是对应用于判断是否sealed的函数;
Object.freeze()比Object.seal()还要严格,所有属性都变为可读了, 对应的查询函数为:Object.isFrozen();
Object.preventExtensions(),Object.seal(),Object.freeze()都是只针对当前object而言的;
class属性目前基本没啥用, 有点等价或者说更细化的typeOf or instanceOf了;



Chapter 7 - Arrays这里主要记录ECMAScript 5引入的一些新的方法, 3已有的可以查看 阅读笔记-2

forEach(value,index,array_itself): array自身的循环调用函数, 相当于for(i in array_name){}, 区别在于其不支持break等可以跳出循环的语句, 如果你想要提前结束循环, 就需要通过try/catch包裹并利用抛出异常来结束循环;
map(): 也算是循环的一种, 遍历每个元素并传递给传入的函数, 最终返回一个新数组;
filter(): 顾名思义, 这是对数组进行筛选的, 值得一提的是filter()会自动跳过空白,所以对于稀疏数组通过filter()可以去除所有空白, 在加上undefined判断, 就可以去除所有空值了;
every() 和 some(): every()是当数组每个元素都使传入函数为真的时候返回真, some()则是只要一个为真即返回为真, 需要注意的事, 对于空数组, every()会返回真, 而some()会返回为假;
reduce(function,initial_value) 和 reduceRight(): 通过执行传入函数而对数组元素进行整合,计算,判断, 最终返回一个结果: var max = a.reduce(function(x,y) { return (x&amp;gt;y)?x:y; });即返回数组的最大值; reduceRight()与reduce()一致, 只是循环顺序相反, 从右到左; 当没有声明初始值时, 采用第一个执行元素作为初始值;
indexOf() 和 lastIndexOf: 顾名思义, 获取数组中某个元素的index, 前者获取首个匹配元素的index, 后者获取最后一个匹配元素的index;

Chapter 8 - Functions
Functions的调用有四种:
直接调用;
作为对象的方法调用;
作为constructor调用;
通过call,apply方法调用(间接调用);


call() 和 apply:
call和apply都是间接调用的方法, 允许一个函数临时客串为某个object的方法;
一定程度上, 可以等价于o.m = f;o.m();delete o.m;
其接受的第一个参数会成为函数运行的this域, 如果是非strict mode下, 传入null/undefined则会自动将global作为this, 而如果传入的是primitive datatype, 则自动转为对应的wrapper object, 即string =&amp;gt; String;
call和apply的区别主要体现在后面的参数上, 前者以分散元素传入, 后者则以整体数组形式传入, 所以用apply可以把原本只支持不定长参数的函数转换为接受数组的函数:var biggest = Math.max.apply(Math, array_of_numbers);;
apply对类array元素处理方式同array元素;


bind(): 很是类似call和apply, 本质也是把某个函数作为某个对象的方法调用, 实现则是通过把object和function绑定, 形成一个新函数从而每次调用新函数都等价于调用了object.funtion, bind接受多个参数, 其首个以后的参数都会作为this域成员代入函数中, 并按序成为函数自身的参数function f(y,z) { return this.x + y + z };var g = f.bind({x:1}, 2);g(3) // 2被赋予了y, 新的3则给了z;
higher-order function: 作用于另一个函数之上的函数;

partial and memoization 这两个都是function programing中常用的方法:

partial: 类似bind()这种会把传入参数默认分配到函数自身的部分接受参数上的做法就是partial application;
memoization: 将函数运行过程的计算结果缓存起来的方式;



123456789101112131415161718192021222324function array(a, n) &amp;#123; return Array.prototype.slice.call(a, n || 0); &amp;#125;// 用以处理类array元素(转为真正的array)function partial(f /*, ... */) &amp;#123;  var args = arguments;  // 存储partial的参数  return function() &amp;#123;    var a = array(args, 1);    // 取出首位以后的参数    var i=0, j=0;    for(; i &amp;lt; a.length; i++)      if (a[i] === undefined) a[i] = arguments[j++];      // 这里的arguments是第二层参数      // 将空元素逐个替换成第二层参数里的值, j自动随着执行+1    a = a.concat(array(arguments, j))    // 组成新的参数数组    return f.apply(this, a);    // 调用f函数, 并传入参数a  &amp;#125;;&amp;#125;var f = function(x,y,z)&amp;#123;return x*y*z&amp;#125;partial(f,undefined,2)(1,3)// x:1,y:2,z:3
123456789101112131415// Return a memoized version of f.// It only works if arguments to f all have distinct string representations.function memoize(f) &amp;#123;  var cache = &amp;#123;&amp;#125;;  return function() &amp;#123;    var key = arguments.length + Array.prototype.join.call(arguments,&quot;,&quot;);    if (key in cache) return cache[key];    else return cache[key] = f.apply(this, arguments);  &amp;#125;;&amp;#125;// 应用方式类似;var factorial = memoize(function(n) &amp;#123;return (n &amp;lt;= 1) ? 1 : n * factorial(n-1); &amp;#125;);factorial(5) // 此时会自动缓存4,3,2的阶乘值. 对于一些复杂的运算, 如此可以很好的加快运算速度.
Chapter 9 - Classes and Modules除了 阅读笔记-2中包含的, 由于ECMAScript 5所引入的那些object property自然都可以应用到新的class中, 从而创建更为复杂有效的函数. 其实js中目前不存在class这个关键词, 所以其模仿的class, 说白了就是一个复杂一些的函数对象.
而因为其内容驳杂繁多, 我么会在后面的应用中有很多实践的机会, 这里就不一一描述了.
参考资料
JavaScript the Definitive Guide 6th edition
Functional Javascript

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (5)</title><link>http://taoalpha.me/blog/2015/06/24/read-javascript-the-definitive-guide-5/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-24T08:00:00.000Z</pubDate><description>概述在十到十二章中, 第十章的正则表达式内容最为丰富, 也是目前应用即为广泛的内容之一. 不过这里也主要是结合js的应用, 实际上正则表达式本身就是一个很值得研究的话题, 有不少书都在谈这个话题, 我后面要读的书目中恰巧就有这么一本, 后面会更加详细的学习以下正则表达式的方方面面.
十一章算是非常前沿, 高端或者说冷门的点了, 随着浏览器的盛行以及技术的进步, 安全问题始终都是一个很重视的点, 而在这种攻防演练中也促进了js本身的进步, 而主流浏览器本身更是走在了js的最前沿. 各种新的属性都是由他们引入而逐渐成为标准的;
十二章主要是对走出浏览器的JS做了一个简单的介绍, 而NodeJS的大名在近几年在前后端, 全端领域都可谓是人尽皆知. 我也会在之后阅读相关书籍的时候做更详细的笔记记录.
阅读笔记Chapter 10 - Pattern Matching Regular Expressions
normal repetition characters:
{m,n} 匹配m-n次;
{m,} 匹配至少m次;
{m} 匹配恰好m次;
? 匹配0或1次;
+ 匹配1或多次;
* 匹配0或多次;


Nongreedy repetition:
??, +?, *? 在常规的匹配后加上?就能让匹配尽可能发生的短, 它会在允许范围内, 找到尽可能短的匹配;


Alternation, Grouping, Reference:
| 表示匹配前者或者后者;
(...) 成组, 以组的形式来使用*,+,?等, 同时会记录组的匹配以用于Reference;
(?:...) 只是成组, 不记录匹配, 不能用于reference, 也不算做reference的序号中去;
\n 引用, n表示序号, 从1开始, 代表之前第几个group的匹配, 用于匹配开头结尾相同且多样的有奇效:/([&amp;#39;&amp;quot;])[^&amp;#39;&amp;quot;]*\1/ 匹配单引号或者双引号内的内容;
需要注意的就是, reference不能用于[]的character class之中!


anchor characters:
^: 匹配开头;
$: 匹配结尾;
\b: 匹配词边界, /\bJava\b/ =&amp;gt; Java
\B: 匹配非词边界, /\B[Ss]cript\B/ =&amp;gt; JavaScript, postscript...
?=p: 表示内容需要匹配p规则,但是返回的命中中不包含这部分;
?!p: 表示内容不匹配p规则;


flags:
i: 大小写敏感, 即区分大小写;
g: 全局匹配, 默认是匹配首个;
m: 多行匹配;


String Methods for Pattern Matching:
search(): 返回匹配词的位置或者-1代表无返回;
replace(): 支持正则匹配替换, 同时支持替换时使用$n代表是正则匹配的引用, 比如text.replace(/&amp;quot;([^&amp;quot;]*)&amp;quot;/g, &amp;#39;“$1”&amp;#39;);即替换&amp;quot;&amp;quot;为“”;
match(): 返回包含了匹配的结果, 返回结构为数组格式;
split(): 接受正则匹配作为其分隔符, 比如: &amp;quot;1, 2, 3&amp;quot;.split(/\s*,\s*/); =&amp;gt; [&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;], 就去掉了本来直接split()多余的空格;


RegExp prototype method:
exec(): 基本等同match(), 不过接受的是string类型去匹配, 而由正则去调用, 当表达式加了全局flag后, exec()每次执行会记录其上次匹配的位置并从此开始新的匹配, 比如:var pattern = /Java/g;pattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).indexpattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).index就会相继输出0,28两个位置;
test(): 用以检测表达式是否匹配了传入的string, 其执行逻辑(g模式下记录上次匹配位置)和exec()一样;



Chapter 11 - JavaScript Subsets and Extensions本章主要介绍一些目前主流浏览器支持但是还没有写入JavaScript官方版本中的一些js语言的子集(非官方版本)和扩展属性:

subsets: 通常是为了确保不确定安全性的代码能够安全的运行而出现的(除了Crockford’s JavaScript: The Good Parts);
ADsafe, 最早一个因为安全因素设计的子集语言, 会禁止对绝大多数全局变量的访问;
dojox.secure: 算是Dojo toolkit的一个扩展;
Caja: 其包含了两个子集, 一个是Cajita, 比较严格, 类似ADsafe 和 dojox.secure; 还有个是Valija, 则比较接近如今ECMAScript 5的strict mode了;
Microsoft Web Sandbox;
FBJS: facebook使用的一个自己;通常子集都需要对应一个verifier, 来确保代码符合其要求;


extensions:
const: 声明常量, 比如: const pi = 3.14;;
let: 块变量声明, 相当于缩小版的var, 作用域仅存活在最近的一个块结构里, 你可以用{}来自行创建一个block;
destructing: 允许多变量结构化赋值: let [x,y] = [1,2];let [r,theta] = polar(1.0, 1.0); function polar(x,y){...};甚至这种all = [first,second] = [1,2,3,4]; 或者这种let transparent = {r:0.0, g:0.0, b:0.0, a:1.0}; let {r:red, g:green, b:blue} = transparent;;
for/each: 和for/in循环不同, for/each遍历对象的属性值而不是属性名, 且可操作类array对象;
for/in: 从js 1.7(mozilla的js引擎版本号)开始, for/in也不局限在array和常规object了, 只要是可循环的元素都可以使用了;
yield: 从python中引入的;
Array Comprehensions:  还是从Python中借用的, let evensquares = [x*x for (x in range(0,10)) if (x % 2 === 0)];
try/catch: 支持多catch;



Chapter 12 - Server-Side JavaScript随着js的发展, 慢慢的超出了其本身的作用域: 浏览器. 随着Google V8引擎为js包入了unix的常用API: files,processes,streams,sockets等, js开始走出浏览器进入server端了. 正式命名为Node.JS. 想来很多人可能都听过, 因为后面我的数目中也包含了相关的书, 且本章内容也没见过太多, 所以就一起留到以后吧~
参考文献:
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (6)</title><link>http://taoalpha.me/blog/2015/06/25/read-javascript-the-definitive-guide-6/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-25T10:00:00.000Z</pubDate><description>概述正式进入本书第二部分的内容, 核心主要围绕在浏览器内的js. 包含了最基本的使用方式, 方法, 因浏览器而增加的各种属性方法, 操作css, dom的方法, 以及常用的一些js框架, 库等, 同时还包含了目前浏览器大热的安全领域.
阅读笔记Chapter 13 - JavaScript in Web Browsers
异步:
defer: 使浏览器在解析并加载渲染完HTML的DOM后加载此js脚本;
async: 使浏览器在尽快执行js脚本, 但在下载js脚本时不停止DOM的解析, 优先级高于defer;
使用方式为在script中增加关键字即可: &amp;lt;script defer src=&amp;quot;deferred.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;;
注意在使用defer/async的时候, js中不能使用document.write();
document.readyState的变化过程: loading(async downloading, normal executing) =&amp;gt; interactive (defer/async executing) =&amp;gt; complete(defer/async done, event handlers invoked);


Compatibility Check:
按照目前的浏览器格局, 基本上一个浏览器就有着一种js的版本, 除了标准版本的基础功能之外, 所有的扩展功能, 各家与各家的实现方式都略有不同, 所以在使用过程中, 就需要我们考虑到兼容性的问题;
Can I Use…, 这是一个非常优秀的检测某个属性, 方法的浏览器支持度, 拿不准的都可以在这里进行查询确认, 其还支持css和html5的检测;
IE5的时候引入了一个Conditional Comments的技巧, 是通过特殊的html注释从而让浏览器识别其IE版本, 比如&amp;lt;!--[if lte IE 7]&amp;gt;&amp;lt;![endif]--&amp;gt;就代表IE7及以下, 而写在这个if里面的内容就会在IE7及以下的浏览器中被识别并作为页面html的一部分而提取出来(仅限IE浏览器), 其他的浏览器都会自动当做注释不理会此部分;
IE的JS也支持Conditional Comments, 比如/*@cc_on @if (@_jscript)...@end @*/, 这里面@cc_on...@*/是整个Conditional Comments, 而里面的@if (@_jscript)...@end则是判断部分, 其中@_jscript是IE自身js编译器的名称;


Accessibility:
对于身体原因而有不便的人, js的支持效果会大打折扣, 所以根据这部分人的情况而优化自身的网页结构, 目前也是网页设计的一大核心之一;


Security:
随着js的发展使用, 其危害性也日益提升;
目前的保障安全手段主要有:限制其功能,限制其使用范围和情景,敏感权限默认关闭虚人工开启;
The Same-Origin Policy: js只允许读取与当前执行环境域名相同域名下的windows属性, 那么怎么界定相同域名呢:
来自不同的网络服务器;
来自相同的网络服务器, 不同的端口;
同一网络服务器, 同一端口, 不同的http协议(http,https);
以上, 都认为是不同域名;


如何舒缓此规则:
document.domain: 考虑到同级子域名也会被禁止, 那么通过设定document.domain为同一母域名即可实现同级子域名的跨域;
Cross-Origin Resource Sharing: 通过http请求新增的Access-Control-Allow-Origin头部, 服务器就可以指定其允许跨域的程度了;
cross-document messaging: HTML5新增了一些很强大的API,cross-document messaging API就是其中之一, 它允许不同的document之间的js进行通讯;





Chapter 14 - The Window Object
Timers:
setTimeout(): 延时触发;
setInterval(): 定时循环执行;
clearTimeout(): 清除延时触发;
clearInterval(): 清除定时循环;


Location:
window.location === document.location 两者皆为当前页面url, 并随页面url变化而更新;
document.URL 也是指代加载后的当前页面, 但不随页面内动态变化引起的url变化而变化;
Location这个对象本身包含了多个属性分别指代url的不同部分:protocol表示网络协议, host, hostname通常都指示域名,前者包含端口, port表示端口, pathname表示以域名根目录为/的相对路径, search表示url中?以后的部分但不包含hash部分, hash则是表示url#以后的部分;
Location还包含了三个常用的函数:assign(),replace(),reload(), 其中前两者功能都一样, 都是用以加载新页面的, 不过replace()加载的同时将当前页面从history中去除了(就是不能后退后之前页面了), 而assign()还保留着; reload()就更不用说了, 只是单纯的重载页面;


History:
back(),forward(): 等价于浏览器的后退,前进按钮;
go(n): 接受数字作为参数, 表示向前或者后退n个页面;
如果页面中有iframe, 那么其history会自动合并到主界面的history中;


Navigator:
appName: 浏览器的名称;
appVersion: 浏览器版本号;
userAgent: 用户代理, 对应HTTP的USER-AGENT;
platform: 操作系统;
onLine: 是否连通网络, HTML5支持;
geolocation: 用户地理位置信息, HTML5支持;
javaEnabled(): 对Java扩展的支持, 非标准;
cookiesEnabled(): 能够设置cookie, 非标准;


Screen:
width,height: 当前屏幕的长宽尺寸;
availWidth,availHeight: 去除功能区等部分之后的实际展现内容的屏幕尺寸;
colorDepth: 显示屏幕的bits-per-pixel;


Dialog Boxes:
alert(): 弹出对话框, 展示传入的信息;
confirm(): 自带OK,Cancel按钮的对话框, 返回对应的boolean值;
prompt(): 附带输入框, 返回输入的值;
上述三个类型的对话框的样式结构都无法调整, 是浏览器默认设定的;
showModalDialog(): 则更加复杂, 它可以支持弹出一个页面, 其接受的第一个参数即为页面的url, 后面的参数则是弹出窗口的属性; 在chromium中已经被禁止了


onerror handler:
用于处理错误信息的, 你完全可以定制这个函数来更好的显示js中的错误信息;


Document Elements As Window Properties:
当一个html元素被赋予了id时, 其id对应名称的全局变量不存在时, 其自动转为全局变量, 属性名称即为id名, 但如果id名已经被使用, 则不生效;
对于&amp;lt;a&amp;gt; &amp;lt;applet&amp;gt; &amp;lt;area&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;form&amp;gt; &amp;lt;frame&amp;gt; &amp;lt;frameset&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;img&amp;gt; &amp;lt;object&amp;gt;这样的元素, 其name值和id效果是一样的, 且name值支持多个元素相同, 会自动生成类array形式, 对于iframe, 对应的属性会指向其内嵌窗口的window对象;


Multiple Windows and Frames:
通过js打开的新窗口都可以被js获取到, 并进行操作, 但是需要符合same-origin的原则;
frame嵌入的窗口可以通过parent.frames属性来获取, 也可以通过其自带的contentWindow来获取;



谜题
Q: 在测试same-origin的时候, 发现有些网站可以设定子域名的document.domain为母域名, 有些不能? 比如在google的搜索结果页, 就可以, 但是在github pages中想要设置为github.io就不可以, 会出现&amp;#39;github.io&amp;#39; is a top-level domain.这样的错误?

参考资料
JavaScript the Definitive Guide 6th edition
Can I Use …
host and hostname

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (7)</title><link>http://taoalpha.me/blog/2015/06/26/read-javascript-the-definitive-guide-7/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-26T06:00:00.000Z</pubDate><description>概述阅读笔记Chapter 15 - Scripting Documents
Selecting:
document.getElementById(id): 通过id, 一个id对应一个元素;
document.getElementsByName(name): 通过name, 可多个;
document.getElementsByTagName(tagname): 通过标签名;
document.getElementsByClassName(class_name): 通过类名;
querySelectorAll(css_selector): 通过css的选择器, 返回所有匹配;
querySelector(css_selector): 返回首个匹配;


Trees of Nodes:
parentNode: 父节点;
childNodes: 子节点;
firstChild, lastChild: 首个或者最后一个子节点;
nextSibling, previousSibling: 下一或者上一兄弟姐妹节点;
nodeType: 节点类型, Document 节点返回9, 元素节点返回1, 文本节点返回3,注释节点返回8, DocumentFragment节点返回11;
nodeValue: 当前节点的文本内容;
nodeName: 标签名, 大写;


Trees of Elements: 忽略所有的文本节点和注释节点;
firstElementChild, lastElementChild: 返回首个或者最后一个元素节点;
nextElementSibling, previousElementSibling
childElementCount: 返回子元素节点的个数;


Attributes of Elements:
getAttribute()
setAttribute()
hasAttribute()
removeAttribute()


Dataset Attributes: 由HTML5引入, 所有带data-前缀的属性都算是合法的html元素属性.
Element Content:
innerHTML
outerHTML: 包含匹配元素自身标签;
insertAdjacentHTML(): 允许指定插入位置beforebegin, afterbegin, beforeend or afterend;
textContent: IE不支持
innerText: IE支持, 功能同上;


Creating,Inserting, and Deleting Nodes
document.createElement(tag_name)
document.createTextNode(text): 创建文本节点;
document.createComment(text): 创建注释节点;
document.createDocumentFragment(): 创建孤立节点;
node_name.cloneNode(): 复制当前节点;
element_node.appendChild(element_node_2): 由后插入;
element_node.insertBefore(element_node_2): 由前插入;
removeChild(): 移除当前节点n.parentNode.removeChild(n);;
replaceChild(): 替换


DocumentFragment: 孤立节点, 其没有母节点(null), 当appendChild()等操作针对其时, 操作执行对象自动变为其所有子节点, 且操作完成后, 其自身为空;
viewport: 表示实际展示内容的窗口, 在顶层网页中为去除浏览器菜单等等之外的部分, 而在iframe中则为iframe定义的frame大小;
document: 表示页面内容的窗口, 通常都大于viewport;
getBoundingClientRect(): 返回节点的长宽,上下左右边界属性width,height,top,left,bottom,right, 返回的结果是基于viewport的;
document.elementFromPoint(): 返回x,y处的元素节点 - 根据z-index, 从外到内的返回;
scroll(), scrollTo(), scrollBy(): 窗口滚动控制, 最后的scrollBy()传入的x,y表示在原有的基础上的增加值;
scrollIntoView(): 滚动到某个节点;
document.forms: 获取页面中所有form元素;
其他document属性:
cookie
domain
lastModified: 修改时间;
location: 等同于window.location
referrer
title
URL: 之前提到过, 其只保存打开时的当前链接, 不随页面内的动态变化而变化;



Chapter 16 - Scripting CSS
js可以通过node.style来访问元素样式属性, 可以获取, 赋予; 而通过更加复杂的函数变化, 就可以创造出一些很棒的动效来, 在css3之前, 所有的非gif或者flash动效基本都是通过js实现的.
window.getComputedStyle(element,&amp;quot;null or :first-line etc&amp;quot;)则可以获取某个元素(或者某个元素的伪类)的所有样式属性, 同时获取的值都会自动转为标准的绝对值(比如设定的百分比也会自动计算出来返回),但是其不能赋予;
disableStylesheet()可以禁止某个元素的所有样式, 如果传入的是数字, 那么会按照document.styleSheets的顺序查找, 如果是string, 则作为css selector查询对应的元素;
insertRule(rules,insert_index), deleteRule(rules) 即插入整条的结构化的css语句, IE下对应的函数为addRule(),removeRule();
document.createStyleSheet则可以创建一个新的样式表, 等价于在head里面创建一个style标签;

Chapter 17 - Handling Events
Events的类型
Device-dependent input events:mousedown, mousemove, mouseup, keydown, keypress, keyup, touchmove, gesturechange;
Device-independent input events: click
User interface events: focus, change
State-change events: loadstart, progress, loadend
API-specific events: dragstart, dragenter, dragover, drop, waiting, playing, seeking, volumechange etc
Timers and error handlers;


Handlers:
Event Handler Attributes: onclick=&amp;quot;&amp;quot;,window.onload = f();
addEventListener(event_name,function,[capturing event handler]): 添加事件, 最后的capturing通常为false;
removeEventListener(): 和上面的add相反;
stopPropagation(): js的事件触发是沿着DOM树向上传递的, 而通过stopPropagation()就能抑制这一环节;
preventDefault(): 很多元素有其自身的事件属性, 比如a标签的跳转, form元素的提交, 当我们想要取消其默认事件的发生时, 可以使用此函数来阻止其发生;



总的来说, 这一章内容其实很丰富, 但是其内容多数都是建立在之前的基本内容之上的. 着重需要知道的就是各种不同的事件, 其支持的元素, 类型以及触发的方式即可. 此类用法主要还是多用多练, 可以试试不同的event都包含那些属性~哈哈
Chapter 18 - Scripted HTTP
XMLHttpRequest:
Ajax: 由js端发起, 通过http请求和服务端交互;
Comet: 由服务端发起, js如果需要反应则使用Ajax回应, 通常由EventSource对象处理;
标准流程:new XMLHttpRequest()=&amp;gt;open(&amp;#39;type of request&amp;#39;, url,[],[username],[userpassword])=&amp;gt;setRequestHeader()=&amp;gt;send([content_body])&amp;lt;=onreadystatechange&amp;lt;=customized handler
通常GET类型的请求我们会通过encodeURIComponent来进行url拼接, 直接在url中体现, send()的时候就不用传值了;
POST类型的请求通常以json格式传递, 我们需要在send()中传入JSON.stringify()的数据, 当然如果是XML的POST, 那么直接传入对应的doc即可, 而像file这类的文件实体, 也是直接传入对应的实体即可;
起中Header部分我们只能自行设定部分, 而Content-Length,Date,Referer,User-Agent等等都由浏览器自动帮我们填上了;
readyState: UNSENT 0(open()还没执行); OPENED 1(open()已经执行);HEADERS_RECEIVED 2(headers已被接收),LOADING 3(正在接受返回),DONE 4(完毕).
XMLHttpRequest对象有一个onprogress的属性可以用来检测其执行进度, 它对应的属性值中包含了lengthComputable, loaded,total, 通过这三个就可以做一个简单的进度条跟踪请求的进度了;
如果是上传行为, 其onprogress属性存在于XMLHttpRequest_Object.upload.onprogress之中;
abort(): 用来取消请求;


EventSource:
标准流程: new EventSource(&amp;quot;url_to_server_file&amp;quot;) =&amp;gt; onmessage



Chapter 19 - The jQuery LibraryjQuery流行度的一大证据之一! 哈哈 我计划抽时间好好读一下jQuery的源码, 所以这里只是大概扫了一遍, 基本也都是应用层面的, 多数我差不多都使用过~哈哈
Chapter 20 - Client-Side Storage我在早先做chrome插件详见我的portfolio的时候, 写过一篇专门介绍web存储的文章. 恩, 当时写了不少patch系列, 哈哈, 改天写个脚本全部导出来转移过来.
恩
参考资料
JavaScript the Definitive Guide 6th edition 我现在就去写导入工具… 今天就到这里吧, 明天算是最后一篇就能完结本书啦~

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (8)</title><link>http://taoalpha.me/blog/2015/06/27/read-javascript-the-definitive-guide-8/</link><category>read</category><tag>js,reding notes</tag><pubDate>2015-06-27T12:00:00.000Z</pubDate><description>概述先说题外话: 昨天读到中途转去忙把以前的旧文章移植过来, 昨夜就已完成, 主要通过python解析了导出来的xml文本, 然后获取对应的时间信息和url信息组成符合jekyll规则的文件名, 再利用文本拼接出每个文件中固有的头和主体, 本来计划用html2text来把每个博文转为markdown, 不过后来源码有些问题, 对部分博文识别不好, 我也没时间细改, 所以就干脆拼接了html到主体中去.
主要导入了当初写的Patch系列和针对UX写的翻译系列. 分别归类到了Tech和DandP目录下. 有兴趣的可查看之~
今天来继续完结JavaScript: the Definitive Guide一书.
阅读笔记Chapter 20 - Client-side Storage
application cache:
为了丰富web app的功能, 或者说让web app更加的像native app, 就有了application cache这个机制, 从而让离线对于web app来说成为了可能;
application cache存储所有的静态格式, 包含html,css,javascript,images等等, 所有和web运行相关的资源文件;
application cache不作为常规cache而被轻易清理掉, 它会一直保持直到被要求删除或者用户手动删除;
Manifest: 为了能够让浏览器将网页存储到application cache里, 我们需要一个manifest文件, 并将之引入到html的head中&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;
此文件必须以CACHE MANIFEST为起始行;
列出所有需要加入application cache里的文件, 用相对路径, 相对与manifest文件而言;
#表示注释, 空行自动忽略;
此文件生效的前提是其MIME属性为text/cache-manifest, 即Content-Type这个header属性, 通常你需要自行在server中添加对应的规则;
如果网页由多个html组成, 则每个html都需要使用&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;声明, 指向同一个appcache文件即可;
一旦缓存, 则所有资源文件都从缓存中获取, 未列出的资源不予加载;


Complex Manifest:
manifest支持复杂规则, 其支持多个section, 包含了NETWORK:,FALLBACK:这两类, 还要加上默认的CACHE:;
NETWORK:: 所有不予cache必须要从网络获取的资源, 可以设定路径, 支持通配符*;
FALLBACK:: 如其名, 优先从网络获取, 无法获取时从本地获取, 所以其每行指定两个url;


Update:
对于Application Cache而言, 其更新主要依照manifest, 浏览器会自动在情况允许时帮助你查看manifest是否更新, 如有, 则重新缓存所有文件;
注意: 浏览器不会自动帮你查看缓存的文件是否更新, 只查看manifest;
通常可以使用#加一行version的注释行来强制更新;
applicationCache.onupdateready: application cache提供了状态函数来指示其更新的进度, 你可以针对其加以操作, 还包含onchecking,onnoupdate,ondownloading,onprogress,oncached,onerror,onobsolete;
除了上述事件外, 还可以通过applicationCache.status来探测其状态: ApplicationCache.UNCACHED =&amp;gt; (0),ApplicationCache.IDLE =&amp;gt; (1),ApplicationCache.CHECKING =&amp;gt; (2),ApplicationCache.DOWNLOADING =&amp;gt; (3),ApplicationCache.UPDATEREADY =&amp;gt; (4),ApplicationCache.OBSOLETE =&amp;gt; (5);
swapCache(): 清楚旧或者废弃的缓存;


Delete:
很简单, 删除manifest, 去掉html中的引用即可;





12345678910111213CACHE MANIFEST# appVersion: 1CACHE:myapp.htmlmyapp.cssmyapp.jsFALLBACK:videos/ offline_help.htmlNETWORK:cgi/
这就算是一个最基本的manifest了.
Chapter 21 - Scripted Media and Graphics
Images:
onmouseover: 鼠标hover移入事件;
onmouseout: 鼠标hover移出事件;
new Image(): 通过创建一个Image对象, 可以赋予其src属性从而实现预加载的功能;


Audio
(new Audio()).canPlayType(type): 检测某种类型的文件是否能播放;
play(): 播放;
initialTime: 初始播放进度;
duration: 文件总时长;
currentTime: 当前播放进度;
muted: boolean, 是否静音;
volume: 音量值;
controls: boolean, 是否显示控件;
loop: boolean, 是否循环;
preload: 是否预加载以及预加载类型, metadata表示加载时长,帧速等, auto表示尽可能预加载更多的内容, none什么都不预加载;
autoplay: boolean, 是否自动播放;
playbackRate: 播放速度(1.0 == normal speed);
readyState: 加载情况(0,1,2,3,4)=&amp;gt;(尚未加载, 已加载但当前位置未加载, 当前位置已开始加载但是不足以开始播放(下一帧还没加载好),已加载且足够播放但是不足以播放到结尾,加载基本足够可以播放至结束)
networkState: 当前媒体文件使用网络的情况(0,1,2,3)=&amp;gt;(还没开始, 没开始但可能已经加载完或者预加载设置为none, 正在使用中, 无法找到资源);
error: 错误信息(1,2,3,4)=&amp;gt;(用户手动停止, 类型正确网络不通畅, encoding问题, 类型不支持)


Video



SVG: Scalable Vector Graphics

SVG算是一种xml格式的矢量图类型;
最新的主流浏览器基本都支持直接在img中嵌入svg, 部分老的浏览器依然只支持使用object标签: &amp;lt;object data=&amp;quot;sample.svg&amp;quot; type=&amp;quot;image/svg+xml&amp;quot; width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;/&amp;gt;
一定程度上SVG很像canvas, 不过它是通过XML的属性来实现的(比如通过&amp;lt;line x1=&amp;#39;50&amp;#39; y1=&amp;#39;5.000&amp;#39; x2=&amp;#39;50.00&amp;#39; y2=&amp;#39;10.00&amp;#39;/&amp;gt;来画线);


Canvas

作为HTML5引入的一个可谓是最重要的标签之一, canvas的存在极大的丰富了网络的表现形式;
canvas和js的关系紧密, 因为其绘画的实现方式就是通过js;
canvas.getContext(&amp;#39;2d&amp;#39;/&amp;#39;3d&amp;#39;): 通过它创建的对象就可以在画布上尽情挥洒了;
很多canvas的函数本质都是数学坐标的公式运算!



我会在后面阅读的HTML5 Canvas中更加详细的研究canvas的各种用法~ 敬请期待~
  
Chapter 22 - HTML5 APIs
Geolocation:
navigator.geolocation.getCurrentPosition()
navigator.geolocation.watchPosition(): 在用户位置变化时唤醒;
navigator.geolocation.clearWatch()
实例 codepen


History Management:
pushState()
replaceState()
实例 codepen


Cross-Origin Messaging:
postMessage()
onmessage()
实例 codepen


Web Workers:
通常来说, js的执行是单线程的, 不支持多线程, 利用Worker可以稍稍的模拟下多线程;
Worker开启的执行不能对window和Dom有任何的操作, 和主线程只能通过postMessage()来交互;
Worker对象的工作域是WorkerGlobalScope, 完全和主线程工作域不同;
Worker支持importScripts来引入其需要的js库;
实例 codepen - 因为跨域问题, 所以这里不能执行, 不过代码很简单, 很好理解, 有兴趣的可以download到本地测试


Typed Arrays and ArrayBuffers:
HTML5 的数组类型变的更加强大, 开始出现类似Int8Array(),Uint8Array()等多种新形式;
实例 codepen


Blobs:
算是存储的一种新形势, 浏览器通常可以存储Blobs到内存或者硬盘中, blobs本身更是可以代表任何数据, 以二进制的形式;
实例 codepen


The Filesystem API: 开启本地文件交互时代;
实例 codepen


Client-Side Databases: 主要为IndexedDB;
实例 codepen


Web Sockets: 一种相对http来说的新网络协议;
实例 codepen



上面针对HTML 5的各个API给出了一个对应的实例, 毕竟看着具体的代码和例子才有意思哈哈
参考资料
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript 阅读阶梯清单</title><link>http://taoalpha.me/blog/2015/06/10/read-must-read-list-of-javascript/</link><category>read</category><tag>js</tag><pubDate>2015-06-10T09:00:00.000Z</pubDate><description>缘起今天翻完了Getting Good With JavaScript, 对于其精华浓缩的设计很欣赏, 很适合有一定无基础或者有一定基础但觉得野路子出身想要夯实一下的人读. 而在文末的Appendix A中作者提到的这个 Rey Bango’s Must-Read list of JavaScript 确实在是本书的又一大收获. 特转来分享~
基础入门所谓入门自然是以打牢基础为目的, 所以下列书都是以基础概念为主, 算是领路之书(考虑到国情需要, 我都尽可能替换为豆瓣链接了):

JavaScript: The Good Parts
Professional JavaScript for Web Developers (Wrox Programmer to Programmer)
ppk on JavaScript, 1/e
Beginning JavaScript with DOM Scripting and Ajax: From Novice to Professional (Beginning: from Novice to Professional) 
Eloquent JavaScript

初窥门径一旦你入了门, 就可以修炼中级秘术了~ 可以看到有两条中级秘术和入门级是一样的, 哈 这就和基础功打的够扎实, 基本拳脚也能当秘术使唤的~

Professional JavaScript for Web Developers (Wrox Programmer to Programmer) 
JavaScript: The Definitive Guide 
Eloquent JavaScript - Online 
DOM Scripting: Web Design with JavaScript and the Document Object Model

高手之路一旦确保自己有了一个牢靠的基础后, 我们就可以开启自己的高手之路了.

High Performance JavaScript (Build Faster Web Application Interfaces)
Object-Oriented JavaScript: Create scalable, reusable high-quality JavaScript applications and libraries
JavaScript Patterns
Pragmatic Guide to JavaScript
Pro JavaScript Techniques
JavaScript Rocks
Secrets of the JavaScript Ninja

造物主模式下面这些就是正儿八经的神级模式了… 当你已经把javascript里里外外摸得门清的时候, 就可以试试调整下面的了… 有一种去看汇编原理的感觉了… 开始研究底层源码了…

Standard ECMA-262 ECMAScript Language Specification 3rd edition (December 1999) – PDF File
Standard ECMA-262 ECMAScript Language Specification 5th edition (December 2009)

JS相关blog分享除了书籍之外, 作者还推荐了一些可以订阅查看的博客~ 我根据其目前存活情况, 主题变更情况简单筛选了下(多数都已经失效了)~

DailyJS - 强烈赞同, 很值得订阅!
JavaScript Weekly Newsletter
YUI Theatre
Rey Bango 作者本人哈哈

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (2)</title><link>http://taoalpha.me/blog/2015/06/30/read-coffeescript-programming-with-jquery-rails-and-nodejs-2/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-30T04:00:00.000Z</pubDate><description>SummaryAfter learned the basic syntax of CoffeeScript, I re-wrote all my blog’s js files with CoffeeScript. I have to say, practice is the best way to learn and understand one skill. Especially for coding, if you just read the book and never write a single line by yourself, you will never become a master of it or you may stick in the beginner for ever.
Today we will finish the book. Talking about how to combine the CoffeeScript with some other web tools we use a lot: jQuery, Rails and Nodejs.
NotesHere I just ignored the second chapter about how to install the coffeescript and nodejs in your computer, if you need some help, feel free to comment below the blog or just visit the nodejs and coffeescript to find a way yourself.
jQueryjQuery is the most popular js module people used in their websites or webapps. And using jQuery with CoffeeScript is just like javascript. jQuery is javascript, after all.
Want to use CoffeeScript with jQuery? Just do it and follow the rules we learn from the basic syntax part. Here I list several examples and if you look it closely, you will find everything you have already known if you read the first chapter carefully. The author of the book shows us another complex examples: TodoMVC in CoffeeScript.
BTW: TodoMVC is a great project which shows you how to write a todo app in all kinds of tools and frameworks.
1234567891011121314151617181920212223242526272829303132333435363738394041$ -&amp;gt;  do some  do another### =&amp;gt;$(function() &amp;#123;  some();  return another();&amp;#125;);That's just like the $(document).ready(function()&amp;#123;&amp;#125;)#### A function using ajax to send mail, which is a new feature I will add to my blog in a few days :)@sendMail = (msg)-&amp;gt;  $.ajax    type: 'POST'    url: 'https://mandrillapp.com/api/1.0/messages/send.json'    data:      'key': ''      'message':        'from_email': msg.sender_mail        'from_name' : msg.sender_name        'to': [            &amp;#123;              'email': ''              'name': 'TaoAlpha'              'type': 'to'            &amp;#125;          ]        'autotext': 'true'        'subject': msg.subject        'html': msg.content  .done (response)-&amp;gt;    showAlert(&quot;success&quot;,&quot;Thanks for your contribution!&quot;)  .fail (data)-&amp;gt;    showAlert(&quot;fail&quot;,&quot;Sorry! Failed to send the email. Please retry!&quot;)# another function to get unique result from an array of objectsArray::getObjectUnique = (id) -&amp;gt;  a=b=[];  add = (data) -&amp;gt; b.push data[id];data  (add i for i in @ when b.indexOf(i[id]) == -1 )
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// You can see that you have saved a lot of keystrokes and the codes look more clean and beautiful.// Because coffeescript doesn't support declare global variables directly, and if we want to use the function in other script, we need to declare it into the `this` scope.this.sendMail = function(msg) &amp;#123;  return $.ajax(&amp;#123;    type: 'POST',    url: 'https://mandrillapp.com/api/1.0/messages/send.json',    data: &amp;#123;      'key': '',      'message': &amp;#123;        'from_email': msg.sender_mail,        'from_name': msg.sender_name,        'to': [          &amp;#123;            'email': '',            'name': 'TaoAlpha',            'type': 'to'          &amp;#125;        ],        'autotext': 'true',        'subject': msg.subject,        'html': msg.content      &amp;#125;    &amp;#125;  &amp;#125;).done(function(response) &amp;#123;    return showAlert(&quot;success&quot;, &quot;Thanks for your contribution!&quot;);  &amp;#125;).fail(function(data) &amp;#123;    return showAlert(&quot;fail&quot;, &quot;Sorry! Failed to send the email. Please retry!&quot;);  &amp;#125;);&amp;#125;;# get unque result for array of objectsArray.prototype.getObjectUnique = function(id) &amp;#123;  var a, add, b, i, j, len, results;  a = b = [];  add = function(data) &amp;#123;    b.push(data[id]);    return data;  &amp;#125;;  results = [];  for (j = 0, len = this.length; j &amp;lt; len; j++) &amp;#123;    i = this[j];    if (b.indexOf(i[id]) === -1) &amp;#123;      results.push(add(i));    &amp;#125;  &amp;#125;  return results;&amp;#125;;
RailsRuby on Rails is a web framework that came around in 2004. And it soon became quite popular. Actually many people believe that Rails saved the ruby…
Check this:How to download and install Rails if you haven’t installed it.
Rails’s principles
Convention over configuration


Rails is designed to assume that the programmer will follow certain known conventions, which if used, provide great benefit and much less need to configure the framework.That means that the framework makes assumptions on how a typical application should be built and structured and it doesn’t try to be overly flexible and configurable. This helps you spend less time on mundane tasks like configuring and wiring up an application architecture and more time on actually building your app.


Don’t repeat yourself, or DRY


Every piece of knowledge must have a single, unambiguous, and authoritative representation within a system.Rails strives to remove duplication and boilerplate wherever it can.

How to use Rails with CoffeeScriptLuckily, after Rails 3.1, you don’t need do anything to let Rails support CoffeeScript. It has already become part of rails! And also, rails has changed its default js library to jQuery.
So what you need to do if you want to use coffeescript with rails? Nothing but learn rails!
Just like the author said in the book: “If you haven’t done so already, I encourage you to spend some more time learning Rails as well as Ruby, and immersing yourself in the wonderful communities they support.”
Node.jsNode is fantastic. It changes something. Before node, javascript was mostly run inside browsers. Now it just came out and gave web developers a chance to become a full-stack!
Features of Node
Event-driven


The Node.js framework only allows non-blocking, asynchronous I/O. This means that any I/O operation that is accessing an external resource, such as the operating system, a database, or a network resource must happen asynchronously.


Fast and scalable


The V8 JavaScript engine(created by google and used in chrome) used by Node.js is highly optimized for performance, thus making Node.js applications very fast. The fact that Node is non-blocking will ensure that your applications will be able to handle many concurrent client requests without using a lot of system resources.


Node is not Rails


Rails strives to be a full-stack solution to building web applications, whereas Node.js is more of a low-level system for writing any type of fast and scalable network application.

Node and CoffeeScriptWant to write coffeescript in node? It’s easy, all you need is a module named CoffeeScript. And like many other languages, node has several frameworks people built for web development, like: Express.
The core about how to use coffeescript with nodejs is to use the --watch for coffee command in node. It will automatically compile all file end with coffee into js when there is a change made into these files.
And just like jQuery, you just follow the rules and write your code.
DigestCoffeeScript is a tool that can help you write js more quickly and elegant. And any platform or language you want to use coffeescript, what you need to do is following the coffeescript’s rules. There is no difference caused by platform or language.
That’s all. Thanks!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (1)</title><link>http://taoalpha.me/blog/2015/06/28/read-coffeescript-programming-with-jquery-rails-and-nodejs/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-28T04:00:00.000Z</pubDate><description>SummaryThe notes I took while I was learning the ‘CoffeeScript’. If you are a real beginner with ‘CoffeeScript’, I suggest you start with another book called “The Little Book on CoffeeScript”, it’s better for beginners. And after that, this one is definitely your best choice.
CoffeeScript is a language which complies to JavaScript. Like the sass or scss to css except that CoffeeScript is not compatible with javascript. So you can not mix the javascript syntax with the CoffeeScript.
This note is mainly about the fist chapter of the book, a nice introduction for CoffeeScript including the basic syntax.

And to improve my english, I think i will start writing english notes for the english books. ^_^

NotesCoffeeScript is pretty popular in the community of JavaScript for its simplicity, elegant and readable. Now let us dive into it.
Instead of  listing the keywords and statements used in CoffeeScript one by one, it would better we learn CoffeeScript from comparing the difference between the CoffeeScript and JavaScript.
CoffeeScript fix some ugly stuffs in JavaScript
CoffeeScript removes most of the semicolons and the curly braces which used a lot in JavaScript, gives us a clearly view of the code, but you can still use the semicolons if you want, and you still have to use the semicolons if you want to put multiple statements in single one;
CoffeeScript learns a lot from ruby and python. Like this one: it uses whitespace or indentation, more accurately, to delimit the code blocks instead of braces.
CoffeeScript removes a lot of parenthesis for many statements and functions, like if..else, while loops and functions with single string parameter. But this is optional, you can still use them if you want. Notice: you will need parenthesis if you want to call a function without any parameters)
Function: as the first class object in JavaScript, CoffeeScript also does a lot improvements for it.
If you write js, you will know that the syntax is really ugly when you want to write a anonymous function. Now you can make it pretty beautiful with CoffeeScript;
CoffeeScript also saves you a lot keystrokes for defining the functions;
so what are the rules?
Replace the function keyword with -&amp;gt;;
Drop the parenthesis if there is no argument for the function;
Put the arguments enclosed with parenthesis in front of the -&amp;gt;, and if the argument has a default value, you can set it in the parenthesis;
Drop the curly braces and use indentation for the function body;
Automatically return the last expression of the function, but if you need return something before, you still need to use the return;





1234567891011121314151617 -&amp;gt; alert 'hi there!'# the code above won't self-initiating, if you want to do that, you need use parenthesis or the `do` keyword like below:# (-&amp;gt; alert 'hi there!')()# do -&amp;gt; alert 'hi there!'square = (n=1) -&amp;gt; n * n# function using splats# this is an alternative way for using Array.prototype.slice()gpaScoreAverage = (scores...) -&amp;gt;  total = scores.reduce (a, b) -&amp;gt; a + b  total / scores.lengthalert gpaScoreAverage(65,78,81)scores = [78, 75, 79]alert gpaScoreAverage(scores...)
1234567891011121314151617181920212223242526272829303132333435var square;(function()&amp;#123;  return alert(&quot;hi there!&quot;);&amp;#125;);/* the code in comments above will compile to:(function()&amp;#123;  if (n == null) &amp;#123;    n = 1;  &amp;#125;  return alert(&quot;hi there!&quot;);&amp;#125;)();*/square = function(n) &amp;#123;  return n * n;&amp;#125;;// [].slice.call(arguments,0) ==&amp;gt;  Array.prototype.slice.call(arguments,0)var gpaScoreAverage, scores,  slice = [].slice;gpaScoreAverage = function() &amp;#123;  var scores, total;  scores = 1 &amp;lt;= arguments.length ? slice.call(arguments, 0) : [];  // get the single score value or a list of the scores  total = scores.reduce(function(a, b) &amp;#123;    return a + b;  &amp;#125;);  return total / scores.length;&amp;#125;;alert(gpaScoreAverage(65, 78, 81));scores = [78, 75, 79];alert(gpaScoreAverage.apply(null, scores));
CoffeeScript saves you a lot of keystrokes
CoffeeScript will declare the variables you need at the top of the function for you automatically. So that means you can’t create the global variables in a function like you can do in JavaScript, actually you can’t use the var keyword in CoffeeScript. &amp;lt;= many people agree that omitting the var keyword makes the variables become global is a really bad desgin…
Object:
CoffeeScript supports the class keyword, and it will create a closure to build the class;
Use the constructor to initialize some private properties, or just omit it;
Every function you define in a class will be added to the object as a prototype method;
Use @ as a shortcut for this;
fat arrow: When you want to use this in previous scope instead of the new scope, you need the fat arrow : =&amp;gt;;
Use super to call the parent’s method (same name, so just pass the parameter);
Use :: as a shortcut for .prototype, so you can extend your prototype as this:Vehicle::stop =-&amp;gt; alert &amp;#39;stop&amp;#39;;



123456789101112131415161718192021222324252627282930313233class Vehicle  # Use the constructor to initialize some private properties  # Use @ as this  constructor: -&amp;gt;    @c = 1  drive: (km) -&amp;gt;    alert &quot;Drove #&amp;#123;km&amp;#125; kilometres&quot;class Car extends Vehicle constructor: -&amp;gt;   @odometer = 0 drive: (km) -&amp;gt;   @odometer += km   super km name:&quot;John Doe&quot; driver: (msg) -&amp;gt;   @msg = msg whoisdriver: -&amp;gt;   @msg()car = new Carcar.drive 5alert &quot;Odometer is at #&amp;#123;car.odometer&amp;#125;&quot;class Person  constructor: (name)-&amp;gt;    @name = name    @mycar = new Car()    @mycar.driver =&amp;gt; alert &quot;#&amp;#123;@name&amp;#125;&quot;mike = new Person &quot;Mike&quot;# use `=&amp;gt;` to show mike's name instead of the default `john doe` set in Carmike.mycar.whoisdriver()
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var Car, Person, Vehicle, car, mike,  extend = function(child, parent) &amp;#123; for (var key in parent) &amp;#123; if (hasProp.call(parent, key)) child[key] = parent[key]; &amp;#125; function ctor() &amp;#123; this.constructor = child; &amp;#125; ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; &amp;#125;,  hasProp = &amp;#123;&amp;#125;.hasOwnProperty;Vehicle = (function() &amp;#123;  function Vehicle() &amp;#123;    this.c = 1;  &amp;#125;  Vehicle.prototype.drive = function(km) &amp;#123;    return alert(&quot;Drove &quot; + km + &quot; kilometres&quot;);  &amp;#125;;  return Vehicle;&amp;#125;)();Car = (function(superClass) &amp;#123;  extend(Car, superClass);  function Car() &amp;#123;    this.odometer = 0;  &amp;#125;  Car.prototype.drive = function(km) &amp;#123;    this.odometer += km;    return Car.__super__.drive.call(this, km);  &amp;#125;;  Car.prototype.name = &quot;John Doe&quot;;  Car.prototype.driver = function(msg) &amp;#123;    return this.msg = msg;  &amp;#125;;  Car.prototype.whoisdriver = function() &amp;#123;    return this.msg();  &amp;#125;;  return Car;&amp;#125;)(Vehicle);car = new Car;car.drive(5);alert(&quot;Odometer is at &quot; + car.odometer);Person = (function() &amp;#123;  function Person(name) &amp;#123;    this.name = name;    this.mycar = new Car();    this.mycar.driver((function(_this) &amp;#123;      return function() &amp;#123;        return alert(&quot;&quot; + _this.name);      &amp;#125;;    &amp;#125;)(this));  &amp;#125;  return Person;&amp;#125;)();mike = new Person(&quot;Mike&quot;);mike.mycar.whoisdriver();
Other Good Things
CoffeeScript will quote reserved words automatically if you use them in your literal object;
You can also drop the comma when you define your literal array or literal object only if you put one property per line, you can drop the braces for object, but you need them for array;
Use #{variable_name} to concatenate the string and variables instead of +, but only use them enclosing with double-quote, the single-quote strings are literal, borrowed from ruby;
CoffeeScript will always convert the == and != to === and !==;
Use the existential operator: ? to check whether a variable exists and has a value or not(means not null or undefined);
Also use the soak: ?. as a shortcut for ternary statement;
Support some new keywords like unless, the opposite to if;
Use plain english aliases for some of the logical operators: is for ===,isnt for !==,not for !,and for &amp;amp;&amp;amp;,or for ||,true can also be yes, or on,false can be no or off;
Support assign multiple values at once;
CoffeeScript replaces the case in switch with when ... then, so you can forget about the break, and it also replaces the default with else;
CoffeeScript supports the chained comparisions: 61 &amp;gt; a &amp;gt; 39;
You can use ### to comment multiple lines. The biggest difference between ### and # is former one will be part of generated javascript;

1234567891011121314151617b=1if a? &amp;amp;&amp;amp; b?  alert &quot;a.c equals to #&amp;#123;a?.c&amp;#125;&quot;[city, state, country] = [&quot;!2&quot;,&quot;24&quot;,&quot;2&quot;]# or function which returns an object with the same structure as you described before the `=`&amp;#123;address: &amp;#123;street: myStreet,room: myRoom&amp;#125;&amp;#125; = getAddress()### =&amp;gt;var b;b = 1;// since we declared the b before, we only need to check if b is null.if ((typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null) &amp;amp;&amp;amp; (b != null)) &amp;#123;  alert(&quot;a.c equals to &quot; + (typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null ? a.c : void 0));&amp;#125;var city, country, myRoom, myStreet, ref, ref1, state;ref = [&quot;!2&quot;, &quot;24&quot;, &quot;2&quot;], city = ref[0], state = ref[1], country = ref[2];ref1 = getAddress().address, myStreet = ref1.street, myRoom = ref1.room;###
Special for List
List: CoffeeScript borrowed a lot list comprehensions from python[ x*2 for x in object_name ] and ruby.
while: it works nearly the same as in javascript except that it has an opposite keyword in CoffeeScript: until and both of them can be used as expression and will return a array;
for: the standard statement is [action or mapping] for [selector] in [collection] when [condition] by [step]. Last by following with a number would affect the loop step(`i++``);
[f_number..l_number]: it will create a array with numbers between the fist number and the last number, you can use ...(3 dots) to make the array only contains the numbers in between;
of: for key-value pairs of an object, you can use of to loop them through;



1234567891011121314151617181920212223242526272829303132333435363738394041times = [0..2](n*times while times -= 1).pop()### =&amp;gt; var times; times = [0, 1, 2];((function() &amp;#123;  var results;  results = [];  while (times -= 1) &amp;#123;    results.push(n * times);  &amp;#125;  return results;&amp;#125;)()).pop();###alert x for x in flavors when x != 'h' by 2###=&amp;gt;var x, i, len;for (i = 0, len = flavors.length; i &amp;lt; len; i+=2) &amp;#123;  x = flavors[i];  if (x !== 'h') &amp;#123;    alert(x);  &amp;#125;&amp;#125;###ages = john: 25 peter: 26 joan: 23alert &quot;#&amp;#123;name&amp;#125; is #&amp;#123;age&amp;#125; years old&quot; for name, age of ages###=&amp;gt;var age, ages, name;ages = &amp;#123;  john: 25,  peter: 26,  joan: 23&amp;#125;;for (name in ages) &amp;#123;  age = ages[name];  alert(name + &quot; is &quot; + age + &quot; years old&quot;);&amp;#125;###
Digest
For JavaScript:
Every class in JS is a function object;
Only function object has the default prototype, so the normal objects like literal string, number or even string created from String(),any objects created by functions, they all don’t have the default prototype;
But every object has a default constructor which is exactly the function object who create it;


For CoffeeScript:
If there is only one line in the body, you can move it in front of the condition &amp;lt;= while/until/for/if...



Puzzle
Q1: In the second code example above, CoffeeScript create a default extend function for us:

123456789101112131415161718192021var extend = function(child, parent) &amp;#123;  for (var key in parent) &amp;#123;      if (hasProp.call(parent, key)) child[key] = parent[key];  &amp;#125;  // Start from here  function ctor() &amp;#123;      this.constructor = child;  &amp;#125;  ctor.prototype = parent.prototype;  child.prototype = new ctor();  // End  // Just cannot understand the codes above...  // Why we need another function as the child's prototype? We have already copied all the properties from parent, or we just need a beautiful prototype chain? `Car &amp;lt;= ctor() &amp;lt;= Vehicle() &amp;lt;= Object` compared to `Car &amp;lt;= Car &amp;lt;= Object()`.  // Then why not we just use the child.prototype = new parent() ??? we can still get a good prototype chain. `Car &amp;lt;= Vehicle &amp;lt;= Vehicle &amp;lt;= Object`.  child.__super__ = parent.prototype;  return child;&amp;#125;,hasProp = &amp;#123;&amp;#125;.hasOwnProperty;
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (1)</title><link>http://taoalpha.me/blog/2015/06/17/read-reading-javascript-the-definitive-guide-1/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-17T10:00:00.000Z</pubDate><description>概述“JavaScript: the definitive guide”可谓是JS入门必读数目之一了. 今天正好读到第7章, 做一简单总结. 前7章的内容都集中在JS中的基本知识上, 包含了:

数据类型: 最简单的primitive datatypes: string, number, boolean , 两个空值类型: null, undefined(通常认为空值类型属于promitive的一种),以及稍微复杂点的: object类型;
变量问题: 变量规则, 变量作用域问题;
基础表达式和操作符: 操作符的优先级问题, 多操作数和单操作数以及执行顺序等;
陈述语句: 包含了if/for/while/do/with/switch(case)/break/continue/return/var/identifiers/empty statement等等;
Object: json格式object以及常规的array类型对象的分别介绍以及自身结构属性, 异同点等;

心得break/continue 后接 label:  break/continue是通常用于for/white/do等循环语句中用以做状态判断的, 但本身其还有另一种用法, 就是通过后接标记语句的用法来是break或者continue能针对标记语句操作, 比如下面这个跳出多层嵌套的例子:
12345678910test:&amp;#123;  for(var i = 0; i&amp;lt; 10; i++)&amp;#123;    for(var j = 0; j&amp;lt; i*5; j++)&amp;#123;      console.log(j);      if(j==3) break test;    &amp;#125;  &amp;#125;&amp;#125;// continue test; 也是同样的用法
但需要注意的即使:

continue 语句(带有或不带标签引用)只能用在循环中;
break 语句(不带标签引用),只能用在循环或 switch 中;

with 语句在js中经常涉及到变量作用域的问题, 而with语句的存在就是可以将某个object放入到其子语句的作用域链中, 什么意思呢? 首先通常来说, 在函数内, 其作用域链由全局作用域(全局对象)和本地作用域(local对象)组成, 我们在引用变量的时候就是在作用域链上逐个查询. 而with的作用就是把某个object插入到作用域链中去, 从而能够直接访问其子元素:
1234567891011a = &amp;#123;&quot;nae&quot;:&quot;hhh&quot;,&quot;test&quot;:&quot;results&quot;&amp;#125;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;nae = &quot;sl&quot;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;// 证明with引入的作用域甚至还在global域之上
不过呢, 通常很少人会去用with的, 因为它过于吃力不讨好了, 其对性能的影响是没有什么优化空间的, 与其使用with, 不如直接定义全局变量或者变量的简写(有一种with的用法是为了省略书写冗长的变量名)更为方便了.
sort内嵌比较函数:sort()本身作为array类型内置的几个函数之一, 默认通常是按照字母表来排序的, 但是其本身也是支持自定义排序规则的, 只需要我们把规则传入即可:
12345678910// 以数字序列为例var a = [12,3,5,8]a.sort()// output: [12,8,5,3]a.sort(function(a,b)&amp;#123;return a - b;// 返回&amp;lt;0, 则a排在b前面, &amp;gt;0 则b在前面, =0则表示相等;&amp;#125;)// output: [3,5,8,12]
利用这一方法你就可以定制你的排序规则了, 甚至可以按照奇偶性排序都可以做到~ 比如 偶数在前: return a % 2-b % 2; 哈哈
concat,slice,splice这三个函数分别都是对array类型的元素进行母串增减获取子串而出现的, 其中有几点需要注意的:

concat()函数支持数字多参数分别传入, 也支持数组传入的形式, 效果都是一样的, 但是concat()不支持递归解套, 即如果你传入的是多层嵌套的数组, concat()只会解套一次; 此外, concat()的操作是不影响母串的;
slice和splice都可以用于获取子数组使用的, 其区别主要有两点, slice()接受的两个参数都代表的是index, 分别是起始次序到终止元素次序, 取子串时计算首位参数的元素,不计算第二位参数所代表的元素, 而splice则传入的两个参数分别是起始元素次序和要截取元素个数,即同样都是(1,2), 后者代表截取第二个元素起始共计两个元素的子串, 前者则只获取第二个元素; 此外, slice()返回子串而不修改原数组, splice()则会在返回子串的同时修改原数组(原数组为去除子串的结果);
splice()除了可以用获取子串外, 还能用于给母串添加元素. splice()可以接受超过2个参数, 从第三个参数起, 多出来的参数都是作为插入元素的, 执行的顺序则是删减完后当前位置插入, 即splice(2,2,1,3,4)表示的就是删掉第三个元素开始共计两个元素, 然后在同样的位置插入1,3,4三个元素, 同时, splice()也接受数组传入, 但是它不主动进行解套;

除了splice(), 上面的sort()的操作也是针对a数组进行的操作, 其结果也是针对a生效的, 即a的值是会被改变的;
pop,push,shift,unshift除了splice()之外, 我们通常用于直接操作母串增减的就是pop,push,shift,unshift四个了, 下面简单介绍下四者的区别:

pop, push分别代表对母串最后一个元素的进出栈操作, pop是弹出最后一个元素, push则是在最后一个元素的后面继续压入新元素, 同样也支持数组元素压入, 但是不自动解套;
shift, unshift和pop,push基本类似, 不同的地方在于操作的位置和后者相反, 是在栈头的位置, 即首位元素处; shift用于移出首位元素, unshift用于在首位增加元素, 接受数组, 也不自动解套, 同时多参数传入时, 作为整体一次性压入, 即unshift(2,3),压入后为[2,3,...].

这里比较独特的就是unshift多参数的压入问题了, 按我的预期其实是逐个元素压入, 这样顺序就是和传参相反, 但结果确实整体压入, 顺序与传参一致了~
谜题书中第七章介绍说在array中如果直接赋值的index是超限(&amp;gt;2^32-1), 负值或者对应表达式的结果是此类值时, 会自动转为string传入定义, 这就引发了一个问题: 一旦如此定义后, 此变量还是array吗?
我在console中简单的测试了下:
1234567891011121314151617181920var a = [1,2,3]// a.length == 3a[-1.2] = &quot;hehe&quot;a// output: [1,2,3]  where is a[-1.2] ?a[-1.2]// output: &quot;hehe&quot;  WTF???a.length// output: 3 ??console.log(a)// output: [1,2,3,-1.2:'hehe']console.log(a.length)// output: 3a instanceof Array// ouput: Truea[&quot;h&quot;] = &quot;hh&quot;a// output: [1,2,3]console.log(a)// output: [1,2,3,-1.2:&quot;hehe&quot;,h:&quot;hh&quot;]
问题: a依然还是一个Array(亦或者不是?), 但用json定义的方式赋值的那几个值还是有效的, 可获取的, 但是为什么直接print出来的时候没有这些值呢, 甚至长度都不包含定义的这几个指? 为什么console.log()可以打出来呢?
猜测解释: a最初被定义为array, 但是却被json方式传值, 存储到了其内存中, 但是调用a时依然按照array来打印, 所以会自动滤除掉不符合array的几个值(只会按照index来找值). 但是console.log()是打出来其存储内容, 所以就按照其内存存储形式打印出来了.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>像TED一样演讲</title><link>http://taoalpha.me/blog/2015/06/25/read-speaking-like-people-on-ted/</link><category>read</category><tag>reading notes,speaking</tag><pubDate>2015-06-25T09:00:00.000Z</pubDate><description>概要今天顺带读完了这本”像TED一样演讲”, 作者上一部和演讲相关的书是”乔布斯的魔力演讲”. 归纳了下书中的核心点, 记录分享给大家. 这一类的书干货其实能占到全书1/10就已经算不错了~ 所以一般看起来也比较快.
阅读笔记情感共鸣
释放你内心的热情 =&amp;gt; 热情可以传染;
掌握讲故事的艺术 =&amp;gt; 故事可以刺激并吸引人脑的注意力, 拉近你与听众的距离;
与演讲主题相关的个人故事;
与演讲主题相关的他人故事;
关于产品或者品牌的某个故事;


让演讲好像好友交谈一样自然;

制造新奇
给人们一个看世界的新视角;
设计让观众惊掉下巴的环节 =&amp;gt; 触发神经学家所说的讲情绪, 让记忆更加深刻;
用幽默给你的演讲加分;

令人难忘
严格遵守18分钟的时间规则 =&amp;gt; 有约束才有创造力;
抓住观众吸引力的魔法, 多感官体验 =&amp;gt; 让内容视觉化;
表现最真实的自己;

书中涉及到的TED(部分)
Bryan Stevenson: We need to talk about an injustice
Dan Ariely: Our buggy moral code
Truly sustainable economic development
Jennifer Granholm: A clean energy proposal – race to the top!
Amy Cuddy: Your body language shapes who you are
Robert Ballard: The astonishing hidden world of the deep ocean
Hans Rosling: The best stats you’ve ever seen
Mary Roach: 10 things you didn’t know about orgasm
Bill Gates: Mosquitos, malaria and education
Jill Bolte Taylor: My stroke of insight
Stephen Hawking: Questioning the universe
David Christian: The history of our world in 18 minutes

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript Coding Style</title><link>http://taoalpha.me/blog/2016/01/09/read-javascript-coding-style/</link><category>read</category><tag>JS,coding style</tag><pubDate>2016-01-10T01:49:12.000Z</pubDate><description>Why and What is Coding StyleCoding style is like the common styles and patterns that are used in your personal codebase or some organizations’ codebase, its purpose is making your code more readable and reusable through the entire developemnt, especially when you work in a team. Everyone can create their own coding style, there is no right or wrong among them, like you prefer 4 spaces than 2 spaces, you like to use camelCase represent the functions and variables,that’s totally fine. 
The benefit of using the same style is obvious, it can save you a lot of time reading and modifying others’ code or even your own code. There are some styles that are pretty popular and agreed by a lot of people and team, like Google Style Guide. Being modified and updated for so many years, I believe these styles would be a better choice to choose rather than create one by yourself.
Javascript Style GuideThere are several popular style guide for javascript, one is the part of the Google Style Guide series:  Google JavaScript Style Guide, another is created by airbnb:Airbnb JavaScript Style Guide, and also there is a Code Conventions for the JavaScript Programming Language created by the author of JavaScript: The Good Parts.
I read them all and summarize the core parts here.
Google JavaScript Style GuideHere I ignore all parts related to the Google Closure Compiler, if you are interested in, take a look at Closure Compiler.
Syntax &amp;amp; Basic Concept
var: never declare a variable without var to save you from global variables;
semicolons: always use semicolons, sometimes the closing brackets are not enough to signal the end of the statement: Javascript never ends a statement if the next token is an infix or bracket operator;
new: Never use wrapper objects for primitive types(like new Boolean(false), return an object!), but can use Boolean(0) to do casting, also for array and object, use literal syntax instead of new; 
prototye: Use prototype to attach methods to an object created via new, initialize other properties within constructor,Current JavaScript engines optimize based on the “shape” of an object, adding a property to an object (including overriding a value set on the prototype) changes the shape and can degrade performance., and NEVER modify prototype of builtins like Object and Array;
delete: Use set to null instead of delete to delete some properties, but if the number of properties of the object matters, use delete;
closure: Be careful to use closure since it might cause memory leak;
eval,with(){}: Just don’t use them;
for-in-loop: Only use it to iterate the key of object/hashmap;
quote: Use single quote &amp;#39;&amp;#39; for strings, use string concatenation if the string is too long;

Naming
CONSTANT_NAME: always use ALL_CAP_SNAKE_CASE represent the constant;
functionName,variableName,methodName: use camelCase represent the functions and variables, methods;
ClassName,EnumNamesLikeThis: use CamelCase represent class or enums;
filenameslikethis.js: use plain lowercase as the name of the files;
_private: private should be named with a trailing underscore;
opt_: Optional function arguments start with opt_;
global: try not to contaminate the global, can use a global object to store all variables you want to use as gloabl scope - prevent some conflicts between global and local;

Comments &amp;amp; JSDocJust remmeber that comments is written for someone who isn’t familiar with the code including youself after a long time!
Here is some resouces about the JSDoc
TipsSome Boolean Expressions1234567891011121314151617Boolean('0') == true'0' != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&amp;#123;&amp;#125;) == true&amp;#123;&amp;#125; != true&amp;#123;&amp;#125; != false
Better For Loop1234var paragraphs = document.getElementsByTagName('p');for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) &amp;#123;  doSomething(paragraph);&amp;#125;
BE CONSISTENTAirbnb JavaScript Style GuideI will address some difference between this one and google’s.
Syntax &amp;amp; Basic Concept
const: Alwasy use const on references instead of var, ensure that you can not reassign your reference, Block-scoped;
let: If you must reassign references, use let instead of var, Block-scoped;
reserved words: don’t use reserved words as keys;
object shorthand: use object shorthand for method and value defined in an Object, and also put all shorthands at the beginning of the object declaration;

123456789101112131415161718// methodconst atom = &amp;#123;  value: 1,  addValue(value) &amp;#123;    return atom.value + value;  &amp;#125;,&amp;#125;;// value, if value and key are the same// put all shorthands at the beginning// only quote properties that are invalid identifiersconst obj = &amp;#123;  lukeSkywalker,  foo: 3,  bar: 4,  'data-blah': 5,&amp;#125;;

spreads: Use ... to copy arrays: const itemsCopy = [...items]; 
Array.from(): Use Array.from() convert an array-like object to an array;
destructuring: Use object and array destructuring when accessing and using multiple properties of an object;

123456789101112131415161718192021222324// goodfunction getFullName(user) &amp;#123;  const &amp;#123; firstName, lastName &amp;#125; = user;  return `$&amp;#123;firstName&amp;#125; $&amp;#123;lastName&amp;#125;`;&amp;#125;// bestfunction getFullName(&amp;#123; firstName, lastName &amp;#125;) &amp;#123;  return `$&amp;#123;firstName&amp;#125; $&amp;#123;lastName&amp;#125;`;&amp;#125;// array destructuringconst arr = [1, 2, 3, 4];const [first, second] = arr;// Prefer object destructuring for multiple return values to array destructuring// goodfunction processInput(input) &amp;#123;  // then a miracle occurs  return &amp;#123; left, right, top, bottom &amp;#125;;&amp;#125;// the caller selects only the data they needconst &amp;#123; left, right &amp;#125; = processInput(input);

template strings: When programmatically building up strings, use template strings instead of concatenation;
functions declarations: Use function declarations instead of function expressions, when you must use function expressions (as when passing an anonymous function), use arrow function notation;

1234567891011121314151617181920212223242526272829// badconst foo = function () &amp;#123;&amp;#125;;// goodfunction foo() &amp;#123;&amp;#125;// use arrow functions as function expressions// immediately-invoked function expression (IIFE)(() =&amp;gt; &amp;#123;  console.log('Welcome to the Internet. Please follow me.');&amp;#125;)();// No function declarations should be in a block// badif (currentUser) &amp;#123;  function test() &amp;#123;    console.log('Nope.');  &amp;#125;&amp;#125;// goodlet test;if (currentUser) &amp;#123;  test = () =&amp;gt; &amp;#123;    console.log('Yup.');  &amp;#125;;&amp;#125;

arguments: Don’t use it, use ...args instead;

12345678910function concatenateAll(...args) &amp;#123;  return args.join('');&amp;#125;```  - `default value`: Use default parameter syntax rather than mutating function arguments, and always put default parameters last;``` javascriptfunction handleThings(name, opts = &amp;#123;&amp;#125;) &amp;#123;  // ...&amp;#125;

spacing: put space between function name and the brackets and curly brackets;
parameter: Never mutate parameters, Never reassign parameters;

123456789// badfunction f1(obj) &amp;#123;  obj.key = 1;&amp;#125;;// goodfunction f2(obj) &amp;#123;  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;&amp;#125;;

arrow functions: 
If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement;
and if the expression spans over multiple lines, wrap it in parentheses;
If your function takes a single argument and doesn’t use braces, omit the parentheses;



12345678910111213141516171819// good[1, 2, 3].map(number =&amp;gt; `A string containing the $&amp;#123;number&amp;#125;.`);// bad[1, 2, 3].map(number =&amp;gt; &amp;#123;  const nextNumber = number + 1;  `A string containing the $&amp;#123;nextNumber&amp;#125;.`;&amp;#125;);// good[1, 2, 3].map( (number) =&amp;gt; &amp;#123;  const nextNumber = number + 1;  return `A string containing the $&amp;#123;nextNumber&amp;#125;.`;&amp;#125;);[1, 2, 3].map(number =&amp;gt; (  `As time went by, the string containing the $&amp;#123;number&amp;#125; became much ` +  'longer. So we needed to break it over multiple lines.'));

class: Always use class. Avoid manipulating prototype directly;
extends: Use extends for inheritance;
methods: Methods can return this to help with method chaining;

123456// goodclass PeekableQueue extends Queue &amp;#123;  peek() &amp;#123;    return this._queue[0];  &amp;#125;&amp;#125;

import: Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system, which means don’t use require etc;
Do not use wildcard imports;
And do not export directly from an import;



1234567891011121314// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide';// bad// filename es6.jsexport &amp;#123; es6 as default &amp;#125; from './airbnbStyleGuide';// good// filename es6.jsimport &amp;#123; es6 &amp;#125; from './AirbnbStyleGuide';export default es6;

iterators and generators:
Don’t use iterators. Prefer JavaScript’s higher-order functions like map() and reduce() instead of loops like for-of;
Don’t use generators for now.



123456789101112131415161718const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &amp;#123;  sum += num;&amp;#125;sum === 15;// goodlet sum = 0;numbers.forEach((num) =&amp;gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&amp;gt; total + num, 0);sum === 15;

properties:

Use dot notation when accessing properties;
Use subscript notation [] when accessing properties with a variable;


variables:

Always use const to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that;
Use one const declaration per variable;
Group all your consts and then group all your lets;
Assign variables where you need them, but place them in a reasonable place;


hoisting:

var declarations get hoisted to the top of their scope, their assignment does not; 
const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ);
It’s important to know why typeof is no longer safe;
Anonymous function expressions hoist their variable name, but not the function assignment;
Named function expressions hoist the variable name, not the function name or the function body;
Function declarations hoist their name and the function body;



1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// using const and letfunction example() &amp;#123;  console.log(declaredButNotAssigned); // =&amp;gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned); // =&amp;gt; throws a ReferenceError  const declaredButNotAssigned = true;&amp;#125;// assignment will not be hoistedfunction example() &amp;#123;  console.log(anonymous); // =&amp;gt; undefined  anonymous(); // =&amp;gt; TypeError anonymous is not a function  var anonymous = function () &amp;#123;    console.log('anonymous function expression');  &amp;#125;;&amp;#125;function example() &amp;#123;  console.log(named); // =&amp;gt; undefined  named(); // =&amp;gt; TypeError named is not a function  superPower(); // =&amp;gt; ReferenceError superPower is not defined  var named = function superPower() &amp;#123;    console.log('Flying');  &amp;#125;;&amp;#125;// the same is true when the function name// is the same as the variable name.function example() &amp;#123;  console.log(named); // =&amp;gt; undefined  named(); // =&amp;gt; TypeError named is not a function  var named = function named() &amp;#123;    console.log('named');  &amp;#125;&amp;#125;// BUT! Function declarations hoist their name and the function body.function example() &amp;#123;  superPower(); // =&amp;gt; Flying  function superPower() &amp;#123;    console.log('Flying');  &amp;#125;&amp;#125;

Comparison Operators &amp;amp; Equality:
Use === and !== over == and !=;
Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules:
Objects evaluate to true
Undefined evaluates to false
Null evaluates to false
Booleans evaluate to the value of the boolean
Numbers evaluate to false if +0, -0, or NaN, otherwise true
Strings evaluate to false if an empty string ‘’, otherwise true





Comments
Use /** ... */ for multi-line comments. Include a description, specify types and values for all parameters and return values;
Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block;
Prefixing your comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that needs to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME – need to figure this out or TODO – need to implement;

12345678910111213/** * make() returns a new element * based on the passed in tag name * * @param &amp;#123;String&amp;#125; tag * @return &amp;#123;Element&amp;#125; element */function make(tag) &amp;#123;  // ...stuff...  return element;&amp;#125;
Spaces
Use soft tabs set to 2 spaces;
Place 1 space before the leading brace;
Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations;
Set off operators with spaces;
End files with a single newline character;
Use indentation when making long method chains. Use a leading dot, which emphasizes that the line is a method call, not a new statement;
Leave a blank line after blocks and before the next statement;
Do not pad your blocks with blank lines;
Do not add spaces inside parentheses;
Do not add spaces inside brackets;
Add spaces inside curly braces;
Avoid having lines of code that are longer than 100 characters (including whitespace);

Commas and Semicolons
Leading commas: NOPE;
Additional trailing comma: Yup;
Always use semicolons;

12345// good (guards against the function becoming an argument when two files with IIFEs are concatenated);(() =&amp;gt; &amp;#123;  const name = 'Skywalker';  return name;&amp;#125;)();
Type Casting &amp;amp; Coercion
Perform type coercion at the beginning of the statement, use String,Number etc instead of other tricky methods;
If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing;
Be careful when using bitshift operations. Numbers are represented as 64-bit values, but Bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits;

12345678910// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &amp;gt;&amp;gt; 0;// be careful2147483649 &amp;gt;&amp;gt; 0 //=&amp;gt; -2147483647
Naming
Avoid single letter names. Be descriptive with your naming;
Use camelCase when naming objects, functions, and instances;
Use PascalCase when naming constructors or classes;
Use a leading underscore _ when naming private properties;
Don’t save references to this. Use arrow functions or Function#bind;
If your file exports a single class, your filename should be exactly the name of the class;
Use camelCase when you export-default a function. Your filename should be identical to your function’s name;
Use PascalCase when you export a singleton / function library / bare object;

1234567891011121314// badfunction foo() &amp;#123;  const that = this;  return function () &amp;#123;    console.log(that);  &amp;#125;;&amp;#125;// goodfunction foo() &amp;#123;  return () =&amp;gt; &amp;#123;    console.log(this);  &amp;#125;;&amp;#125;
Accessors
Accessor functions for properties are not required;
If you do make accessor functions use getVal() and setVal(‘hello’);
If the property is a boolean, use isVal() or hasVal();
It’s okay to create get() and set() functions, but be consistent;

jQuery
Prefix jQuery object variables with a $;
Cache jQuery lookups;
For DOM queries use Cascading $(&amp;#39;.sidebar ul&amp;#39;) or parent &amp;gt; child $(&amp;#39;.sidebar &amp;gt; ul&amp;#39;);
Use find with scoped jQuery object queries;

1234567891011// goodfunction setSidebar() &amp;#123;  const $sidebar = $('.sidebar');  $sidebar.hide();  // ...stuff...  $sidebar.css(&amp;#123;    'background-color': 'pink'  &amp;#125;);&amp;#125;
TestingYou should write testing!!!
Code Conventions for the JavaScript Programming LanguageAll coved by two styles I list above.
SummaryCompared to google’s old style guide, airbnb’s style guide has much more valuable new ES6 styles, if you are an active ES6 users, I strongly suggest you use airbnb’s style !!!
Even you are a solo worker, you should use some common styles, it is a good habit and you should have.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Using @font-face</title><link>http://taoalpha.me/blog/2014/07/15/read-yi-using-font-face/</link><category>read</category><tag>CSS,font-face,翻译文章,译系列</tag><pubDate>2014-07-15T10:00:00.000Z</pubDate><description>如下例:
123456789@font-face &amp;#123;  font-family: 'MyWebFont';  src: url('webfont.eot'); /* IE9 Compat Modes */  src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */       url('webfont.woff') format('woff'), /* Modern Browsers */       url('webfont.ttf')  format('truetype'), /* Safari, Android, iOS */       url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&amp;#125;
由于如今WOFF是如此之火, 你也可以简化使用:
123456@font-face &amp;#123;  font-family: 'MyWebFont';  src: url('myfont.woff') format('woff'), /* Chrome 6+, Firefox 3.6+, IE 9+, Safari 5.1+ */       url('myfont.ttf') format('truetype'); /* Chrome 4+, Firefox 3.5, Opera 10+, Safari 3—5 */&amp;#125;
其实只用WOFF也可以的, 目前基本主流浏览器都能支持了.
然后你就可以在其他元素中使用这一属性了~ 比如:
1234body &amp;#123;  font-family: 'MyWebFont', Fallback, sans-serif;&amp;#125;
讲讲font-face的历史吧, @font-face是用于加载以及使用你自定义的字体而出现的, 针对的就是如今浏览器有权限使用的系统已有的有限字体. 这里有个系统预装字体的详情介绍.
说到性能. 一般我们认为字体文件都是非常巨大的, 同时还会让你的网站增加很多额外的请求, 这些都会拖慢你的站点速度. 所以在使用之前请务必确保你考虑清楚.
如果你确实要使用自定义字体, 有一种更好的更负责的方式是尽可能的加载足够少的字母和样式种类. 比如, 如果你使用google fonts, 只需要引入一些特定的组合即可:
123@import url(http://fonts.googleapis.com/css?family=Averia+Sans+Libre:400,300italic,700);
甚至可以缩减引入的字符数量.
相比于性能, @font-face似乎经常出现各式各样的bug…比如这种, 这种,还有这种…
关于字体格式, 倒是有几种, 每种都还有些历史.
  WOFF    Web Open Font Format. 是专为网络使用而创造的, 由Mozilla和一些其他组织共同发展起来的, WOFF字体通常比其他格式字体加载的更快, 主要是因为他们使用了比OTF和TTF更加压缩的结构, 这种结构中还能包含一些meta信息和license信息, 目前来说WOFF应该是最大的赢家了, 主流的浏览器基本都已经能够支持了.    SVG/SVGZ    Scalable Vector Graphic(Font). SVG是一种字体的矢量化过程, 主要可以让体积变的更小, 同时也能够用于移动设备. 这个字体格式是4.1版本以下的Safari浏览器唯一支持的字体格式了. 目前来说SVG依然不能被Firefox, IE以及IE 移动版支持. Firefox主要精力都在支持WOFF了~ 天知道他们什么时候支持SVG… SVGZ是SVG的再压缩版本.    EOT    Embedded Open Type. 这一格式是由微软从15年前创造的(真正意义上@font-face的源头). 也是唯一一种IE8以及以下版本支持在@font-face中使用的格式了.    OTF/TTF    OpenType Font 和 TrueType Font. 在一定程度上WOFF格式的出现也是因为这些格式可以很容易被复制, 无论合法与否. 同时, OpenType的某些特性(比如手写字体等)比较吸引设计师们.  


字体服务有很多, 主要就是提供那些你可能无权使用的字体, 从而让你的使用合法化. 主要有以下这些:
  Cloud Typography  Typekit  Fontdeck  Webtype  Typotheque  Fontspring  WebINK  Fonts.com  Google Fonts  Font Squirrel



想要对比下这些服务的好坏?
Source Link:  CSS Tricks
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>User Experience is a feeling</title><link>http://taoalpha.me/blog/2014/11/10/read-t-user-experience-is-a-feeling/</link><category>read</category><tag>UX,产品学习,关于HCI,翻译文章,译系列</tag><pubDate>2014-11-10T14:00:00.000Z</pubDate><description>用户体验是一种感觉

“如果你以’用户体验是一种感觉’为基础, 那么你就算是向真正理解用户体验迈出了一步.”

许多人似乎都认为用户体验是一个可以控制的设计产出–好像它是一个你可以通过你的想法, 设计师以及开发者们从而操纵一个人对某个产品或者服务的体验. 实际上, 用户体验经常被认为是一个定义以及管理用户对产品的感觉.

但是你的产品并不能决定一个用户的体验, 用户自己的行为, 态度以及情感才是决定因素. 因此, 用户体验就是一个感觉. 实际上, 它远不止于此, 但如果你是在此基础上去理解用户体验, 那么你就算是向真正理解用户体验迈出了一步.

一个用户在使用某个产品时的体验是每个产品都需要关注的点. 一个用户可能会有很好的体验也可能会有一个很糟糕的体验. 虽然你不能直接的设计一个用户对一个产品的体验, 但你可以采取一些措施, 应用一些用户为中心的设计原则和流程来确保他们的体验是积极的, 正面的.

你应该把以用户为中心的设计的各种优势告诉那些投资人, 相关利益人从而拿到钱, 而这些优势就包括以下这些:- 快速的获得更多客户- 保留现有的客户- 为你的公司建立信誉- 在公司长期运行中扩大销售额- 降低周边产品/服务(外围设备)的价格, 比如客服/售后- 减少无形的花费, 比如浪费的时间- 完成的更加高效

对于你的公司而言, 无论是一个创业公司还是说一个庞然巨物, 都要意识到这些利处, 而你所在的产品团队则需要:

理解伟大的设计和优质的体验之间的区别像用户那样去思考, 而不是站在一个产品的制作者角度在你的产品策划, 设计以及开发环节都要考虑到产品的用户

优秀的设计是不够的

“许多人认为用户体验就是一个产品是如何工作以及外观”. 换句话说, 人们很容易认为用户和产品的交互就是用户体验的全部内容了. 比如, 他们可能关注的焦点问题诸如: 产品的交互界面是否利于用户导航呢? 最重要的内容是否获得了视觉的最优位置呢? 产品外观是否足够优质呢?

如果对此类的回答是”是”, 就会让人很容易的认为你已经给你的产品赋予了极好用户体验. 在很多方面, 你可能已经做的比你的竞争对手好很多. 但是, 一个产品的用户体验所包含的内容远远不止是在一个网页浏览器或者移动设备中打开一个应用这么简单.

让我们以一个我们可能会提问的问题为例: 在用户第一次使用你的产品之前用户对产品的期望是什么? 可能他们听到很多其他用户的看法, 可能是好的, 也可能是不好的看法, 如果这样的话, 这些意见都会成为TA对你的产品最终形成的整体体验感受的重要组成部分, 它当然会影响到他们对产品的使用方式, 他们对产品以及你的公司的看法和感受, 以及很多我们接下来会说到的一些重要部分.

像素, 屏幕, 页面以及体验

“以用户为中心的设计所关心的不只是产品本身的用户界面, 还有用户在界面之外与产品的交互行为.” 这些包含但不限于以下几点:

你的产品市场和分发方式购买, 打开和首次使用产品的整个流程升级流程“登船体验”, 即逐步学习产品所具备的能力, 以及如何使用和如何处理错误信息的过程宣传, 用户的口碑是最好的广告客服或者售后服务质量, 以及你对产品能力的深入了解

上面这个清单仅仅只是非常表面的一些东西, 但是它可以初步让我们对影响用户体验的诸多因素有个大概的了解.

如果你曾经找你的手机或者线路公司进行技术咨询, 你就会理解这一经历会对你对他们的产品以及服务的感受观点有多大影响了. 虽然你可能最后还是解决了问题, 获得了更好的线路以及手机问题得以解决, 但是如果你在处理这一事宜的过程是非常让人不开心的一个经历, 那么你可能依然会对他们的服务产生负面的观感. 而一个用户对你公司的看法和以往的交往经历都可以算是用户体验的一部分.

像一个伟大的UX设计师那样思考

在本文后面的内容中, 我会提供一些你可以用来和你的产品团队分享, 一起帮助每个人像一个伟大的UX设计师那样思考问题. 为了创造一个人们喜欢的产品, 需要你整个团队, 不只是UX团队, 都聚焦到用户身上.” 而如果能够把焦点放到用户身上, 那么就能帮助你传递很多益处, 会带来很多我上面说过的好处.

走向优秀体验的态度

像一个伟大的UX设计师那样思考意味着你需要养成一些思维方式, 这些思维方式与其说是一些特定的思考流程或者做事规则, 不如说是一些基本的态度更为合适.

要有同理心

当你被无数决策缠身, 催促着你从想法走到原型直到上线, 你会很容易的陷入到一个困境, 就是视野会局限在产品团队之中.  你手头工作的复杂和困难以及你作为产品主导者对产品目的, 设计以及功能的熟悉都让你无法兼顾自检的环节了.  在这个环节中, 我们缺失的正式外界的观点-你的用户的角度的看法.

和你的用户交流所能带来的好处不仅是他们提供的那些你可以用来优化设计流程的信息, 随着时间, 和你的用户交流能够帮助你建立更好的同理心. 你将学会通过他们的眼睛看世界.

而有了同理心, 你将可以站在用户的角度去评估你的设计和商业决策. 而且你会更有可能创造一些他们 能够找到其价值, 用处以及给他们带来欢乐的产品.

要承认每个意见都是有价值的

以用户为中心的设计的下一个态度往往很难被人所采用. 请跟着我一起重复:”每个意见都有价值. 每个意见都有价值.” 哪怕是意见本身可能完全没有逻辑. 哪怕是这个意见完全违反了一个正确的设计原则. 哪怕是这个意见是完全非理性的, 而且对你而言完全没有意义的.

如果使用你的产品对用户而言是一个可选行为的话–实际上它确实是个可选的行为–那么他们的意见就是有意义的. 但是从那些非理性或者无逻辑的反馈中找到有价值的东西是有难度的. 然而, 这类用户反馈可能指向的更大的一些问题, 可能代表着用户的某种更深层次的情感模式, 而这对于用户和你的产品之间的交互有着很大的影响. 而如果带着”每个意见都有价值”的观点来处理用户的反馈, 那么就能够帮助你发现这些模式.

如果你收到一些对你完全没有意义的反馈, 那么你应该暂停一下, 好好思考以下它的具体含义. 可以问这么几个问题:

那些没有给我们反馈的用户中有多少可能也有同样的看法呢?为什么他们会需要这么一个具体的功能点呢?为什么他们不能理解我们设定的这种用户工作流呢?为什么他们会这么感觉呢?

退一步讲, 和你的用户聊天, 即便是一些似乎很疯狂的想法也往往能够给你带来一些新的观点, 说不定就能帮助你解决手头的问题呢.

意识到情景和经历都会对用户体验产生影响的

可能你的项目的目的是创造某个全新的东西, 但是你的产品最终会被那些有着自己过往使用科技产品经历以及特定的使用场景的人去使用的. 而这些经历以及所处的情景会在很深层次上影响人们和产品之间的交互.

比如, 我每次购物时如果发现那些老式的黑屏绿字, 带着键盘的销售终端依然还在投入使用时都会觉得这是一件非常令人着迷的事情. 实际上, 我经常能够在非常现代化, 成功的零售商们那里看到类似这样的用户界面.

这样的用户界面可能看起来很过时, 而且使用也不高效, 但是如果你考虑下它使用的场景, 就会有不同的看法了:

零售行业的工作人员在长期的工作中, 因为不断的使用同样的用户界面重复同样的销售操作, 会形成一种独特的肌肉记忆;他们的这种肌肉记忆会允许他们甚至不怎么注意屏幕就能够准确的完成操作, 也就让他们有更多的时间和客户进行视觉交流, 这样能够给客户更好的购物体验;这种肌肉记忆需要很长的时间才能形成. 可能需要一个缓慢的学习曲线去掌握, 但是一旦掌握了, 它带来的速度和效率的提升是雇员们所愿意放弃的, 即便是面临着一个有着快速学习曲线的新的交互界面的诱惑也一样.

如果你忽略这种历史原因以及特定的场景原因, 那么这种古老的POS终端看起来就是一个典型的糟糕的用户体验. 但是你一旦把这些都考虑进来, 你就会获得完全不同的理解了.

当你脱离用户界面, 而考虑更加宏观的一些事情时, 你就会知道哪些因素才能真正让你的产品体验有所不同.

要有情商

如果你自己质疑用户对你产品的感觉的重要性, 那么你可以回想下最近Facebook首次展示了他们做了明显改变的新用户界面, 而随之而来的用户疯狂的愤怒回应.

最强烈的情感–爱, 恨, 快乐和忠诚–都需要时间来建立的. 你的公司的新产品将会继承那些旧产品用户的情感, 而这些完全不受你控制–比如用户对你的app运行平台的看法以及在app store中的应用发现这一过程等都是不受你控制的.

但是他们对你产品的感觉会随着使用逐渐的形成并发展. 想象一下: 不断重复的讨人厌的登录环节, 一个流畅的,愉快的导航, 一个思虑周全的错误处理机制, 一个一直都不尽如人意的客户服务, 这些长期积累下来情绪, 会产生什么样的影响呢?

像一个UX设计师一样思考, 就要考虑到用户和你的产品之间的这种情感关系.

把这种优秀UX设计师的态度应用起来

有一个很简单的, 混合了这些特点的方式可以让你开始像一个优秀的UX设计师那样思考: 注意观察人们是如何和日常生活的事物进行交互的. 他们的这些行为会告诉你很多, 很多在你开始考虑开发一个产品之前需要考虑的事情, 会告诉你如何开发一个新产品, 一个能够让人们生活更加便捷, 更加快乐, 更加符合人们期望的产品. 

来源:

原文: User Experience Is a Feeling
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>设计心理学系列(1) - 网络心理学</title><link>http://taoalpha.me/blog/2015/05/08/read-design-psychology-1-cyber-psychology/</link><category>read</category><tag>Cyber Psychology,设计心理学</tag><pubDate>2015-05-08T12:00:00.000Z</pubDate><description>什么是网络心理学?网络心理学是随着互联网等新技术出现以及发展而逐渐发展起来的一门新兴科学. 它所研究的领域就是网络与心理学的结合, Cyberpsychology本身由两个词合并而成, 前者Cyber是取自Cybernetics, 代表着对于机械控制和与之通信的研究, 代表着对新兴网络领域的研究, 而心理学则是对人脑和行为学的研究. 两者的集合即表明了Cyberpsychology的研究领域主要集中在了人与新兴机器系统(包含虚拟系统)的心理学研究.
网络心理学简介演化历史Cyberpsychology最开始是集中关注于人在操作机器以及与机器交互的过程中的心理学变化, 后来随着电脑的出现以及普及, 互联网的诞生以及发展, 加上新兴智能机器的出现和发展, 都使得Cyberpsychology的研究重点放到了互联网上面. 而随着虚拟现实技术的出现, Cyberpsychology的研究范围再一次的增广, 可以说, Cyberpsychology的研究范围基本会随着cyberspace的领域增长而延伸.
通常认为John Suler, 来自Rider University的心理学教授, 是Cyberpsychology的奠基人. Suler教授是最早开始关注与网络对人们心理变化带来的影响, 其出版的The Psychology of Cyberspace一书也是被认为最早整合性的Cyberpsychology学术作品.
从1960年代, 计算机开始出现网络系统, 到1980年代世界性互联出现, 领域内专家, 极客作为初始用户. 又过了10年, 随着超链接的出现, 衍生了一个对普通人更友好的万维网. 全球互联网正式诞生.
随着人们对互联网的使用越来越频繁, 开始逐渐有心理学研究人员关注到这一领域, 慢慢促成了Cyberpsychology的诞生. 而随着互联网对人们生活的侵入越发全面, 这一领域也越来越收到人们的重视, 而随着互联网的发展, 新技术的出现, 这一领域也在不断的自我演进. 
很多人都预言未来毫无疑问将会是网络的时代, 而随着智能设备, 智能家居以及虚拟现实的出现, 都让这一预言变的更加可信. 所以研究人与网络的交互过程对人类本身的影响反馈是非常重要而值得的.
参考视频: The Birth of CyberPsychology - 需翻墙
包含方向目前人们对于Cyberpsychology的研究方向都还集中在那些因网络出现而造成的明显影响之中, 尤其是那些负面影响, 目前大体的一些主流热门话题都围绕在以下几个方面:

网络成瘾问题;
网络身份与自我认知问题;
网络关系问题;
网络与现实的表现差别问题;
网络人格/性格问题;
虚拟现实领域;

…
网络心理学的研究知名人士
Dr. John Suler - The founder of the Cyber Psychology
J. &amp;amp; Parker - The author of the Cyberpsychology
Bernard Luskin - Launched the first MA/Ph.D program in Media Psychology

重要期刊
Journal of Computer Mediated Communication
Cyberpsychology: Journal of Psychosocial Research on Cyberspace
Cyberpsychology, Behavior, and Social Networking
Journal of CyberTherapy &amp;amp; Rehabilitation

阅读书目
The Psychology of Cyberspace by John Suler
Cyberpsychology by Alison Attrill
Cyberpsychology: An introduction to Human-Computer Interaction
Cyberspace Romance: The Psychology of Online Relationships
The Psychology of Menu Selection: Designing Cognitive Control at the Human/Computer Interface (Human/Computer Interaction)

参考文献
Wikipedia of Cyberpsychology
The psychology of cyberspace
Cyber Psychology &amp;amp; Cyber Sociology
Cyberpsychology and Vitrual Reality
The first decade of CyberPsychology

2015-05-09 By 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>52WeeksOfUX-第一周(译)</title><link>http://taoalpha.me/blog/2013/06/11/read-first-week-of-52weeksofux-translated/</link><category>read</category><tag>Design,UX,产品学习,翻译文章</tag><pubDate>2013-06-11T12:00:00.000Z</pubDate><description>The First Rule of UX(UX第一定律)“你不得不交流.所有的行为本质都是一种交流.因为行为本身没有一个完全相反的概念(没有反=行为的概念),所以不可能不去交流.(这个因为所以没有看懂啊)”–Paul Watzlawick关于沟通的第一公理.
这是UX的第一条规则.设计师所做的任何事都会对用户体验造成影响.从一个有一天添加的设计元素到一个关键信息的疏忽遗漏,每一个决定都在塑造着我们设计服务的用户的未来模型.
因此,任何一个好的设计师的首要目标都是传达预期的信息…这可以促进用户体验的提升.文案,文本颜色,表格的对齐,导航链文字标题的大小写–即便是没有设计模式,也都是沟通的一部分.
了解了这些,我们可以问这样的一个问题(最好也能回答):”这个元素和我想要向用户传达的信息是相辅呢?还是相悖呢?”而且,通过询问这些,你可以重新定义改善一些细节;一些经常不被注意的细节,而这些通常组成了最终的用户体验.
What makes the user experience?用户体验是由一个用户和你的品牌,公司,组织的全部交互所组成的.这将可能包含于你的软件的交互,与你网站的交互,与你电话服务中心的交互,与广告的交互,以及在他人电脑上指指点点的交互,与一个移动应用的交互,与你Twitter账户的交互,与你通过邮件的交互,可能甚至是面对面的交互.这些交互的总和构成了用户体验.
交互设计师就是在这个时候发挥作用的.他们的一部分指责就是让所有的交互都灵活,包含所有软件,文案,图形,布局,用户流动,物理体验的各个方面.对于一个体验而言,如果一部分极好而另一部分极差,那才是羞耻.内聚力是非常重要的.
用户体验贯穿了很多的实际工作.以建筑为例,如果一个建筑师被雇佣来为一个财力雄厚的客户创造一种很棒的用户体验,他们将不会止步于设计人们的居住环境.他们会花时间花精力去关注周边的绿化,车道的弧线,每个角度的视觉感受..可能甚至是客户可能打招呼的方式以及桌椅摆放的方式.所有的这些触点对于一个大型的系统都是重要的组成部分..而房屋仅仅只是这块大拼图的一片而已.
网页设计师,传统观点中的网页创建者,现在有了更广的领域.因为用户体验设计时的环境比以前变的更广了.所以,我们必须调整我们的设计方法,包含用户体验的方方面面.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Knowledge vs Intelligence</title><link>http://taoalpha.me/blog/2014/11/21/read-knowledge-vs-intelligence/</link><category>read</category><tag>翻译文章,译系列</tag><pubDate>2014-11-21T10:00:00.000Z</pubDate><description>大约一周前, 我在开发我一个小产品的时候遇到了一个很严重的问题. 我花了好几个晚上的时间去解决这个问题, 但是依然没有什么进展, 这让我很沮丧.

之后的一个晚上, 我正在和 Olivier Lacan视讯, 我们讨论了这个问题. 因为他是我的一个非常好的朋友, 所以他建议我把我的桌面分享给他来让他看看. 我正在研究 Laravel一个全新的PHP的框架, 也是Olivier从来没用过的一个框架(当然其实他连PHP都不用的). 但是他很聪明而且是一个很伟大的开发者, 所以我很愉快的接受了他的要求.

我们开始梳理整个代码库, 我带着他过了一遍整个应用和框架,  他则见或提出一些内部系统的尖锐问题. 因为Olivier并不是非常熟悉Laravel, 所以他问的问题就和我不同, 而这些问题则指向了一个有趣的部分, 而这个部分正是我一个人想的时候没有注意到的. 而在一个小时的debug后, 我们找到问题的根源并且解决了它.

我之前曾谈论过有关 “编码交换”的话题, 就是把自己的电脑与他人交换, 然后尝试解决对方的问题–但是这次则是另一个问题. 这是一个类似 传统的 “橡皮鸭”的问题, 不同的是有一个可信任的聪明的朋友.

这里的关键在于知识和智慧之间的区别. 知识是关于技能, 以及经历和从中获取的信息的集合. 智慧则是应用知识的能力.  一个人缺乏某个领域的知识不代表他们不能应用自己的智慧来帮助解决对应的问题.

知识是很好的, 但是它总会随着技术和科技的 兴起没落而渐渐消失掉. 但是智慧则不会. 它跨越了技术和科技之间的壁垒, 这就是最大的区别了.

Source:

Knowledge vs Intelligence
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>How Users Read on the Web(译)</title><link>http://taoalpha.me/blog/2013/06/04/read-how-users-read-on-the-web-translation/</link><category>read</category><tag>HCIBib,产品学习,网页浏览,翻译文章</tag><pubDate>2013-06-04T10:00:00.000Z</pubDate><description>本文主要是针对网页上的文字排版对于用户阅读的影响,列举了三种不同的处理方式以及混合情况下对网页可用性的提升效果.他们从不阅读。
人们极少逐字逐句地阅读网页上的内容，他们只是扫视页面，选取某些字词语句来阅读。 在关于人们如何阅读网站的研究中，我们发现大概79%的测试用户对于任何他们进入的页面都是采用扫视的方式阅读，只有16%的用户 是逐字阅读的。(更新：一个新的研究发现用户在阅读email时比阅读网站更加散漫。)
所以，网页需要提供可以扫视的文本信息，利用：
    高亮关键字(超文本链接是高亮的一种形式，字体和颜色变化也是高亮的形式)    有意义的子标题(不算作很明智的选择)    符号列表    一个段落一个主题(如果用户没有段落中前几个词所吸引的话,那么他们会跳过剩下的所有)    倒金字塔风格,先说结论    相比传统的写作而言,字数至少要减少一半我们发现可信性对于网页用户而言是非常重要的,因为对于网页信息背后的作者以及网页是否可以信任是不清楚的.可信性可以通过高质量的图片/优秀的写作以及向外的超文本连接来提高.外链表现出作者已经做完了该做的,并不担心用户访问别的站点.
用户厌恶”商业感”,通过主观的自我夸赞和宣言(有史以来最经典的)来提升写作风格在当下的网页中已经不再使用了.网页用户非常忙碌的,他们想要得到最直接的结果.还有,如果用户清晰的看到网站在夸大,可信性会一落千丈的.
衡量提高网页写作风格带来的影响
为衡量一些我们已经确认的内容指南所带来的影响,我们制作了想通网站的五个不同的版本(形同的基础信息;不同的措辞;相同的站点导航).接着我们让用户在不同的网站下完成相同的任务.正如下表中所示,易用性在简介版本以及浏览性版本的网站中得到了很明显的提升(58%以及47%的提高).而且当我们将三种 方式整合到一起来提升写作风格,形成一个单一的站点,结果会更加炫目:124%的易用性提升.




网页版本

示例段落

可用性提升

促销对照组 使用的就是常规商业网站使用的风格
Nebraska is filled with internationally recognized attractions that draw large crowds of people every year, without fail. In 1996, some of the most popular places were Fort Robinson State Park (355,000 visitors), Scotts Bluff National Monument (132,166), Arbor Lodge State Historical Park &amp;amp; Museum (100,000), Carhenge (86,598), Stuhr Museum of the Prairie Pioneer (60,002), and Buffalo Bill Ranch State Historical Park (28,446).
0% (by definition)

简洁版本只有对照组的一半字数
In 1996, six of the best-attended attractions in Nebraska were Fort Robinson State Park, Scotts Bluff National Monument, Arbor Lodge State Historical Park &amp;amp; Museum, Carhenge, Stuhr Museum of the Prairie Pioneer, and Buffalo Bill Ranch State Historical Park.
58%

扫描式布局 和对照组文本一致,但采用易于扫视的格式
Nebraska is filled with internationally recognized attractions that draw large crowds of people every year, without fail. In 1996, some of the most popular places were:

Fort Robinson State Park (355,000 visitors)
Scotts Bluff National Monument (132,166)
Arbor Lodge State Historical Park &amp;amp; Museum (100,000)
Carhenge (86,598)
Stuhr Museum of the Prairie Pioneer (60,002)
Buffalo Bill Ranch State Historical Park (28,446).47%客观的语言 利用中立而不是主观自负或者言过其实的语言(其他都和对照组一致)Nebraska has several attractions. In 1996, some of the most-visited places were Fort Robinson State Park (355,000 visitors), Scotts Bluff National Monument (132,166), Arbor Lodge State Historical Park &amp;amp; Museum (100,000), Carhenge (86,598), Stuhr Museum of the Prairie Pioneer (60,002), and Buffalo Bill Ranch State Historical Park (28,446).27%整合版本以上三种写错风格修改的集合.In 1996, six of the most-visited places in Nebraska were:
Fort Robinson State Park
Scotts Bluff National Monument
Arbor Lodge State Historical Park &amp;amp; Museum
Carhenge
Stuhr Museum of the Prairie Pioneer
Buffalo Bill Ranch State Historical Park124%在客观语言版本中可用性获得了27%的提升着实让我们吃惊了.我们期待用户可以喜欢这个版本胜过对照组(实际上也确实是这样的),但是我们认为评价标准对于任意一种语言而言都是一样的.正如预计的那样,我们的四种评价标准(时间错误内存网站结构)都获得了客观风格比原始的促销版本更好一些的结论.我们用以解释这一发现的猜想是促销性语言为用户强加了认知的负担,必须让用户花费精力去过滤夸张的表象从而获得事实. 当人你们在阅读一个以”Nebraska是一个充满了国际公认景点的地方”开头的地方,他们的第一反应是”不,不是的”,并且这一想法将会降低他们使用网站的速度,分散他们的注意力.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>网页设计简史</title><link>http://taoalpha.me/blog/2014/12/05/read-read-a-brief-history-of-web-design/</link><category>read</category><tag>Design,翻译文章,设计,读系列</tag><pubDate>2014-12-05T09:00:00.000Z</pubDate><description>本文针对网页设计的历史做了简单的介绍, 配上了很多动态图片作为示意, 可以说很简练但是也很完整, 值得一读.

作者最开始应该是对设计和代码实现都比较有兴趣的, 但随着代码越来越复杂, 实现一个设计的方法越来越多, 但是即便这么多的方法, 都不能保证适用于所有浏览器. 于是作者慢慢对代码层失去了兴趣, 专心开始搞设计了~ 所以本文开篇, 作者提出了一个很好的问题:

  设计和代码部分是如何分开的呢? 而且越分越远?

所以相对于设计师该不该学代码的问题, 本文研究的则是设计和代码是如何在网页设计这条路上分道扬镳的呢?

1989–网页设计最黑暗的时期



可以说最开始的网页设计是非常不明朗的, 那个时候屏幕都是黑色背景的命令行状态, 再加上非常有限的屏幕尺寸.  可以说, 那个时候所谓设计能依赖的东西只有那些符号和制表符了… 真可以说那个时候就不存在什么网页设计…

1995 - 网页设计的开端-表格设计



随着可以展示图片的浏览器的诞生, 宣告了网页设计的正式开始. 而在当时, 已经存在于html中的table元素就成为了设计师用来发挥自己设计天赋的绝佳工具. 当时有本著名的书 Creating Killer Sites就是介绍如何用Table布局的. 但是Table的设定本身并不是为了进行页面的设计布局, 而是为了展示结构化的数据, 所以存在了很多的问题, 比如维护这种碎片化的结构是个相当费事的事情… 但是, 因为各种原因, 这种设计方式依然存在流行了很长的一段时间~ 而在这一时期, 切图设计也逐渐变热. 设计师们设计出各种酷炫的布局, 而开发者则将他们拆分成一个个小块然后再拼接在一起. 另一方面, 表格又确实有着一些非常棒的属性: 比如垂直居中. 这些优势和我们后面会说到的grid布局设计极为相像.  但也正因为这种布局结构的麻烦和痛苦, 所以很多开发者们都很不喜欢进行前端编程…

1995-JS的出现



JS可谓是对HTML的很好补充. 比如说, 如果我们需要一个弹出窗口, 想要动态的对某些东西进行排序? 那么JS就是最好的选择了.  问题在于JS是基于网页基础结构之上的, 所以它不能和web资源一起载入, 而需要分开进行载入.  所以有种像是html的补丁一样~

如今我们多数情况下能用CSS实现的基本不用JS实现, 但是当时JS可谓是网页设计的一大救星啊. 即便如今, jQuery此类的JS库依然是前端编程和后端编程(node.js)的热门组件.

1996-设计的黄金时期



为了打破当时网页设计的限制, 出现了一个前所未有的工具, 而使用它, 设计师们的工作变的无比的自由! 任意的形状, 布局, 动画, 交互, 字体, 随便搞. 这个工具就是–Flash. 把需要的资源打包到一起, 然后交给浏览器去展示就行了. 这就意味着只要用户拥有最新的flash插件, 那么只需要等待一段载入时间, 那么它就能呈现出非常绚烂的结果. 这可以说是网页设计的黄金时期, 出现了无数的飞溅式设计, 介绍动画, 以及各式各样的交互效果. 但不幸的是, 它的不够开放或者说对搜索引擎非常不友好以及处理本身耗费的资源过多等特性, 都导致其终将被舍弃. 而随着Apple决定在他们的iPhone上直接抛弃了Flash的支持, Flash就开始走向了衰亡(至少对网页设计来说是的).

1998-CSS



CSS大概和Flash同时期出现的, 作为一个解决设计布局的更好的方法而出现在设计师面前.  基本的想法就是把网页内容层和展示样式层分离开. 所以外观展现和样式类型都由CSS来决定, 而内容则由HTML决定. 第一版的CSS当然远没有如今的这么灵活, 丰富, 但是这还不是当时最大的问题. 当时最重要的问题是各大浏览器的支持率. CSS花费了几年的时间才让很多浏览器开始支持它, 而且最初还有着很多各式各样的问题存在.  而在当时, 一个浏览器更新支持一个新功能, 而其他浏览器还没有支持这种让开发者痛苦至死的事情(即便到如今依然有这个问题…尤其是在国内: IE6,7..永恒的恨啊..)已经开始出现. 

值得说明的是: CSS并不是一种编程语言, 它更像一种声明性语言. 我们可以讨论设计师是不是需要编程, 但是设计师需不需要了解CSS的工作原理则是完全不需要讨论的事情.

2007-移动端的升起-网格布局和框架的时代



在移动端浏览网页对当时的设计师而言是个非常大的挑战. 不说布局, 单就是它引发的内容问题(content-parity)就是个挺麻烦的事情: 在小屏幕下展示时和大屏一样呢? 还是要精简一些呢? 在小屏幕上如何投放那些晃眼的广告呢? 速度也是个问题, 毕竟加载资源过多的话网费就够你喝一壶的了. 首先提出的解决方案是网格布局法. 而经过几次迭代厚, 960 grid system成功的普及开来, 而这种12列的布局方式页逐渐成为设计师们日常使用的布局结构了.  而下一步解决的问题就是常用的各个组件, 比如表格, 导航, 按钮这些元素的复用. 基本的想法是, 制作一个元素的库来存储这些代码. 而最后的胜出者就是如今大名鼎鼎的Bootstrap和Foundation了~  而随着网页和app的界限逐渐消失, 这些框架变的更加流行. 但是所有的设计看起来都是蛮像的, 而设计师如果完全不理解代码工作的原理那么也是无法发现他们的区别的.

2010-响应式设计



Ethan Marcotte决心改变当时的设计方式, 想要用同一套内容但是不同的布局来自动的适应不同的屏幕尺寸(厉害啊!), 于是, 响应式布局就出现了. 从技术上, 还是使用HTML和CSS, 所以倒也不是一个新的技术. 但是如今对响应式依然存在了很多的误解. 对于一个设计师而言, 响应式往往意味着要进行多布局的设计. 对于客户而言, 就是单纯的: 这个网站在手机上也能看的比较舒服. 对开发者而言, 则设计了很多方面, 包括图像的展示, 下载速度, 是否移动居先等等问题. 而这里最大的好处就是内容, 它能够保证网站内容的完整性和一致性. 

其实响应式的问题目前也主要集中在加载层面, 毕竟响应式会导致在手机上也会加载几乎全套的资源, 这必然会导致加载速度受到影响. 而包含了各个尺寸样式的css文件也会导致加载速度的变慢~ 不过! 随着技术手段的提升和网络速度的提高, 这些问题想来也不会是什么大的问题吧.

2010-扁平化时代



为不同布局状态设计是很费力的一件事, 而简化设计流程, 去掉那些烦人的阴影效果以及仿真化的细节, 自然能够让设计变的容易很多. 这就是扁平化设计, 其极大的简化了元素的细节, 重回设计的根本–为内容服务.  而那些酷炫的按钮则被图标取代, 使我们能够使用位图以及icon字体. 有趣的是, 这在一定程度上和网页的起始阶段很像, 不是吗? 果然是回归根本啊…哈哈

2014-光明的未来



网页设计说白了就是设计师制作的视觉效果在浏览器中呈现罢了. 想象以下, 未来设计们可能只需要拖动下元素, 就能够获得一个简洁的代码文件, 而不在需要手写代码, 这多给力啊. 哪怕不能做到那些酷炫的效果, 仅仅单纯的静态页面和简单的交互也是相当不错的事情呢. 再想象以下未来开发者们再也不用担忧浏览器兼容的问题, 而只需要集中精力解决那些真正的问题, 那TM该是多美好的未来啊…

如今技术上已经出现了一些光明未来的曙光: 比如CSS中新引入的一些属性, vh, vw就容许布局上有更好的灵活性. Flexbox则帮助更好的布局, 不再需要那么多的代码, 只用一行就能制作很棒的布局了. 而那些现成的做好的各个组件, 比如注册登录等等, 都让网页设计变的更加容易更加流畅. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Introduction To Usability(译)</title><link>http://taoalpha.me/blog/2013/06/13/read-introduction-to-usability-translated/</link><category>read</category><tag>UX,Usability,产品学习,翻译文章</tag><pubDate>2013-06-13T09:00:00.000Z</pubDate><description>Introduction To UsabilitySummary 如何定义可用性?如何,什么时间,什么地方来提升?为什么你要关注可用性?这是一个关于核心的可用性概念的介绍以及回答一些基本的问题.
What–Definition Of Usability
可用性是一个表征质量的属性,用以描述用户界面在使用性上的难易程度.”Usability”这个词本身也有用以提升设计过程中易用性的方法的含义.
可用性主要通过以下5个部分的特点组成:
    易学性:对于用户而言,第一次使用时完成基础任务的难易程度?    高效性:一旦用户学会了之后,他们完成任务的效率有多高?    记忆性:当用户在一段时间的不用后再次返回时,他们重新熟练的容易性如何?    错误率:用户会犯多少错误,这些错误的严重程度如何,以及他们从这些错误中脱身的难易程度?    满意度:用户使用这一设计的满意度如何?此外还有很多重要的品质属性.其中比较关键的一个就是实用性,表征的是设计的功能性:它所做的都是用户所需的吗?
可用性和实用性都是同等重要的,而且它们一起决定了设计是否有用:如果某物很容易但却不是你想要的也是没啥意义的. 虽然对于幻想那种可以做任何你想做的事情的系统也不见得是好的,但是如果你的交互界面很难用的话,你是不可能做到这一点的.为了研究一个设计的实用性,你可以用提升易用性同样的研究方法.
    Definition: Utility—它是否提供了你所需要的功能;    Definition: Usability–这些功能用起来的难度和满意度如何.    Definition: Useful = Usability + UtilityWhy Usability is Important(为什么可用性这么重要)
在网络上,可用性是一个必须要考虑的生存条件.如果一个网站非常难用,人们就会离开.如果一个公司的主页不能描述清楚公司提供的产品或者服务,用户可以做什么等,人们也会离开.如果用户在一个网站迷路了,他们就会离开.如果一个网站的信息很难阅读或者无法回答用户的关键问题,他们也会离开. 注意到一个模式了吗?根本不存在这样的情况:用户费劲的阅读说明书或者花费很多时间去理解一个界面.外面还有无数的网站等待用户去选择,离开是用户在感到难用时的第一选择.
电子商务的第一条定律就是如果用户无法找到产品,他们就无法购买这个产品.
对于企业内部网络,可用性就是一个关乎员工生产力的事情了.用户如果花费太多的时间在内部网络或者纠结于思考那些困难的指令,那么也就等同于在浪费着你付给他们工作的薪水了.
目前最佳的财政预算是将设计项目预算的10%留给可用性上.平均来讲,这些大概是一个网站期望的质量标准的2倍左右,而且大概是一个内部网络质量标准花费的两倍略低一些.对于软件或者实际的物理商品,强调设计过程的易用性,所致的提升效果会相对较小,但是依然很显著.
对于内部的设计项目,应该考虑将培训预算砍掉一半,而将易用性方面的预算加倍,以及加倍做事的员工的时薪.对于外部的设计,则应该考虑加倍销售的预算以及注册用户和用户引导的预算,同时加倍那些对你的设计项目有提升动机的预期计划.
How to Improve Usability(如何提升易用性)
在研究易用性上有很多方法,但是最主要最基础最有用的就是用户测试了,它包含了以下三个部分:
    找到一些典型的用户,比如电子商务网站的消费者或者内部网络的员工(在后者的情况下,他们应该是在你们部门之外工作的);    让用户实施一些有代表性的任务;    观察用户做了什么,那些地方成功了,哪些地方他们遇到了问题,而且闭上你的嘴,而让用户讲出他们想说的;逐一分别的测试用户,让他们独立解决任何问题是很重要的,.如果你帮助他们或者把他们的注意力指引向屏幕的任何部分,你都让实验结果受到了污染;
为确定一个设计最重要的易用性问题,测试5个用户就基本足够.预期去运行一个大型的,昂贵的项目研究,还不如使用这些资源进行一个小规模的测试,并且逐一重新审视你的设计,这样你才能在确定问题后修正你的易用性瑕疵.迭代设计是一个而方法来提升你的体验质量.你和用户测试的版本和界面设计越多,效果越好.
用户测试和焦点小组是不同的,焦点小组是一种相对较差的方式来评估设计的易用性.焦点小组常用于市场调研,但是为了评价交互设计,你必须足够近的观察一个用户利用你的设计界面去完成一个任务.通过聆听用户所说的会有误导:你必须去亲自观察他们真正做的是什么.
When to Work on Usability(什么时候注意易用性)
易用性在设计过程的每一步中都占据一定的地位.对于多个研究的需要也是我推荐把个人独立的研究尽快而又便宜的完成的原因之一:
    在开始一个新的设计之前,测试旧有的设计来确定其中好的部分,这样你就可以保留这些部分并加以强化,同时知道哪些对用户造成困扰的部分.    除非你在一个内部网络中工作,测试你竞争者的设计可以廉价的获取到一组相对较好的设计界面,而且这些都和你的设计有着很多共同的特性.(如果你工作于一个内部网络,那么可以通过阅读内部的设计年刊来学习其他的设计).    针对用户在他们的日常生活中是如何表现的做一个实地的考察;    对一个或者更多的新设计注意制作纸质原型并加以测试.你投资在这些设计的时间越少,效果越好,因为你需要根据测试结果来修改他们(就是不用花费太多的时间去做特别精致的原型)    通过多次迭代后,对最优秀的那个设计不断修改来完善它,逐渐的从低质量的原型到高质量的电子原型展示.每一次迭代都需要测试.    观察那些和建立可用性规则先关的设计,无论是你早期的研究还是公开的研究.    一旦你决定了并且开始着手最终的设计,再次测试一次.一些微小的可用性问题经常在实施的时候出现.不要抵制用户测试,除非你已经有了一个完成的设计了.如果你已经有了一个成品,那么再去修复绝大多数测试没有覆盖到的关键问题就会变得不可能了.像这一类的问题大多是比较偏向结构方面的,而修复他们将会需要对主要部分的重构.
想要获得一个高质量的用户体验唯一的方法就是在设计的早期就开始用户测试,并一直持续的在接下来的每一步实施它.
Where to Test(在哪里测试)
如果你每周至少实施一次用户测试,那么专门建立一个可用性实验室就有必要的了.但对绝大多数公司,在一个会议室或者办公室里进行一次测试就已经不错了,只要你关上门隔开干扰就可以了.重点在于你要有真实的用户,并且可以在他们测试的过程中陪坐一旁.你唯一需要的设备就是一个笔记本.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Google又做了一件大好事:干掉了烦人的识别型验证码!</title><link>http://taoalpha.me/blog/2014/12/04/read-read-google-did-a-good-thing-kill-annoying-type-identification-code/</link><category>read</category><tag>Captcha,reCaptcha,翻译文章,读系列</tag><pubDate>2014-12-04T14:00:00.000Z</pubDate><description>译系列正式转为读系列, 以后都为阅读后自己整理总结成文~ 吸收知识哈哈
伟大的Google又做了一件大好事啊!! 它干掉了烦人的识别型验证码!!! 本文简单介绍了一下这一新的验证码.

对于验证码, 大家都不会陌生, 无论你是否经常上网, 是否买过东西, 是否看过网络视频, 你一定遇到过验证码!!! 而如今最为常见的几种验证码形式分别是:

Captcha(Completely Automated Public Turing test to tell Computers and Humans Apart): 图片识别, 通过识别一些或模糊或清晰的图片中的文字信息来达到验证”我不是机器人”的效果;reCAPTCHA: 同样来自Google, 用Captcha的方式做有意义的事情. 其和Captcha的表现形式基本是一致的, 只不过里面的图片不再是预设好的人工生成的那种故意扭曲或者加干扰后的图片, 而是Google的图书扫描项目中那些OCR无法识别的单词(多数是手写体或者不够清晰), 这样你每次输入验证码, 还能帮助Google的Books做的更好哦~(至于如果它自己都不识别, 那么怎么判断输入是否正确, 则是因为通常reCaptcha会提供两个词组, 一个是已知的, 一个是未知的, 所以呢, 在已知的正确的情况下, 未知的正确性就有了一定的保证, 而结合大量的输入, 那么最中获得的结果的正确概率就越高:所以, 面对一些很少有人输入过的验证码, 其实你很有可能输错了部分, 但也通过了~哈); 而继图书项目后, Google又在reCaptcha项目中加入了Google街景的路牌, 街道名识别~ 所以有时候你会遇到那种拍的很模糊的数字图~Puzzle CAPTCHA: 在识别类验证码之后, 又出现了这种拼图类的验证码, 操作方式有很多, 有的是图片切分打乱, 需要你重新排列成完整的图片, 有的则是有一块图片从整个图片中脱离出来, 需要你移动回去这种~ 这种有时候也叫做Draggable Captcha~Quiz Captcha: 这种则属于问答类的验证码了, 有的时候是一些显而易见的数学计算题或者找规律题, 有的时候则是一些基本常识, 还有些时候甚至是当前往网站名称这类有着明显答案提示的问题~

当然, 除了上述的这些, 还有着很多的验证码类型, 但是无论怎样, 为了实现区分人和机器的目的, 都是需要一定操作成本的, 这也是为什么大家很讨厌验证码的原因~

但是! Google这次新的reCaptcha:No CAPTCHA reCAPTCHA, 就改变了这一点, 它完全干掉了现有的这种繁琐的验证码, 取而代之的是一个简单的checkbox!!! 你只要勾选了这个”我不是机器人”边上的checkbox, 就算是通过了验证~ 似乎感觉这不是进步而是退步? 这样怎么能够实现Captcha的区分人和机器人的目的呢?

其实这个简单的checkbox里面有着非常复杂的机制, 它会通过你验证码勾选前后的整个表现来判断是否是一个机器人, 一旦有所怀疑, 甚至可以选择变回旧有的那种图形或者其他传统类型的验证码来再次确认. 这些都是基于 人工智能方面很深入的研究和成果.

目前这种新的Captcha的API已经开放给很多大客户了, 最近在开始接受网站主们的申请了~ 而那些大客户的反馈来看, 其效果是非常不错的: 核心的anti-spam质量虽然文章中没说, 但应该不错, 文章中重点提到了这个新Captcha的一个优点就是可以让用户更快的登录访问网站.

有兴趣的可以前往Google reCaptcha了解更多详情~
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>What Is the Relationship Between HCI Research and UX Practice?</title><link>http://taoalpha.me/blog/2014/09/05/read-t-what-is-the-relationship-between-hci-research-and-ux-practice/</link><category>read</category><tag>HCI Research,HCI翻译,关于HCI,翻译文章,译系列</tag><pubDate>2014-09-05T08:00:00.000Z</pubDate><description>测试feedpusher的数据库搜索功能时找到了这篇文章~ 对于HCI Research有很好的介绍!


人机交互是一个快速发展的学术研究领域. 目前来说, 学术机构基本主导了绝大多数的HCI研究, 无论在US,UK,Europe,Australasia以及Japan, 还有逐渐发展起来的南亚以及中国. HCI研究经常是附属在计算机系之下的, 但是又保留着其很强的心理学背景和人因学背景. 此外, 还有几个大型的杰出公司同时在独立的, 当让也有和各学术研究机构合作进行的, HCI相关的研究. 比如微软, PARC以及goole.
What Do Academic HCI Researchers Do?(那么学术性的HCI研究者都在做什么呢?)
通常来说, 学术性研究者都在做以下这三类事情:
    他们通过探索性的实验以及利用复杂的交互系统来创造新的计算机用户界面;    他们建立并发展了一套经验体系, 针对用户对于用户界面的使用和体验; 主要通过实验室中的用户界面研究或者在实际环境中观察用户对用户界面的使用情况(就如同人种学研究一样)来获得的;    他们发展出了一个理论系统来讲述设计以及使用交互系统. 其中包含了一些基本理论, 比如Fitts’s law(菲茨定律),描述指针移动和目标元素在屏幕的位置的的关系, 通常, HCI理论采用设计框架的形式, 包含了各种混杂的概念. HCI研究可能是聚焦到某个整体的局部也可能是直接识图去强化整体.


Is There a Connection Between Academic Research and Industry Practice?(在学术研究和工业实践之间有联系吗?)
在工业界的UX从业人士也通常都会做些研究的, 就如同设计一样. 但是学术性HCI研究和UX研究在目的产出, 目标, 以及关注的范围都有着非常显著的差别, 学术研究和工业研究通常可能都在处理那些看起来比较接近的基础对象: 数字化交互系统的设计和理解以及它们的用户群体. 两者都遵循用户为中心的设计原则, 都提倡把对人类的理解融入到设计环节中. 所以说, 它们之间肯定也应该有很强的关系以及重叠区域.
在UK, 政府在HCI的学术研究基金投入上逐渐关注起学术研究和工业时间的联系了. UK的工程和物理科学研究委员会, 也是HCI研究领域基金的重要来源, 就讨论过关于HCI研究需要考虑如何”把理论和方法应用到工业实践中”. 更进一步地说, 既然HCI学术研究在很多的领域, 包含医疗健康, 电子设备消费品以及软件等等都有很强的关系, 那么在HCI学术研究和UX实践之间建立一个更好的联系就能够获得很高的回报.
虽然学术圈经常会对UX领域做出很多不准确的猜测,而且有时候认为两者的关系是理所当然的. 学术研究者们通常会假设因为知识的利用和转移, 所以学术研究和工业实践有着非常自然的联系. 但另一方面, UX领域则经常认为HCI的学术研究通常都是脱离实际的, 在现实社会中是无法应用的. 也因为这样的原因, 他们通常会整个抛弃学术研究, 或者至少是觉得消化以及应用学术研究的结论是非常困难的一件事.
Moving Toward Establishing a Mutually Beneficial Connection Between Academia and Industry(为学术研究和工业实践发展建立一个双赢互惠的关系)
有两个开放性问题我们需要强调的是:
    UX职业领域该如何指导以及启发学术研究?    学术研究又能够为UX职业领域做什么事情呢?

回答第一个问题可能需要HCI研究者们对理解UX职业领域的工作有着一定的热情, 并且进行一些关于UX实践的经验性研究. 迄今为止, 学术研究中对于UX实践应用的探索还是比较有限的. 无论如何, 在UX领域工作的经验能够对学术研究产生很多意外的重要启示. 而回答第二个问题就要相对更加复杂了 – 甚至可以说完全不知道该如何下手了. 它需要很深入的研究才行.
令人好奇的是, 学术研究者们通常对HCI研究中大量出现的创新以及其自身关注领域的快速发展而感到忧虑. 在一个学术领域中, 他们的目标通常是建立一个强有力的基础, 然后慢慢发展.
然而, HCI学术研究领域的创新和广度都强化了其和在工业限制下的UX领域有限的能力形成的鲜明对比. 比如说, 在一个很限制的项目中工作时, 你需要考虑有限定的预算, 有限的时间, 你需要去满足客户的需求以及相关利益人的利益, 还要能和其他领域的人相互配合, 比如软件开发者; 还要习惯于新的工作方式, 比如敏捷开发以及精益方法. 你不会担心有过多的创新, UX从业人士通常希望能够在他们非常受限的环境下创造更多的创新.
学术性研究的产出中完全可以提供很多对UX领域有潜在价值的东西. 但是如何来传递这些产出呢? 首先也是最重要的是, 我们完全不用把HCI研究和某一个项目或者新项目, 或某项服务的预期条件, 或者某个客户的特定需求绑定在一起; 其次, 学术新的HCI研究有其探究未来科技的自由 – 即便其设计本身有着一定的风险且没有清晰的,即时的回报. 所以, HCI研究者们通常在无数失败的基础上创造了快速的创新, 他们的工作少了很多的限制.
也许通过有效的沟通, HCI学术研究中的那些成果能够给工业实践带来巨大的价值. 很多UX从业人士都没有那么富裕的时间来让他们去探讨那些当前需求以外的东西. 但是在学术研究中, 关注范围更广是很通常的事情.
不幸的是, 就目前来说, 绝大多数的学术工作–无论是创造圆形, 概念, 想法, 或者是设计原则 – 都局限在了HCI研究者们在各种会议期刊上发表的论文中了. HCI研究者的受众多数都是那些其他的学术研究者, 而不是那些在工业界工作的人们.
通过理解用户体验的工作情景, HCI研究者们能够更好的把他们的研究方向切合这些受众, 从而和UX职业领域建立更加友好自然的联系. 与其让学术研究和工业实践互相竞争, 不如假设一方创造那些权威的, 严禁的知识体系, 一方吸收并加以应用呢. 两者这样的互利互惠关系才是最有价值的. 采用这一方法可能会让学术研究者们更好的理解他们该如何进行自己的研究, 让它们更加容易帮助到那些UX从业人士.
Postscript(后记)
作为我开始针对这一领域的调研的一部分, 我创建了一个非常简短的, 5分钟调查问卷, 邀请各位UX从业人士来提供一些关于自身背景, 所用方法以及和学术研究的关系的信息. 如果你愿意参与其中, 或者是对这一工作有兴趣的话, 请参与此项调查.
Acknowledgments(感谢)
作者非常感谢EPSRC的支持.
References(参考)
[1] Benford, Steve, and Gabriella Giannachi. Performing Mixed Reality. Cambridge, MA: MIT Press, 2011.[2] Engineering and Physical Sciences Research Council. Report of the Human EPSRC Computer Interaction Theme Day and Survey, March 2012.[3] Friess, Erin. “Personas and Decision Making in the Design Process: An Ethnographic Case Study.” In Proceedings of CHI ’12. New York: ACM Press, 2012.[4] Goodman, Elizabeth. Performance and Materiality in Professional Interaction Design. PhD thesis, University of California, Berkeley, 2013.[5] Gray, Colin M., Erik Stolterman, and Martin A. Siegel. “Reprioritizing the Relationship Between HCI Research and Practice: Bubble-Up and Trickle-Down Effects.” Proceedings of CHI ’14. New York: ACM Press, 2014.

Source Link:
    What Is the Relationship Between HCI Research and UX Practice?
</description><source>TaoAlpha</source><author>TaoALpha</author></item></channel></rss>