<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TaoAlpha's Blog</title><link>http://taoalpha.me/blog</link><pubDate>2016-02-14T00:20:12.727Z</pubDate><description></description><language>en</language><generator>hexo</generator><item> <title>OJ Gas station</title><link>http://taoalpha.me/blog/2016/02/13/oj-oj-gas-station/</link><category>OJ</category><tag>Gas Station,LeetCode</tag><pubDate>2016-02-14T04:36:08.000Z</pubDate><description>134. Gas StationProblemThere are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.
LeetCode134. Gas Station
Tags: Medium, Greedy
AnswersBrute forceThe easiest way to solve this problem will be enumerate all possible start points and check whether you can pass or not.
Time complexity would be O(n^2).
123456789101112131415161718192021222324252627/** * @param &amp;#123;number[]&amp;#125; gas * @param &amp;#123;number[]&amp;#125; cost * @return &amp;#123;number&amp;#125; */var canCompleteCircuit = function(gas, cost) &amp;#123;    for (i = 0; i &amp;lt; gas.length; i++) &amp;#123;        if(helper(gas,cost))&amp;#123;           return i         &amp;#125;        gas.push(gas.shift())        cost.push(cost.shift())    &amp;#125;    return -1&amp;#125;;var helper = function(gas, cost) &amp;#123;    var i,j,preGas = 0, preCost = 0;    for (i = 0; i &amp;lt; gas.length; i++) &amp;#123;        if (gas[i] + preGas &amp;lt; cost[i] + preCost) &amp;#123;            return false        &amp;#125;        preGas += gas[i];        preCost += cost[i];    &amp;#125;    return true&amp;#125;
Runtime: TLE.
PruningConsider about this fact: if you start from A and you could not reach C, then if you start from any gas station between A and C, could you make it to C ?
No, you can not. Why ? I observe it. But here is a proof provided by some solutions from discussion.

Say there is a point C between A and B – that is A can reach C but cannot reach B. Since A cannot reach B, the gas collected between A and B is short of the cost. Starting from A, at the time when the car reaches C, it brings in gas &amp;gt;= 0, and the car still cannot reach B. Thus if the car just starts from C, it definitely cannot reach B.

Based on this affect, we can do some pruning for previous solution:
1234567891011121314151617181920212223242526272829303132333435363738/** * @param &amp;#123;number[]&amp;#125; gas * @param &amp;#123;number[]&amp;#125; cost * @return &amp;#123;number&amp;#125; */var canCompleteCircuit = function(gas, cost) &amp;#123;  var sumGas = 0, sumCost = 0;  for (var i = 0; i &amp;lt; gas.length; i++) &amp;#123;    sumGas += gas[i];    sumCost += cost[i];  &amp;#125;  // deal with no solution condition first  if(sumGas -1-1&amp;lt; sumCost) &amp;#123;return -1&amp;#125;  // now we know there definitely is a solution here.  for (var i = 0; i &amp;lt; gas.length; i++) &amp;#123;    var temp = helper(gas.slice(i),cost.slice(i));    if(temp == &quot;DONE&quot;)&amp;#123;      // Now we have the start point that can go through all the rest gas stations      return i+temp+1    &amp;#125;    // Now we now any gas stations before temp can not make it    i = temp+i  &amp;#125;&amp;#125;;var helper = function(gas, cost) &amp;#123;  var i,j,preGas = 0, preCost = 0;  for (i = 0; i &amp;lt; gas.length; i++) &amp;#123;    if (gas[i] + preGas &amp;lt; cost[i] + preCost) &amp;#123;      // definitely can not make it from i      return i    &amp;#125;    preGas += gas[i];    preCost += cost[i];  &amp;#125;  return &quot;DONE&quot;;&amp;#125;
Runtime: 100 ms
Even betterSimplify the previous pruning solution with one pass. Solution from discussion.
123456789101112131415var canCompleteCircuit = function(gas, cost) &amp;#123;  var i, tank = 0, start = 0, total = 0;  //if car fails at 'start', record the next station  for(i=0;i&amp;lt;gas.length;i++) &amp;#123;    tank += gas[i] - cost[i];  // gas left in your tank    if(tank&amp;lt;0) &amp;#123;      // you know you can not make it starting before i      start = i + 1;      total += tank;  // total gas you own along the way      tank = 0;  // reset the tank    &amp;#125;  &amp;#125;  // if the tank has fewer gas than you own, you can not make it, or you can start from current start position  return (total + tank &amp;lt; 0) ? -1 : start;&amp;#125;
Runtime: 84-90 ms
Two PointersStill could not figure out why this solution works… 
123456789101112131415var canCompleteCircuit = function(gas, cost) &amp;#123;  var start = gas.length - 1,      end = 0,      sum = gas[start] - cost[start];  while (start &amp;gt; end) &amp;#123;    if (sum &amp;gt;= 0) &amp;#123;      sum += gas[end] - cost[end];      end ++;    &amp;#125; else &amp;#123;      start --;      sum += gas[start] - cost[start];    &amp;#125;  &amp;#125;  return sum &amp;gt;= 0 ? start : -1;&amp;#125;
Runtime: 100 ms
Gas station seriesThere is some mutation problems on this gas station problem. So I just list here to broaden your eyes: 
Suppose you want to go on a road trip across the US. You start from New York City and would like to drive to San Francisco. 
Now you have a roadmap with all gas station locations and their gas prices.
You want to minimize the travel cost(gas expenses).
DPGas Station Series
Want to see the solution ? Check the link to see the PDF.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ water problems</title><link>http://taoalpha.me/blog/2016/02/13/oj-oj-water-problems/</link><category>OJ</category><tag>LeetCode,Two Pointers</tag><pubDate>2016-02-13T23:55:19.000Z</pubDate><description>11. Container With Most WaterProblemGiven n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.
LeetCode11. Container With Most Water
Tags: Array, Two Pointers, Medium
AnswersTwo pointers, keep tracking the max area.
12345678910111213141516/** * @param &amp;#123;number[]&amp;#125; height * @return &amp;#123;number&amp;#125; */var maxArea = function(height) &amp;#123;  var i = 0, j = height.length - 1, max = 0;  while (i&amp;lt;j) &amp;#123;    max = Math.max(max,Math.min(height[j] , height[i]) * (j - i));    if (height[i] &amp;lt; height[j]) &amp;#123;      i ++;    &amp;#125;else&amp;#123;      j --;    &amp;#125;  &amp;#125;  return max;&amp;#125;;
Runtime:  116 ms
42. Trapping Rain WaterProblemGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
LeetCode42. Trapping Rain Water
Tags: Array, Stack, Two Pointers
AnswersDifferent with previous question, now we need to keep tracking the trapping water. Consider collection the water on each cell: every cell how much mater you can collect depends on the smaller one of the max height of your left bars and the max height of your right bars.
12345678910111213141516171819202122232425/** * @param &amp;#123;number[]&amp;#125; height * @return &amp;#123;number&amp;#125; */var trap = function(height) &amp;#123;  var i,j, left = [], right = [], max = 0, res = 0;  for (i = 0; i &amp;lt; height.length; i++) &amp;#123;    // store the max high left bar of each position    max = Math.max(max,height[i]);    left[i] = max;  &amp;#125;  max = 0;  for (i = height.length - 1; i &amp;gt;= 0; i--) &amp;#123;    // store the max high righ bar of each position    max = Math.max(max,height[i]);    right[i] = max;  &amp;#125;  for (i = 0; i &amp;lt; height.length; i++) &amp;#123;    var temp = Math.min(left[i],right[i]);    if(temp &amp;gt; height[i]) &amp;#123;      res += temp - height[i]    &amp;#125;  &amp;#125;  return res&amp;#125;;
Runtime: 144 ms
Actually we don’t need the two list storing the maxLeft and maxRight, since every max value we only will use once and both maxLeft and maxRight are depends on the bars on the left or right of the current bar. So we can just use two numbers track it.
Then you can simplify your code:
12345678910111213141516171819/** * @param &amp;#123;number[]&amp;#125; height * @return &amp;#123;number&amp;#125; */var trap = function(height) &amp;#123;  var i = 0, j = height.length - 1, leftMax = 0, rightMax = 0, res = 0;  while(i&amp;lt;=j)&amp;#123;    leftMax = Math.max(leftMax,height[i]);    rightMax = Math.max(rightMax,height[j]);    if (leftMax &amp;lt; rightMax) &amp;#123;      res += (leftMax - height[i]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored      i++;    &amp;#125;else&amp;#123;      res += (rightMax - height[j]);      j--;    &amp;#125;  &amp;#125;return res;&amp;#125;;
Runtime: 124 ms
Two pointers is a really good solution for some classical questions like KSum, Palindrome Problems…
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Add SSL to your github pages with customized domain</title><link>http://taoalpha.me/blog/2016/02/11/tech-add-ssl-to-your-github-pages-with-customized-domain/</link><category>tech</category><tag>DNS,Github Pages,SSL</tag><pubDate>2016-02-11T22:45:06.000Z</pubDate><description>Since Google announced that HTTPS as a ranking signal, all the webmasters including the people like me owns a personal website starts considering moving from HTTP to HTTPS.
There are plenty of ways to add SSL to your website, most of host service providers will provide the SSL for you, you just need to pay for it :). If you don’t want to pay and also can access your server from SSH, you may try Let’s Encrypt which is a free and open certificate authority.
If you are using github pages, you should be fine already since github pages has already supported HTTPS since 2014/4 GitHub Pages Now (Sorta) Supports HTTPS, So Use It.
But if you are using customized domain, you need to do some leg work to make it support SSL, and free. :)
SSLWhat is SSL (Secure Sockets Layer) ? According to google: 

SSL is the standard security technology for establishing an encrypted link between a web server and a browser. This link ensures that all data passed between the web server and browsers remain private and integral.

About how to encrypt the data, you can check here to read more).
CloudFlareCloudFlare is like a service that help you improve the performance of your website, like dynamic dns, analytics … and security like SSL. So it is the easiest way to move your website to HTTPS
Moving to HTTPSHere is a really good post about how to move the HTTP to HTTPS. Set Up SSL on Github Pages With Custom Domains for Free
I just summarize some important steps as follow:

Sign up in CloudFlare
Add your site
Confirm the records including the A and CNAME (you can add some new or delete some wrong ones)
Get the new nameserver from cloudflare
Replace the nameserver in your domain provider(where you buy the domain from)
Sit and wait

Default as HTTPSIf you want to redirect all your users to HTTPS version, you can achieve that with a little script:
1234var host = &quot;yoursite.com&quot;;if ((host == window.location.host) &amp;amp;&amp;amp; (window.location.protocol != &quot;https:&quot;)) &amp;#123;  window.location.protocol = &quot;https&quot;;&amp;#125;
If you change to HTTPS, you can not load resources through http request, so remember to change your resources to https too.
If you have some api calls which don’t have a https version, you have to figure out some ways to solve that. Here I have three solutions may be helpful:

S1: Replace with another similar serviceif you can find some alternatives, you may just replace the old http service with new https alternative, you may need to change your code as well since the api may have some little difference.
S2: Proxyif you host your website on a server which you have access to it, you may build your own proxy and replacing the old request with your proxy(like forwarding all http request to your proxy, and forwarding retrieved data back to your site).
S3: Cookie trickif you are using a static website host like github pages, and your data is pretty small and doesn’t change so frequently. You may can use cookie trick : everytime when someone loads the page, check the cookie, if already got, load your site through https, otherwise, load with http and retrieve the data and store in cookie. So if your users have the cookie, they will always in HTTPS protocol and the data would be renderred perfectly.

Currently, the weather information I show on my website is using openweathermap and I have only http version if I don’t want to pay them :) So I use the cookie trick to store the information in cookie during your first visit(or the first visit after the cookie expired), every visit after that will be redirected to HTTPS automatically. :)
Updates
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Feedpusher Close Alpha</title><link>http://taoalpha.me/blog/2016/02/10/tech-feedpusher-close-alpha/</link><category>tech</category><tag>FeedPusher,MongoDB</tag><pubDate>2016-02-10T10:48:07.000Z</pubDate><description>Due to a big bug in MongoDB &amp;lt; 2.6 version, I lost maybe 20% data… The bug is pretty famous back to that time :) Caused by the limitation of MongoDB(16MB)…Since I set up all the server on my raspberry pi, the only available version of MongoDB for it is 2.1.1… so sad… I don’t know why I can not export all data to my local.. I can only export like 80% percent of them… still haven’t figured out why …
But anyway, this is kind of a good thing. You know, better be sooner :). And also this makes me decide to release the feedpusher as a packaged tool that you can use to built your own rss reader instead of a real service provider :)
So I have to say: there will be no beta test for feedpusher, since I have closed the test user account… so you can not log in with that test@mail.com any more, sorry :) But I have released all source code on github(separated into two different repo: feedpusher and baby). I will clear the code and combine them into the refactor branch of feedpusher soon.
For personal use, it will work great and provide high customizability! And in order to learn react, I will release the code with angular version and react version :)
Sorry for closing the test account, when I set up the authenticate level part, I will reopen it but for pure demo purpose. I just can not let some people ruin my database… :) I got a lot attact from China… I don’t know why… so sad… it’s my motherland, you should be nicer to me!!! :)
Written at 1:00am, Feb 10th, after clean the database :)
Good night!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Parentheses Problems 1</title><link>http://taoalpha.me/blog/2016/01/31/oj-oj-parentheses-problems/</link><category>OJ</category><tag>LeetCode,Parentheses</tag><pubDate>2016-01-31T21:43:37.000Z</pubDate><description>20. Valid ParenthesesQuestionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.
The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.
LeetCode20. Valid Parentheses
Tags: Stack, String, Easy
AnswersStack or Queue123456789101112131415161718192021222324/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;boolean&amp;#125; */var isValid = function(s) &amp;#123;  var list = [];  while (s.length != 0) &amp;#123;    if (list.length != 0 &amp;amp;&amp;amp; ( s[0] == &quot;)&quot; &amp;amp;&amp;amp; list[0] == &quot;(&quot; || s[0] == &quot;]&quot; &amp;amp;&amp;amp; list[0] == &quot;[&quot; || s[0] == &quot;&amp;#125;&quot; &amp;amp;&amp;amp; list[0] == &quot;&amp;#123;&quot;)) &amp;#123;      // The order or () &amp;#123;&amp;#125; [] is important, since the left one must show before the right one      // remove if we have a match pair      list.shift();    &amp;#125;else&amp;#123;      // add all unmatch one to the list      list.unshift(s[0]);    &amp;#125;    s = s.slice(1);  &amp;#125;  if (list.length != 0)&amp;#123;    return false;  &amp;#125;  return true;&amp;#125;
Runtime: 156 ms
The solution above uses the Queue structure, but you definitely can use stack, I tried, the time cost are pretty much same.
HashTableSame as before. just use a hashmap to save some lines of code.
1234567891011121314151617181920212223/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;boolean&amp;#125; */var isValid = function(s) &amp;#123;  var map = &amp;#123;    &quot;)&quot;:&quot;(&quot;,    &quot;&amp;#125;&quot;:&quot;&amp;#123;&quot;,    &quot;]&quot;:&quot;[&quot;  &amp;#125;;  var stack = [];  for (var i = 0; i &amp;lt; s.length; i++) &amp;#123;    if (s[i] == &quot;(&quot; || s[i] == &quot;[&quot; || s[i] == &quot;&amp;#123;&quot;) &amp;#123;      stack.push(s[i]);    &amp;#125; else &amp;#123;      if (map[s[i]] != stack.pop()) &amp;#123;        // not a match        return false      &amp;#125;    &amp;#125;  &amp;#125;  return stack.length == 0&amp;#125;
Runtime: 160 ms
22. Generate ParenthesesQuestionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
“((()))”, “(()())”, “(())()”, “()(())”, “()()()”
LeetCode22. Generate Parentheses
Tags: Backtracking, String, Medium
AnswerClassical backtracking questions. The most important part is to determine the exit condition.
1234567891011121314151617181920212223/** * @param &amp;#123;number&amp;#125; n * @return &amp;#123;string[]&amp;#125; */var generateParenthesis = function(n) &amp;#123;  var output = [];  dfs(n,n,&quot;&quot;,output);  return output&amp;#125;;var dfs = function(left, right, res, output) &amp;#123;  if (left &amp;gt; right || left &amp;lt; 0 || right &amp;lt; 0) &amp;#123;    // exit when out of bound    // exit when right appears before left    return  &amp;#125;  if (left == 0 &amp;amp;&amp;amp; right == 0)&amp;#123;    // correct result    output.push(res)    return  &amp;#125;  dfs(left-1,right,res+&quot;(&quot;,output)  dfs(left,right-1,res+&quot;)&quot;,output)&amp;#125;
Runtime: 140 ms
241. Different Ways to Add ParenthesesQuestionGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.
Example 1Input: “2-1-1”.
((2-1)-1) = 0(2-(1-1)) = 2Output: [0, 2]
Example 2Input: “23-45”
(2(3-(45))) = -34((23)-(45)) = -14((2(3-4))5) = -10(2((3-4)5)) = -10(((23)-4)5) = 10Output: [-34, -14, -10, -10, 10]
LeetCode241. Different Ways to Add Parentheses
Tags: Divide and Conquer, Medium
AnswerHere is the origin answer post
123456789101112131415161718192021222324252627282930/** * @param &amp;#123;string&amp;#125; input * @return &amp;#123;number[]&amp;#125; */var diffWaysToCompute = function(input) &amp;#123;  var result = [], i;  for (i = 0; i &amp;lt; input.length; i++)&amp;#123;    var c = input[i];    if (c == &quot;+&quot; || c == &quot;-&quot; || c == &quot;*&quot;) &amp;#123;      var result1 = diffWaysToCompute(input.slice(0,i));      var result2 = diffWaysToCompute(input.slice(i+1));      for (var j = 0; j &amp;lt; result1.length; j++) &amp;#123;        for (var t = 0; t &amp;lt; result2.length; t++) &amp;#123;          if (c == &quot;+&quot;) &amp;#123;            result.push(result1[j] + result2[t]);          &amp;#125; else if (c == &quot;-&quot;) &amp;#123;            result.push(result1[j] - result2[t]);          &amp;#125; else &amp;#123;            result.push(result1[j] * result2[t]);          &amp;#125;        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;  if (result.length == 0) &amp;#123;    result.push(Number(input));  &amp;#125;  return result&amp;#125;;
Runtime : 168 ms
There is another solution in the same post with DP or hashtable more accuracy. Since we calculate the substring all the time, so we can just store them in a hashmap and check whether we have calculated it or not before we do the calculation. 
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @param &amp;#123;string&amp;#125; input * @return &amp;#123;number[]&amp;#125; */var diffWaysToCompute = function(input) &amp;#123;  var map = &amp;#123;&amp;#125;;  return computeWithDP(input,map);&amp;#125;var computeWithDP = function(input,dpMap) &amp;#123;  var result = [], i;  for (i = 0; i &amp;lt; input.length; i++)&amp;#123;    var c = input[i];    if (c == &quot;+&quot; || c == &quot;-&quot; || c == &quot;*&quot;) &amp;#123;      var result1, result2, substr = input.slice(0,i);      if (dpMap[substr]) &amp;#123;        result1 = dpMap[substr];      &amp;#125; else &amp;#123;        result1 = computeWithDP(substr, dpMap);      &amp;#125;      substr = input.slice(i + 1);      if (dpMap[substr]) &amp;#123;        result2 = dpMap[substr];      &amp;#125; else &amp;#123;        result2 = computeWithDP(substr, dpMap);      &amp;#125;      for (var j = 0; j &amp;lt; result1.length; j++)&amp;#123;        for (var t = 0; t &amp;lt; result2.length; t++)&amp;#123;          if (c == &quot;+&quot;) &amp;#123;            result.push(result1[j] + result2[t]);          &amp;#125; else if (c == &quot;-&quot;) &amp;#123;            result.push(result1[j] - result2[t]);          &amp;#125; else &amp;#123;            result.push(result1[j] * result2[t]);          &amp;#125;        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;  if (result.length == 0) &amp;#123;    result.push(Number(input));  &amp;#125;  dpMap[input] = result;  return result&amp;#125;
Runtime: 160 ms
There are still two hardquestions about the parentheses… but I don’t think I can solve it by myself… even I see the answer… I don’t think I can come up with it after today…
So I will just leave them to …. future… :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Calculator Problems</title><link>http://taoalpha.me/blog/2016/01/30/oj-oj-calculator-problems/</link><category>OJ</category><tag>LeetCode,Stack</tag><pubDate>2016-01-31T01:18:18.000Z</pubDate><description>224    Basic CalculatorQuestionImplement a basic calculator to evaluate a simple expression string.
The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .
You may assume that the given expression is always valid.
Some examples:“1 + 1” = 2“ 2-1 + 2 “ = 3“(1+(4+5+2)-3)+(6+8)” = 23
Note: Do not use the eval built-in library function.
LeetCode224	Basic Calculator
Tags: Stack, Math, Medium
AnswersTwo StackFirst, we can use two stack, one stores numbers, the other stores the operators, and once we got the “)”, we start to pop elements and operators to calculate.
123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  var nums = [], ops = [], number = 0, i;  //s = s.replace(/ /g,&quot;&quot;); // skip all spaces with replace first  for(i = 0; i &amp;lt; s.length; i++)&amp;#123;    if(s[i] == &quot; &quot;) continue; // skip all spaces    var c = s[i];    if (c == '(' || c == '+' || c == '-') &amp;#123;      // push all operators into ops and go to next position      ops.push(c);       continue;    &amp;#125;    if (c == ')') &amp;#123;      // remove the remaining &quot;(&quot;      ops.pop();    &amp;#125;else if(s[i] != &quot; &quot;  &amp;amp;&amp;amp; Number.isInteger(Number(c)))&amp;#123;      // for digits, combine them to get our operands      // Number(&quot; &quot;) will be converted to 0 and return true for isInteger()      number = number*10 + Number(c);      if (i + 1 &amp;lt; s.length &amp;amp;&amp;amp; s[i+1] != &quot; &quot; &amp;amp;&amp;amp; Number.isInteger(Number(s[i+1]))) continue;      // make sure we got all digits for one operand, and no out of bound      nums.push(number);  // push the operand to our nums      number = 0;    &amp;#125;        if (ops.length == 0 || ops[ops.length-1] == &quot;(&quot;) continue;  // skip if no operators or we have finish all in this pair of parentheses      // get our operator and operands    var op2 = nums.pop(),        op = ops.pop();        // do the calculate with second operand    if (op == &quot;+&quot;) &amp;#123;      nums[nums.length-1] += op2;    &amp;#125;else if (op == &quot;-&quot;) &amp;#123;      nums[nums.length-1] -= op2;    &amp;#125;  &amp;#125;  return nums.pop()  // now our nums should only have our result&amp;#125;
Runtime: 168 ms - 180 ms
One StackPrevious solution we use a second stack store the operators, but actually we don’t need to do that. If we separate the whole expression into several small parts, then everytime we find a parentheses, we just store the previous result after calculation to the stack, and solve the inner part first.
And in order to do this way, we need initialize the result to 0.
1234567891011121314151617181920212223242526272829303132333435363738/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  var stack = [],i,sign = 1,result = 0, number = 0;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    var c = s[i];    if (c != &quot; &quot; &amp;amp;&amp;amp; Number.isInteger(Number(c))) &amp;#123;      number = 10*number + Number(c)    &amp;#125; else if (c == &quot;+&quot;) &amp;#123;      result += sign * number;      sign = 1;  // keep the positive sign      number = 0;  // clear the number after calculation    &amp;#125; else if (c == &quot;-&quot;) &amp;#123;      result += sign * number;      number = 0;      sign = -1;  // make sure now we have a negative operator, this will affect the last result of next number    &amp;#125; else if (c == &quot;(&quot;) &amp;#123;      // result += sign*number;  // make sure our result including the last number, actually a open parenthese would always follow another operator like + or -, and we already clear the number      // now we need store the result to stack      stack.push(result);      stack.push(sign);  // store the sign, used for next operand (previous result +/- wait for next result)      result = 0;  // clear the result and solve the inner part      sign = 1;  // reinitialize the sign    &amp;#125; else if (c == &quot;)&quot;) &amp;#123;      // now we finish the inner part      result += sign*number;  // the end parenthese always follow a number      result *= stack.pop();  // determine it is - or + this result      result += stack.pop();  // now add the previous result      number = 0;  // clear the number    &amp;#125;  &amp;#125;  if (number != 0) &amp;#123;    result += sign * number;  // in case we only have a number without any operators  &amp;#125;  return result;&amp;#125;
Runtime: 176 ms
227. Basic Calculator IIQuestionImplement a basic calculator to evaluate a simple expression string.
The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.
You may assume that the given expression is always valid.
Some examples:“3+2*2” = 7“ 3/2 “ = 1“ 3+5 / 2 “ = 5
Note: Do not use the eval built-in library function.
LeetCode227. Basic Calculator II
Tags: String, Medium
AnswersDirect Updating StackSince we don’t have parentheses which make this question much easier, we can just keep calculating all the * and /, then store all results into the stack, and also store the - with second operator as a negative number, then we just need to sum all the stack to get our final answer.
In order to deal with the first number, we could prepend the expression with a “0+”, so we initialize the first number as 0 and first operator as “+”.
123456789101112131415161718192021222324252627282930313233/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */ var calculate = function(s) &amp;#123;   var stack = [], num = 0, c = &quot;+&quot;, i;   for (i = 0; i &amp;lt; s.length+1; i++) &amp;#123;     if (s[i] == &quot; &quot;) continue;  // skip all spaces     if (Number.isInteger(Number(s[i]))) &amp;#123;       num = 10 * num + Number(s[i]);       continue;     &amp;#125;else if (c == &quot;+&quot;) &amp;#123;       stack.push(num);     &amp;#125;else if (c == &quot;-&quot;) &amp;#123;       stack.push(-num);     &amp;#125;else if (c == &quot;*&quot;) &amp;#123;       stack.push(stack.pop()*num);  // do the calculation!     &amp;#125;else if (c == &quot;/&quot;) &amp;#123;       // be careful about the negative number, since we only need the integer part       var temp = stack.pop();       if (temp &amp;lt; 0) &amp;#123;         temp = Math.ceil(temp/num);       &amp;#125;else&amp;#123;         temp = Math.floor(temp/num);       &amp;#125;       stack.push(temp);     &amp;#125;     num = 0;     c = s[i];  // always store the precious closest operator before current number   &amp;#125;   stack.push(num);   return stack.reduce( (sum,v) =&amp;gt; sum += v )&amp;#125;
Runtime: 236 ms
Previous code would have an “out of bound” issue, but js just doesn’t have this kind of error…
You can remove the continue after getting the number, and change the condition for second part with:
12345if (!Number.isInteger(Number(s[i])) || i == s.length - 1) &amp;#123;  ...  num = 0;  c = s[i];&amp;#125;
Runtime: 200 ms
No StackSame idea, but we don’t need the stack, we just keep the previous result and always add the current result to the previous result whenever we can.123456789101112131415161718192021222324252627282930/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  var result = 0, cur_res = 0, op = '+', pos;  s = s.replace(/ /g,'');  for(pos = 0; pos &amp;lt; s.length;) &amp;#123;    if (Number.isInteger(Number(s[pos]))) &amp;#123;      var tmp = Number(s[pos]);      while(pos++ &amp;lt; s.length &amp;amp;&amp;amp; Number.isInteger(Number(s[pos]))) &amp;#123;        tmp = tmp*10 + Number(s[pos]);      &amp;#125;      switch (op) &amp;#123;        case '+' : cur_res += tmp; break;        case '-' : cur_res -= tmp; break;        case '*' : cur_res *= tmp; break;        case '/' : cur_res = cur_res &amp;lt;= 0 ? Math.ceil(cur_res / tmp) : Math.floor(cur_res / tmp); break;      &amp;#125;    &amp;#125;else &amp;#123;      if(s[pos] == '+' || s[pos] == '-') &amp;#123;        result += cur_res;        cur_res = 0;      &amp;#125;      op = s[pos++];    &amp;#125;  &amp;#125;  return result + cur_res;&amp;#125;
Runtime: 196 ms
CalculatorQuestionSo if we combine the two problems together, we can make a simple calculator that can do basic calculation.
AnswerThe basic idea is convert the infix notation to Polish notation or Reverse Polish notation and store them into a stack, then we can just use stack to calculate the result.
Here is the origin solution from leetcode
Here is the reverse polish notation on wikipedia
12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var calculate = function(s) &amp;#123;  s = &quot;(&quot; + s.replace(/ /g,'') + &quot;)&quot;;  var nums = [], ops = [], i, curNum = 0;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    var c = s[i];    if (Number.isInteger(Number(c))) &amp;#123;      curNum = 10*curNum + Number(c);    &amp;#125; else if (c == &quot;(&quot;) &amp;#123;      ops.push(&quot;(&quot;);      ops.push(&quot;+&quot;);    &amp;#125; else &amp;#123;      var topOp = ops[ops.length-1];      switch (topOp) &amp;#123;        case &quot;*&quot;:        case &quot;/&quot;:          curNum = topOp == &quot;/&quot; ? Math.floor(nums.pop()/curNum) : nums.pop() * curNum;          ops.pop();      &amp;#125;      switch (c) &amp;#123;        case &quot;)&quot;:          if (ops[ops.length-1] == &quot;-&quot;) &amp;#123;            curNum = -curNum;          &amp;#125;          ops.pop();          while (ops[ops.length-1] != &quot;(&quot;) &amp;#123;            curNum += ops.pop() == &quot;-&quot; ? -nums.pop() : nums.pop();          &amp;#125;          ops.pop();  // skip &quot;(&quot;          break        default:          ops.push(c);          nums.push(curNum);          curNum = 0;      &amp;#125;    &amp;#125;  &amp;#125;  return curNum&amp;#125;
Runtime: 184 ms for Basic Calculator IRuntime: 196 ms for Basic Calculator II
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Remove Duplicate Letters</title><link>http://taoalpha.me/blog/2016/01/26/oj-oj-remove-duplicate-letters/</link><category>OJ</category><tag>Greedy,LeetCode</tag><pubDate>2016-01-26T23:26:53.000Z</pubDate><description>316. Remove Duplicate LettersQuestionGiven a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.
Example:Given “bcabc”Return “abc”
Given “cbacdcbc”Return “acdb”
LeetCode316. Remove Duplicate Letters My Submissions Question
Tags: Medium, Stack, Greedy
AnswersGreedy
Greedy algorithm is an algorithm that follows the problem solving heuristic of making the locally optimal choice at each stage with the hope of finding a global optimum. In many problems, a greedy strategy does not in general produce an optimal solution, but nonetheless a greedy heuristic may yield locally optimal solutions that approximate a global optimal solution in a reasonable time.

Classic problem is the coin changes problem: determine minimum number of coins to give while making change.
This problem can also be solved with greedy algorithm, we just need to determine the local optimal choice first: 

We need find the current smallest letter in the string and put it into our result, smallest means that smallest one that could be put into the result;

Now question is how we determine the smallest letter:

Condition 1: the letter is smaller than every letter appeared before it and it only appear once, then it would be our smallest, like “cbacb”, the “a” will be our current smallest;
Condition 2: the letter only appeared once and the smallest letter should be the first smallest letter before this letter, like “cbdcb”, so the “b” will be our current smallest;

1234567891011121314151617181920212223242526272829/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var i,j,res = &quot;&quot;;  while (s !== &quot;&quot;) &amp;#123;    var countMap = &amp;#123;&amp;#125;;    // build the countMap for current string    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      countMap[s[i]] = countMap[s[i]] || 0;      countMap[s[i]] ++;    &amp;#125;    var smallestPos = 0;    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      if (s[smallestPos] &amp;gt; s[i]) &amp;#123;        // update the smallest number        smallestPos = i      &amp;#125;      // until find the letter only appeared once, and we will get the index of our smallest letter      if (countMap[s[i]] == 1) break;      countMap[s[i]] --;    &amp;#125;    // put the letter into our result string    res += s[smallestPos];    s = s.slice(smallestPos+1).replace(new RegExp(s[smallestPos],&quot;g&quot;),&quot;&quot;)  &amp;#125;  return res&amp;#125;;
Runtime: 244 ms
If we build the countMap with 0 default before we do the count part, it can speed up a little.
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var i,j,res = &quot;&quot;;  while (s !== &quot;&quot;) &amp;#123;    var countMap = &amp;#123;&amp;#125;;    // build the countMap for current string    for (i = 0; i &amp;lt; 26; i++) &amp;#123;       countMap[String.fromCharCode(i + 97)] = 0    &amp;#125;    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      countMap[s[i]] ++;    &amp;#125;    var smallestPos = 0;    for (i = 0; i &amp;lt; s.length; i++) &amp;#123;      if (s[smallestPos] &amp;gt; s[i]) &amp;#123;        // update the smallest number        smallestPos = i      &amp;#125;      // until find the letter only appeared once, and we will get the index of our smallest letter      if (countMap[s[i]] == 1) break;      countMap[s[i]] --;    &amp;#125;    // put the letter into our result string    res += s[smallestPos];    s = s.slice(smallestPos+1).replace(new RegExp(s[smallestPos],&quot;g&quot;),&quot;&quot;)  &amp;#125;  return res&amp;#125;;
Runtime: 196 ms
And of course you can use recursion instead of iterator to do it, but it should be slower than iteration way.
StackThis is a solution I found from the discussion: C++ solution using stack
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var cnts = &amp;#123;&amp;#125;, stack = [], isVisited = &amp;#123;&amp;#125;;  var i,j;  // build count mapper   for (i = 0; i &amp;lt; 26; i++) &amp;#123;     cnts[String.fromCharCode(i + 97)] = 0  &amp;#125;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    cnts[s[i]] ++  &amp;#125;  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    cnts[s[i]] --;    if (isVisited[s[i]]) continue;    while (s[i] &amp;lt; stack[0] &amp;amp;&amp;amp; cnts[stack[0]]) &amp;#123;      // if the letter is smaller than previous smaller letter(stack[0]) and we still have some stack[0] after this letter,      // Then we remove it from the stack      isVisited[stack[0]] = false;      stack.shift();    &amp;#125;    // put the smaller one we find into the stack    stack.unshift(s[i]);    isVisited[s[i]] = true;  &amp;#125;  return stack.reverse().join(&quot;&quot;)&amp;#125;
Runtime: 192 ms
This is so comlicated to figure out… I don’t think I can come up with this solution during any interview… maybe I can after I finish the Algoithm Class of this semester.
Another WayEasy to understand iterative Java solution has a really nice and easy to understand solution for this problem.

find out the last appeared position for each letter; c - 7 b - 6 a - 2 d - 4find out the smallest index from the map in step 1 (a - 2);the first letter in the final result must be the smallest letter from index 0 to index 2;repeat step 2 to 3 to find out remaining letters.

123456789101112131415161718192021222324252627282930313233343536373839/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var removeDuplicateLetters = function(s) &amp;#123;  var countMap = &amp;#123;&amp;#125;, res = [];  var i,j;  // build count mapper with letter-last index  for (i = 0; i &amp;lt; s.length; i++) &amp;#123;    countMap[s[i]] = i  &amp;#125;  // loop and try to find the smallest letter between each interval of last index, start from 0  var len = Object.keys(countMap).length,      begin = 0,      end = findMinLastIdx(countMap);  for (i = 0; i &amp;lt; len; i++) &amp;#123;    var minChar = &quot;z&quot;;    for (j = begin; j &amp;lt;= end; j++) &amp;#123;      if (countMap[s[j]] &amp;gt; -1 &amp;amp;&amp;amp; s[j] &amp;lt; minChar) &amp;#123;        minChar = s[j];        begin = j + 1;      &amp;#125;    &amp;#125;    res[i] = minChar;    countMap[minChar] = -1    end = findMinLastIdx(countMap);  &amp;#125;  return res.join(&quot;&quot;)&amp;#125;var findMinLastIdx = (countMap) =&amp;gt; &amp;#123;  var min = Math.pow(2,31)-1;  for(var item in countMap)&amp;#123;    if(countMap[item]!=-1)&amp;#123;      min = Math.min(countMap[item],min)    &amp;#125;  &amp;#125;  return min&amp;#125;
Runtime: 192 ms
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Ugly Number Problems</title><link>http://taoalpha.me/blog/2016/01/25/oj-oj-ugly-number-problems/</link><category>OJ</category><tag>LeetCode,Numbers</tag><pubDate>2016-01-25T07:09:04.000Z</pubDate><description>263. Ugly NumberQuestionWrite a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.
Note that 1 is typically treated as an ugly number.
LeetCode263. Ugly Number
Tags: Math, Easy
AnswersI think there is only one way to solve this problem efficiently, which is based on the math fact of this problem.
Based on the definition, if we keep dividing the number by 2, 3 or 5, and finally we get 1, then it should be a ugly number, otherwise it would be something else.
1234567891011121314/** * @param &amp;#123;number&amp;#125; num * @return &amp;#123;boolean&amp;#125; */var isUgly = function(num) &amp;#123;  // num is not prime and divide by 2, 3, 5   if(num&amp;lt;1)&amp;#123;return false&amp;#125;  if(num === 1)&amp;#123;return true&amp;#125;  num = num % 5 === 0 ? num / 5 : (num % 3 === 0) ? (num / 3) : (num % 2 === 0) ? (num / 2) : &quot;true&quot;;  if(num === &quot;true&quot;)&amp;#123;    return false;  &amp;#125;  return isUgly(num)&amp;#125;;
Runtime: 208 ms
We can simplify above code with an for and while loop.
123456789101112/** * @param &amp;#123;number&amp;#125; num * @return &amp;#123;boolean&amp;#125; */var isUgly = function(num) &amp;#123;  for (var p of [2, 3, 5])&amp;#123;    while (num &amp;amp;&amp;amp; num % p == 0) &amp;#123;      num /= p;    &amp;#125;  &amp;#125;  return num == 1;&amp;#125;;
Runtime: 224 ms
264. Ugly Number IIQuestionWrite a program to find the n-th ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note that 1 is typically treated as an ugly number.
LeetCode264. Ugly Number II
Tags: Dynamic Programming, Heap, Math, Medium
AnswersUsing isUgly123456789101112131415161718192021222324252627/** * @param &amp;#123;number&amp;#125; n * @return &amp;#123;number&amp;#125; */var nthUglyNumber = function(n) &amp;#123;    console.log(n)    if(n &amp;lt;= 0) return false; // get rid of corner cases     if(n == 1) return 1; // base case    var count=1,i=0,num = 1;    for(i = 1;count &amp;lt;= n;i++)&amp;#123;        if(isUgly(i))&amp;#123;            count ++;            num = i;        &amp;#125;    &amp;#125;    return num&amp;#125;;var isUgly = function(num) &amp;#123;  // num is not prime and divide by 2, 3, 5   if(num&amp;lt;1)&amp;#123;return false&amp;#125;  if(num === 1)&amp;#123;return true&amp;#125;  num = num % 5 === 0 ? num / 5 : (num % 3 === 0) ? (num / 3) : (num % 2 === 0) ? (num / 2) : &quot;true&quot;;  if(num === &quot;true&quot;)&amp;#123;    return false;  &amp;#125;  return isUgly(num)&amp;#125;;
Sadly, it will be TLE since it is so slow….
DPThis is a classic DP problem if you treat every n-th is a status, and we can find:

f(0) = 1
f(1) = min(f(0)2,f(0)3,f(0)*5)
f(2) = min(f(1)2,f(0)3,f(0)*5)…

Just be careful about the number like 6, since it can be got from 23 or 32, so we need update both pointers stand for 2 and 3.
123456789101112131415161718/** * @param &amp;#123;number&amp;#125; n * @return &amp;#123;number&amp;#125; */var nthUglyNumber = function(n) &amp;#123;  if(n &amp;lt;= 0) return false; // get rid of corner cases   if(n == 1) return 1; // base case  var p2 = 0, p3 = 0, p5 = 0; //pointers for 2, 3, 5  var f = [];  f[0] = 1;  for(var i  = 1; i &amp;lt; n ; i ++)&amp;#123;    f[i] = Math.min(f[p2]*2,f[p3]*3,f[p5]*5);    if(f[i] == f[p2]*2) p2++;     if(f[i] == f[p3]*3) p3++;    if(f[i] == f[p5]*5) p5++;  &amp;#125;  return f[n-1];&amp;#125;;
Runtime: 212 ms
313. Super Ugly NumberQuestionWrite a program to find the nth super ugly number.
Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.
Note:(1) 1 is a super ugly number for any given primes.(2) The given numbers in primes are in ascending order.(3) 0 &amp;lt; k ≤ 100, 0 &amp;lt; n ≤ 106, 0 &amp;lt; primes[i] &amp;lt; 1000.
LeetCode313. Super Ugly Number
Tags: Math, Heap, Medium
AnswersDPWe can use same code as before, just replace the hardcode 2,3,5 with a prime list.
12345678910111213141516171819202122232425/** * @param &amp;#123;number&amp;#125; n * @param &amp;#123;number[]&amp;#125; primes * @return &amp;#123;number&amp;#125; */var nthSuperUglyNumber = function(n, primes) &amp;#123;  if(n &amp;lt;= 0) return false; // get rid of corner cases   if(n == 1) return 1; // base case  var p = [];  for(var i = 0;i&amp;lt;primes.length;i++)&amp;#123;    p[i] = &amp;#123;      prime : primes[i],      count:0    &amp;#125;;  &amp;#125;  var f = [];  f[0] = 1;  for(var i  = 1; i &amp;lt; n ; i ++)&amp;#123;    f[i] = Math.min.apply(null,p.map( (a) =&amp;gt; &amp;#123; return f[a.count]*a.prime &amp;#125; ) );    for(j = 0;j&amp;lt;p.length;j++)&amp;#123;      if(f[p[j].count]*p[j].prime == f[i]) p[j].count ++;     &amp;#125;  &amp;#125;  return f[n-1];&amp;#125;;
Runtime: 404 ms
HeapAs usally, though I got accepted for the dp solution, but it is so slow… So I open the discussion and look through some best votes answers, find this nice solution:
12345678910111213141516171819202122232425/** * @param &amp;#123;number&amp;#125; n * @param &amp;#123;number[]&amp;#125; primes * @return &amp;#123;number&amp;#125; */var nthSuperUglyNumber = function(n, primes) &amp;#123;  var res = [1],      idxs = [],      i,j;  for (i = 1; i &amp;lt; n; i++) &amp;#123;    res[i] = Math.pow(2,31) - 1;    for (j = 0; j &amp;lt; primes.length; j++)&amp;#123;      idxs[j] = idxs[j] || 0;      res[i] = Math.min(res[i],primes[j] * res[idxs[j]]);    &amp;#125;    for (j = 0; j &amp;lt; idxs.length; j++)&amp;#123;      if (res[i] == primes[j] * res[idxs[j]]) &amp;#123;        idxs[j] = idxs[j] || 0;        idxs[j] ++;      &amp;#125;    &amp;#125;  &amp;#125;  return res[n-1]&amp;#125;
Runtime: 276 ms
Actually it is pretty much the same as the DP solution… but much faster. 
We actually can combine the two for loops into one to speed up again:
123456789101112131415161718192021var nthSuperUglyNumber = function(n, primes) &amp;#123;  var res = [],      idxs = [],      vals = new Array(primes.length+1).join(1).split('').map(parseFloat),      i,j,next = 1;    for (i = 0; i &amp;lt; n; i++) &amp;#123;    res[i] = next;    next = Math.pow(2,31) - 1;    for (j = 0; j &amp;lt; primes.length; j++)&amp;#123;      // skip duplicate and avoid extra multiplication      if (vals[j] == res[i]) &amp;#123;        idxs[j] = idxs[j] || 0;        vals[j] = res[idxs[j]++] * primes[j];      &amp;#125;      next = Math.min(next,vals[j]);    &amp;#125;  &amp;#125;  return res[n-1]&amp;#125;
Runtime: 232 ms
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>High-Performance Browser Networking .1.Preface</title><link>http://taoalpha.me/blog/2014/07/24/read-yi-high-performance-browser-networking-1-preface/</link><category>read</category><tag>技术文章,浏览器性能,翻译文章,译系列</tag><pubDate>2014-07-24T11:00:00.000Z</pubDate><description>chrome一直以极速著称, 当然这和webkit内核有很大的关系, 但是本身chrome在网络处理上也有着非常多的优化方案, 综合了这些优化和本身优质的内核属性, chrome才能实现如今的极速~ 
进入正文前, 先介绍下原文或者说原书的作者: Ilya Grigorik.
Ilya是google的一个网络性能开发工程师, 其在很多方面都有杰出的成绩~ 有兴趣的可以去大神的github上看看大神都在做什么项目, 顺带能观摩学习下大神的代码~
==================================正文=============================
前言–Steve Sounders, Head Performance Engineer, Google, 2013
“优秀的开发者知道如何做, 伟大的开发者知道为什么这么做.”
我们一直都以此名言勉励自己. 我们都希望成为那个知道而且可以解释我们所使用系统的底层原理的人. 但是, 如果你是一个网页开发者, 你可能反而要走相反的路子.
网页开发者现在变得越来越细分. 你是什么类型的开发者呢? 前端? 后端? 韵味? 大数据分析? UI/UX(交互设计)? 存储? 视频? 信息流? 我还可以给这个长长的列表中加入性能工程师这一细分领域. 
我们很多时候很难平衡技术的基础学习和前沿领域的了解. 但是, 如果我们不能了解这些基础知识, 我们的知识系统一定很空洞, 很浅薄. 仅仅知道一个技术手段的顶层使用是不够的, 尤其是在面对一些复杂的问题时, 一旦出现了一些莫名其妙的问题, 那么依赖的还是掌握底层原理的人.
这也是为什么本书(High Performance Browser Networking)如此重要了. 如果你是一个网页开发者, 那么你的基础知识就是网络以及网络协议基于的金字塔结构: TCP-TLS-UDP-HTTP以及其他一些东东. 这其中的每一个协议都有其自身的性能属性特点和优化方法, 而为了创建高性能的应用, 你就需要去了解网络的工作形式, 为什么是这样的而不是那样的~
感谢上苍, 你已经找到了如何阅读本书的方法. 我真希望在我开始网络编程之路时能够有这本书啊. 当初完全依靠那些懂得网络原理的前辈的言传身教以及自己硬啃那些说明指导才一步步走到现在的. HPBN一书集合了一个网络界的前辈–Ilya Grigorik–他把自己对网络的方方面面了解都融合集成到了这本书中.
在本书中, Ilya详尽解释了许多关于网络的原理性知识: 比如为什么延迟(latency)是性能的绊脚石. 为什么TCP并不总是最好的传送机制以及UDP可能是你更好的选择. 还有为什么链接复用是个非常关键的优化. 紧接着他更进一步的提供了很多提升网络性能的具体方法. 想要减少延迟? 尽可能在里客户端更近的服务器端中断会话. 想要提升链接的复用? 启用链接的长效性. 就是这种如何做和为什么这么做的结合让本书传达的知识更有可操作性.
Ilya 阐述了网络的基本原理并且基于此介绍了很多协议和浏览器方面的前沿知识. HTTP 2.0的有点也有所介绍. 回顾了XHR以及它的局限性, 和由此引发的跨域资源共享问题的介绍.Server-Sent Events, WebSockets, 和 WebRTC 也都所涉及, 带我们领略了一些浏览器网络的最前沿.
本书的两大核心就是基础原理和前沿知识. 性能是帮助我们理解网络的根本, 并将之转化到性能是如何影响到我们的网页和用户的. 它把复杂的概念转化成了我们可以真正用于提升优化自己网站并创造更好的用户体验的工具. 这一点很重要, 这也是你为什么要阅读本身的重要原因.
浏览器是当下受众面最广的部署平台了: 它出现在每一台智能手机, 平板, 笔记本, 台机和每一个介于其中形式的载体上. 实际上, 从目前设备的涨势来看, 我们预期2020年的时候入网设备能够达到200亿–至少有一个浏览器而且至少可以接入wifi或者信号基站. 而平台的形式, 设备的厂商, 以及操作系统的版本都不是问题, 每一个设备都至少会有一个网页浏览器, 而浏览器本身功能也在越发丰富了.
我们如何看到的浏览器已经和过去的老版本有了千差万别, 这得益于进来的一系列创新: HTML, CSS形成的展示层, JavaScript作为web集成的新语言被引入, 以及HTML5的提出和其新的API都在继续提升着新平台提供高性能应用的能力. 当今再没有别的技术或者平台能够做到这样, 这么的面向全部人类, 同时这也是如今各种机会, 创新频出的领域.
实际上, 再没有比浏览器内部的网络基础机构更适合阐述网络的快速迭代和创新了. 历史上, 我们曾经受限于简单的HTTP请求式交互, 而如今, 我们拥有了更加丰富的机制, 可以实现更加有效的信息流传递, 双向而实时的交流, 自定义应用协议的传递以及一对一的视频会议, 各方之间的数据直接传输等等, 只需要JavaScript, 足矣.
最终结果? 不计其数的联网设备, 已有服务和新服务中不断壮大的用户基数, 以及对高性能应用的高需求. 速度一直都是一个功能特点, 甚至对一些应用而言, 它是决胜功能点, 而一个高性能的网页应用也需要一个对浏览器如何工作以及和网络的交互有扎实, 基础的了解的人, 这也是本书的受众.
About this Book(关于本书)
我们的目的是能够覆盖到每一个应该了解网络是如何工作的开发者: 我们使用的是哪一种协议, 它有什么局限性, 如何最大化的优化你的性能来使用你的网络, 以及浏览器提供了什么样的网络特性来让你使用.
在此过程中, 我们会深入的了解TCP, UDP以及TLS协议, 以及如何去针对性的优化我们的应用和基础结构. 接着我们会深入的了解下无线和移动网是如何工作的–就是无线电波这家伙, 比较难懂–还会讨论一些它对我们设计和搭建我们自己的应用的启发. 最后, 我们们仔细剖析一下HTTP协议是如何工作的, 并调查下浏览器中许多新的,让你兴奋的网络特性:
    即将到来的HTTP 2.0的改善;    新XHR的特点和能力;    结合Server-Send Events的数据流    使用WebScoket的双向沟通;    点对点的视频和音频沟通–WebRTC;    点对点的数据交互–DataChannel

理解每一个字节都是如何传递的,以及每个传递过程和协议的属性对我们创建高性能应用都是至关重要的知识. 毕竟, 如果我们的应用卡死在网络上, 那么无论怎么渲染, JS或者其他的优化方式都是没有意义的. 我们的目标是通过近可能最大的提升网络性能而减少等待的时间.
HPBN一书将会是任何一个乐于研究优化传递和应用性能的开发者的菜, 更广面的, 任何一个不满足于一个简单的checklist, 而是想要了解浏览器和底层协议是如何工作的, 有着强烈好奇心的人, 都是本书的受众. 其中如何做以及为什么做会交替进行: 我们将会覆盖到很多实际的建议, 帮助你更好的进行配置和架构规划, 我们还会探究下每一种优化方法的益处和代价.
Conventions Used in This Book(本书使用的一些习惯表达)
    斜体: 代表新术语, URLs, email地址, 文件名或者文件扩展名;    Constant width:Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.    Constant width bold: Shows commands or other text that should be typed literally by the user.    Constant width italic: Shows text that should be replaced with user-supplied values or by values determined by context.后面三个和两种tip的形式都无法在本译文中体现, 所以就不管了哈…Source links:    Preface Part1    Preface Part2
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>FeedPusher Pre-Alpha-Release</title><link>http://taoalpha.me/blog/2016/01/23/tech-feedpusher-pre-release/</link><category>tech</category><tag>FeedPusher,NodeJS</tag><pubDate>2016-01-24T02:26:45.000Z</pubDate><description>As getting close the the end of the winter break, I’m almost ready to release the alpha version of new feedpusher :).
Here is some declaration before I release the first version :)

Instead of a public service, the first one or maybe several versions would be invitation only since the the service host on my raspberry pi, can not handle too many requests;
Also because I will host it on my raspberry pi until the beta version, so during the alpha, maybe the service will be kind of unstable but once I have some new and fancy functions, I will add to it… :) ;
And I will release all source code including the spider, and maybe write a series posts about how to set up one for youself (actually I have done that, here is the link to my feedpusher refactor branch, all updates will synchronize to this branch);
Normally I wouldn’t record any personal information except for your standard user profile, but I will record the person who add the site first as a trace to track contributions :) ;
If you really want to use it or test it, please send me an email to ask for an invitation code, otherwise, you can use test@mail.com and test2016 to log in and have fun, remember tell me all your suggestions if you have :)

Here is the basic functions the first released version will cover:

Common:
Sign in;
Add;
Delete;
Load more;
Read;
Mark as read(automatically);
Skip all read items;
Reload as requested;


tablet or middle sized screen:
Read within the page;
Check the x-frame-option, show tips when there is some CORS limitation;


Mobile or small screen:
Nothing special


Chrome App:
Use webview;


Chrome Extension:
Not this time;



Since you have read all these bullshit… :) Now you can try the demo with the test email and password I mentioned before.
Here is the Demo
:) Thanks!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Sum Closest Problems</title><link>http://taoalpha.me/blog/2016/01/21/oj-oj-sum-closest-problems/</link><category>OJ</category><tag>KSum,LeetCode</tag><pubDate>2016-01-22T03:12:51.000Z</pubDate><description>16. 3Sum ClosestQuestionGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
For example, given array S = {-1 2 1 -4}, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
LeetCode16. 3Sum Closest
Tags: Medium, Two Pointers, Array
AnswersKeep updating closest distanceThe first idea hit my head is using the same method in NSum Questions, but store the closest distance in a single value and keep updating it.
Here is the code:12345678910111213141516171819202122232425262728293031323334/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number&amp;#125; */var threeSumClosest = function(nums, target) &amp;#123;  if(nums.length &amp;lt;= 0)&amp;#123;    return 0  &amp;#125;  if(nums.length &amp;lt;= 3)&amp;#123;    return nums.reduce( (a,sum) =&amp;gt; sum += a )  &amp;#125;  var i,left,right,closest = Math.pow(2,31)-1;  // set initial min to maximum  nums.sort( (a,b) =&amp;gt; a-b );  for(i = 0;i&amp;lt;nums.length-2;i++)&amp;#123;    // use nums.lenght -2 since there will be 3 numbers    left = i+1;    right = nums.length - 1;    while(left &amp;lt; right)&amp;#123;      // update min if we can      var sum = nums[i] + nums[left] + nums[right];      if ( Math.abs(sum - target) &amp;lt; Math.abs((closest - target)) ) &amp;#123;        closest = sum;      &amp;#125;      // normal loop over every possibility      if (sum &amp;lt; target) &amp;#123;        left ++;      &amp;#125;else&amp;#123;        right --;      &amp;#125;    &amp;#125;  &amp;#125;  return closest&amp;#125;;
Runtime : 160 ms
If there are a lot cases that atually can find the right combiantion which is the target, you can check the sum and target during the while loop, and maybe stop it earlier.
123if(sum == target)&amp;#123;  return sum&amp;#125;
Seems no simple and better solution for this one. So I will stop here.
KSum ClosestThis is not a leetcode problem. But same as KSum or NSum problems, can we summarize a general solution for KSum Closest ?
1234567891011121314151617181920212223242526272829// pre-requirement: has to be at least one solutionvar KSumClosest = function(nums, target, output, preSum, N) &amp;#123;    if (nums.length &amp;lt; N || N &amp;lt; 2) return  if (N == 2) &amp;#123;    var i = 0,        j = nums.length - 1;    while (i &amp;lt; j) &amp;#123;      var sum = preSum + nums[i] + nums[j];      if ( Math.abs(sum - target) &amp;lt; Math.abs(output.ans - target) ) &amp;#123;        output.ans = sum;      &amp;#125;      // normal loop over every possibility      if (sum &amp;lt; target) &amp;#123;        i ++;      &amp;#125;else&amp;#123;        j --;      &amp;#125;    &amp;#125;  &amp;#125;else&amp;#123;    var i = 0;    for(i = 0;i&amp;lt;nums.length;i++)&amp;#123;        preSum += nums[i]        KSumClosest(nums.slice(i+1), target, output, preSum, N - 1)        preSum -= nums[i]    &amp;#125;  &amp;#125;&amp;#125;
Accepted by previous 3sum closest.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ Word Search Problems</title><link>http://taoalpha.me/blog/2016/01/20/oj-oj-word-search-problems/</link><category>OJ</category><tag>DFS,LeetCode,Word Search</tag><pubDate>2016-01-20T07:17:56.000Z</pubDate><description>79. Word SearchProblemGiven a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
For example,Given board =
[  [‘A’,’B’,’C’,’E’],  [‘S’,’F’,’C’,’S’],  [‘A’,’D’,’E’,’E’]]
word = “ABCCED”, -&amp;gt; returns true,word = “SEE”, -&amp;gt; returns true,word = “ABCB”, -&amp;gt; returns false.
LeetCode79. Word Search
Tags: Array, Backtracking, Medium
AnswersDFS and hashtableThe first idea hit my head is using dfs, so here is my exit condition:

index out of bound;
visited elements(stored in a hashtable);
prefix not fit with target;

True condition:

String match.

So I got my code:
123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string&amp;#125; word * @return &amp;#123;boolean&amp;#125; */var exist = function(board, word) &amp;#123;  var i , j, mapper = &amp;#123;&amp;#125;;   // all visited elements will be marked as true within mapper  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      if(board[i][j] == word[0])&amp;#123;        // start with the first same letter        if(dfs(board,i,j,'',word,mapper))&amp;#123;          return true        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;  return false&amp;#125;;var dfs = (board,x,y,comb,word,mapper) =&amp;gt;&amp;#123;  if(comb == word)&amp;#123;    // true condition    return true  &amp;#125;  if(mapper[x+&quot;-&quot;+y] || word.length &amp;lt; comb.length || word.indexOf(comb) !== 0)&amp;#123;    // exit condition 1    return false  &amp;#125;  if(x &amp;gt;= board.length || x &amp;lt; 0 || y &amp;gt;= board[x].length || y &amp;lt; 0) &amp;#123;    // exit condition 2, out of bound    return false  &amp;#125;  mapper[x+&quot;-&quot;+y] = true;  // mark current elements as visited  comb += board[x][y]  if(dfs(board,x+1,y,comb,word,mapper) || dfs(board,x,y+1,comb,word,mapper) || dfs(board,x,y-1,comb,word,mapper) || dfs(board,x-1,y,comb,word,mapper))&amp;#123;    return true  &amp;#125;else&amp;#123;    mapper[x+&quot;-&quot;+y] = false    // recover the element for following loop  &amp;#125;&amp;#125;
You can pass with this. But it will be slow as 404ms.
DFS OptimizationI look at my code again, and find that since I can compare the first letter, why not just compare the current letter for each dfs. So I move it into the dfs and simplify my code with new exit and true condition:
True condition:

All letters match;

Exit condition:

Letter not match;
index out of bound;
visited elements;

And also, we don’t need to store the visited elements, we can just change it and then put the origin one back after the loop;
So finally we got this:
123456789101112131415161718192021222324252627282930313233343536373839/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string&amp;#125; word * @return &amp;#123;boolean&amp;#125; */var exist = function(board, word) &amp;#123;  var i , j;  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      if(dfs(board,i,j,word,0))&amp;#123;        return true      &amp;#125;    &amp;#125;  &amp;#125;  return false&amp;#125;;var dfs = (board,x,y,word,step) =&amp;gt;&amp;#123;  if(step == word.length)&amp;#123;    // all letters match, we got our word    return true  &amp;#125;  if(x &amp;gt;= board.length || x &amp;lt; 0 || y &amp;gt;= board[x].length || y -1&amp;lt; 0) &amp;#123;    // exit condition 1 - out of bound    return false  &amp;#125;  if(board[x][y] == &quot;\0&quot; || board[x][y] !== word[step])&amp;#123;    // exit condition 2 - visited or not same letter    return false  &amp;#125;  var temp  = board[x][y];  board[x][y] = &quot;\0&quot;;   // change the visited elements to something else   if(dfs(board,x+1,y,word,step+1) || dfs(board,x,y+1,word,step+1) || dfs(board,x,y-1,word,step+1) || dfs(board,x-1,y,word,step+1))&amp;#123;    return true  &amp;#125;else&amp;#123;    board[x][y] = temp;   // put the origin letter back    return false  &amp;#125;&amp;#125;
Now with the new code, we can hit the 168 ms.
212. Word Search IIQuestionGiven a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
For example,Given words = [“oath”,”pea”,”eat”,”rain”] and board =
[  [‘o’,’a’,’a’,’n’],  [‘e’,’t’,’a’,’e’],  [‘i’,’h’,’k’,’r’],  [‘i’,’f’,’l’,’v’]]Return [“eat”,”oath”].Note:You may assume that all inputs are consist of lowercase letters a-z.
LeetCode212. Word Search II
Tags: Trie, Backtracking, Hard
AnswersTrie with classic waySince this question is based on the previous one, we can just borrow our previous code here. And if you just loop through all words, it will be TLE. So you have to do pruning to stop the dfs as soon as possible.
According to the hint, we can use Trie to help us stop the dfs earlier, here I just use some code I wrote for another problem. As before, lets list the exit condition and succesful conditions for this problem:
Exit conditions:

Out of bound;
Visited;
Prefix never show up in our Trie(which was built with all input words);

True conditon:

Words is in our Trie;

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Trie implementation in JavaScript */var TrieNode = function()&amp;#123;  // # of words end here   this.wordsCount = 0  // # of words will match the prefix  this.prefixMatches = 0  // all the node belong to this node  this.children = &amp;#123;&amp;#125;&amp;#125;var Trie = function()&amp;#123;  this.root = new TrieNode()&amp;#125;Trie.prototype.insert = function(word)&amp;#123;  // if not a word, return  if(word.length &amp;lt;=0) return  var node = this.root  var i = 0  // loop every character of the word and update associate node  while(i&amp;lt;word.length)&amp;#123;  if(!node.children.hasOwnProperty(word[i]))&amp;#123;    node.children[word[i]] = new TrieNode()  &amp;#125;  node = node.children[word[i]]   if(i == word.length-1)&amp;#123;    node.wordsCount ++  &amp;#125;else&amp;#123;    node.prefixMatches ++  &amp;#125;  i ++  &amp;#125;&amp;#125;Trie.prototype.startsWith = function(prefix)&amp;#123;  // if not a word, return  if(prefix.length &amp;lt;=0) return false  var node = this.root  var i = 0  // loop every character of the word and find whether there is any match  while(i&amp;lt;prefix.length)&amp;#123;  if(!node.children.hasOwnProperty(prefix[i]))&amp;#123;    return false  &amp;#125;  node = node.children[prefix[i]]   if(i == prefix.length-1 &amp;amp;&amp;amp; (node.prefixMatches !== 0 || node.wordsCount !== 0))&amp;#123;    return true  &amp;#125;  i ++  &amp;#125;  return false&amp;#125; Trie.prototype.search = function(word)&amp;#123;  // if not a word, return  if(word.length &amp;lt;=0) return false  var node = this.root  var i = 0  // loop every character of the word and find whether there is any match  while(i&amp;lt;word.length)&amp;#123;  if(!node.children.hasOwnProperty(word[i]))&amp;#123;    return false  &amp;#125;  node = node.children[word[i]]   if(i == word.length-1 &amp;amp;&amp;amp; node.wordsCount === 0)&amp;#123;    return false  &amp;#125;  i ++  &amp;#125;  return true&amp;#125;/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string[]&amp;#125; words * @return &amp;#123;string[]&amp;#125; */var findWords = function(board, words) &amp;#123;  var i,j, trie = new Trie(),output = new Set();  for(i = 0; i &amp;lt; words.length;i++)&amp;#123;    trie.insert(words[i])  &amp;#125;  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      dfs(board,i,j,0,'',trie,output)    &amp;#125;  &amp;#125;  var res = []  output.forEach( (v) =&amp;gt; &amp;#123;res.push(v)&amp;#125;)  return res&amp;#125;;/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string&amp;#125; word * @return &amp;#123;boolean&amp;#125; */var dfs = (board,x,y,str,trie,output) =&amp;gt;&amp;#123;  // the code is pretty much same with previous word search I, but store the fit words into output asap  if(x &amp;gt;= board.length || x &amp;lt; 0 || y &amp;gt;= board[x].length || y &amp;lt; 0) &amp;#123;    // exit condition 1 - out of bound     return false  &amp;#125;  if(board[x][y] == &quot;\0&quot;)&amp;#123;    // exit condition 2 - visited    return false  &amp;#125;  str += board[x][y];  // exit condition 2 - not in our trie tree  if(!trie.startsWith(str))&amp;#123;return false&amp;#125;  // match condition  if(trie.search(str))&amp;#123;output.add(str)&amp;#125;  var temp  = board[x][y];  board[x][y] = &quot;\0&quot;;  dfs(board,x+1,y,str,trie,output)  dfs(board,x,y+1,str,trie,output)  dfs(board,x,y-1,str,trie,output)  dfs(board,x-1,y,str,trie,output)  board[x][y] = temp;&amp;#125;
Runtime: 868 ms
This is so slow… that I even can not appear in the rumtime distribution of javascript….
Modified TrieAccording to this post: Java 15ms easiest solution. We actually don’t need the entire tree structure, we can modify the structure to speed up our answer for this problem.
Here is the code in JS:
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param &amp;#123;character[][]&amp;#125; board * @param &amp;#123;string[]&amp;#125; words * @return &amp;#123;string[]&amp;#125; */var findWords = function(board, words) &amp;#123;  var i,j,output=[], root = buildTrie(words);   // build the Trie with input words  for(i = 0;i&amp;lt;board.length;i++)&amp;#123;    for(j = 0;j&amp;lt;board[i].length;j++)&amp;#123;      dfs(board, i, j, root, output);    &amp;#125;  &amp;#125;  return output;&amp;#125;;var TrieNode = function()&amp;#123;  this.next = [];  // store next letter from 0 - 25 &amp;lt;= a - z  this.word = '';&amp;#125;var buildTrie = function(words)&amp;#123;  var i, root = new TrieNode(),j;  for(i = 0;i&amp;lt;words.length;i++)&amp;#123;    var node = root;    for(j = 0;j&amp;lt;words[i].length;j++)&amp;#123;      var idx = words[i][j].charCodeAt(0) - 97;   // hash index of the letter, all letters are lowercase      if(!node.next[idx])&amp;#123;        node.next[idx] = new TrieNode();      &amp;#125;      node = node.next[idx];  // move the node to the end    &amp;#125;    node.word = words[i];  // store the word in the end node  &amp;#125;  return root&amp;#125;var dfs = (board,i,j,node,output) =&amp;gt;&amp;#123;  var idx = board[i][j].charCodeAt(0) - 97;  // compute the hash index  if(board[i][j] == '#' || !node.next[idx]) return;  // exit condition: visited or not in Trie  node = node.next[idx];  if(node.word != &quot;&quot;)&amp;#123;    // successful condition    output.push(node.word);    node.word = &quot;&quot;;  // this is to remove the duplicates - genius!!  &amp;#125;  // same as before, backtracking  var temp = board[i][j];  board[i][j] = '#';  if(i &amp;gt; 0) dfs(board, i - 1, j ,node, output);   if(j &amp;gt; 0) dfs(board, i, j - 1, node, output);  if(i &amp;lt; board.length - 1) dfs(board, i + 1, j, node, output);   if(j &amp;lt; board[0].length - 1) dfs(board, i, j + 1, node, output);   board[i][j] = temp;&amp;#125;
Runtime: 204 ms
And I beat 100% of js submissions… Compared to previous answer.. it is unbelievable fast…
BTWHave you ever heard about the Word-Clock ? It is a beautiful clock using words represent the time instead of the finger and hands… It is gorgeous!!! Why I mention it ? Don’t you feel it is very similiar to what we did in this post ? Word search?
I will try to make a web version of this beautiful watch by using all these words search algorithms :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript Sorting Algorithm - Radix Sort and Bucket Sort</title><link>http://taoalpha.me/blog/2016/01/19/tech-javascript-sorting-algorithm-radix-sort/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2016-01-19T23:44:09.000Z</pubDate><description>Comparison based sorting algorithmsWe have discussed all popular comparison based sorting algorithms:insertion sort and selection sort, bubble sort and merge sort, Quicksort and Heap Sort.
All these algorithms are great under most of conditions, but their lower bound is O(nlogn), they can not do better.
If for some reason, we want to achieve better than nLogn, we have to find some other ways.
About why the lower bound of all comparison based sorting algorithms is nlogn ? 
Why nlognFor any array with n elements, it has n! possible orders. Since we are using comparison based, suppose we are building a decision tree for all these possible orders, and h is the height of the decision tree and also is how many number of comparisons we need to get down to the leaves. Then we should have:
2^h &amp;gt;= n! which means: the total number of leaves should be enough to cover all possible orders of our array.
Then we would get h &amp;gt;= nlogn for approximation.
Non-Comparison based sorting algorithmsSo if we want to get over the nlogn, we have to ask help from some non-comparison based ways.
If you knew or heard about the sorting algorithms, you should know we have several famous non-comparison based sorting algorithms: counting sort, bucket sort and radix sort.
And lets talk about them today, one by one :)
Counting SortImage this situation: 
You have a deck of playing cards in random order(without jokers), and you want to sort them into the ascending order from A to K. What you gonna do ? Possibly you will count the cards and group them into 13 groups from A to K, and then combine these groups from A to K.
This is a classical counting sort. Once we are sure how many groups we have in our array or we know that the elements in our array are coming from a distribution from a to b. Then we can group them into (b - a + 1) buckets and loop over the array, put elements into proper buckets and then combine them.
Here is the code:1234567891011121314151617181920// counting sortcountingSort(list)&amp;#123;  var bucket = [],idx = 0;  // assign each element to its bucket  for(var i = 0;i&amp;lt;list.length;i++)&amp;#123;    bucket[list[i]] = bucket[list[i]] || 0    bucket[list[i]] ++  &amp;#125;  // now combine all the buckets  for(i = 0; i&amp;lt; bucket.length;i++)&amp;#123;    while(bucket[i] &amp;amp;&amp;amp; bucket[i] &amp;gt; 0)&amp;#123;      // skip empty buckets and loop over every elements in a bucket      list[idx++] = i;      bucket[i] --;    &amp;#125;  &amp;#125;  return list&amp;#125;
Bucket SortThe counting sort is amazing fast : O(n+k), k is the number of buckets we have. But it costs too much space, and if we don’t know the distribution of elements, it maybe have a lot of empty buckets which is a waste of space. 
Bucket sort is an optimization of counting sort, instead of only assigning same elements into one bucket, it will put several elements into one bucket but make sure the it is ascending from the point of buckets which means: for i,j buckets, if i &amp;lt; j, we know any elements in i will smaller than any elements in j.
By doing this, we can divide the entire array into a lot of small subarrays, and now we can just use any comparison based sorting algorithm to sort the small arrays.
Same as counting sort, if we have a wonderful distribution of our elements, it would be O(n + klogb), k is the number of buckets and b is the number of elements in one bucket, to sort the entire array. But the worst case, all elements assigned into the same buckets, it will degrade to the comparison based sorting algorithm we use, but only when you choose a really bad method to group.
1234567891011121314151617181920212223242526272829// bucketSortbucketSort(list,bucketCount)&amp;#123;  // only for numbers  var min = Math.min.apply(Math,list),  // get the min      buckets = [],      bucket_count = bucketCount || 200  // build the bucket and distribute the elements in the list  for(var i = 0;i&amp;lt;list.length;i++)&amp;#123;    // this is a simple hash function that will make sure the basic rule of bucket sort    var newIndex = Math.floor( (list[i] - min) / bucket_count );      buckets[newIndex] = buckets[newIndex] || []    buckets[newIndex].push(list[i])  &amp;#125;  // refill the elements into the list  var idx = 0  for(i = 0;i&amp;lt;buckets.length;i++)&amp;#123;    if(typeof buckets[i] !== &quot;undefined&quot;)&amp;#123;      // select those non-empty buckets      insertionSort(buckets[i]);  // use any sorting algorithm would be fine      // sort the elements in the bucket      for(var j = 0;j&amp;lt;buckets[i].length;j++)&amp;#123;        list[idx++] = buckets[i][j]      &amp;#125;    &amp;#125;  &amp;#125;  return list&amp;#125;
Radix SortCounting sort and Bucket sort are great, but they are too space-consuming and sometimes they are even slower than comparison based ones. Like if we have a really sparse array coming from 0 to n^2, then counting sort would down to O(n^2), and also if we don’t know the distribution of all elements in the array, we might choose an unefficient way to do the hash part for bucket sort, we could still get O(n^2).
Radix is here to help us out of this trouble. The idea of Radix Sort is to do digit by digit sort starting from least significant digit to most significant digit. Radix sort uses counting sort as a subroutine to sort.
For example: we have: [101, 203, 5, 87, 76, 48], using radix sort:

[101,203,5,76,87,48] &amp;lt;- last digits
[101,203,5,48,76,87] &amp;lt;- second last digits
[5,48,76,87,101,203] &amp;lt;- the first digits

Using zero when the number doesn’t have this digit.
Now lets show the code:
1234567891011121314151617181920212223242526272829303132333435363738394041// helper function to get the last nth digit of a numbervar getDigit = function(num,nth)&amp;#123;  // get last nth digit of a number  var ret = 0;  while(nth--)&amp;#123;    ret = num % 10    num = Math.floor((num - ret) / 10)  &amp;#125;  return ret&amp;#125;// radixSortradixSort(list)&amp;#123;  var max = Math.floor(Math.log10(Math.max.apply(Math,list))),        // get the length of digits of the max value in this array      digitBuckets = [],      idx = 0;  for(var i = 0;i&amp;lt;max+1;i++)&amp;#123;    // rebuild the digit buckets according to this digit    digitBuckets = []    for(var j = 0;j&amp;lt;list.length;j++)&amp;#123;      var digit = getDigit(list[j],i+1);      digitBuckets[digit] = digitBuckets[digit] || [];      digitBuckets[digit].push(list[j]);    &amp;#125;    // rebuild the list according to this digit    idx = 0    for(var t = 0; t&amp;lt; digitBuckets.length;t++)&amp;#123;      if(digitBuckets[t] &amp;amp;&amp;amp; digitBuckets[t].length &amp;gt; 0)&amp;#123;        for(j = 0;j&amp;lt;digitBuckets[t].length;j++)&amp;#123;          list[idx++] = digitBuckets[t][j];        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;  return list&amp;#125;
The time complexity for radix sort is : O(d*(n+b)), d is the number of digits the array has, b is the buckets we have, normal it is 10 for base 10 system.
Cool ha :)
BTWSince I combine radix sort with bucket sort and counting sort, so this is the last post about sorting algorithms. But for this serie, I think I will have another post talking about when we should use which algorithm.
See ya.
Oh, and also, I combine all these codes together and create a gist for it: Soting Algorithms in JS.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Quicksort and Heap Sort</title><link>http://taoalpha.me/blog/2016/01/19/tech-sorting-algorithm-in-javascript-median-sort-and-quicksort/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2016-01-19T05:33:27.000Z</pubDate><description>Last time we have finished the four different sorting algorithms including : insertion sort and selection sort, bubble sort and merge sort.
Now let’s continue playing with another one or two.
Median Sort and QuicksortMedian SortSimiliar with merge sort, we still use divide and conquer, the basic approach for many problems, but what if we use some statistical information about the array that need to be sorted? Like the median of the array.
If we know the median, we can sort the array into 2 distinct subarrays of about half the size: left with all elements smaller than the median, and right with all elements bigger or equal to median. And we keep doing this for all subarrays, finally we will get a sorted array.
That gives us the MEDIAN SORT.
QuicksortMedian sort is a nice start, but it still has one problem: how to find the the median of an array? Before we atually put our efforts on solving this problem, we should consider about another problem: how about we use some other attributes instead of median? Our purpose is divide the array into two parts, we don’t need them to be the same size. By thinking this way, we may consider choose any value in the array and use this value as a separator and divide the array into subarrays.
This is quicksort, and the value we choose as a separator is called pivot.
Now let’s show the code:
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var quickSort = (list,left,right) =&amp;gt; &amp;#123;  var idx;  if(list.length &amp;lt;= 1)&amp;#123;    return list  &amp;#125;  // left and right  must be number, default value :  0 and list.length - 1  left = (left^0) !== left ? 0 : left  right = (right^0) !== right ? list.length-1 : right  // divide the array from left to right into two subarrays  // return the index of the separator  idx = partition(list,left,right)   if(left &amp;lt; idx - 1)&amp;#123;    // keep doing quicksort on left subarray until it can not be separated again    quickSort(list,left,idx - 1)  &amp;#125;  if(idx &amp;lt; right)&amp;#123;    // keep doing quicksort on right subarray until it can not be separated again    quickSort(list,idx,right)  &amp;#125;  return list&amp;#125;var partition = (list,begin,end) =&amp;gt; &amp;#123;  var pivot = Math.floor(Math.random()*(tail-head+1)+head), // random pivot index       pivot_value = list[pivot]; // pivot value  // divide into two subarrays using the pivot value with two pointers  while(begin &amp;lt;= end)&amp;#123;        // skip all 'good' ones in right    while(list[end]&amp;gt;pivot_value)&amp;#123;      end --    &amp;#125;    // skip all 'good' ones in left     while(list[begin]&amp;lt;pivot_value)&amp;#123;      begin ++    &amp;#125;    // swap the 'bad' pairs to make them 'good'    if(begin &amp;lt;= end)&amp;#123;      swap(list,begin,end)      begin ++      end --    &amp;#125;  &amp;#125;  // return the separator line  return begin&amp;#125;// swap functionvar swap = (list,first,second) =&amp;gt; &amp;#123;  var temp = list[first]  list[first] = list[second]  list[second] = temp&amp;#125;
With all comments, the code should be easy to understand.
Quicksort is famous and popular for its speed especially after linux start using it as the default sorting algorithm. Normally, if we know nothing about the distribution of our array and speed is the most important reason you consider about, then use quicksort.
In above example, we choose the pivot randomly. Normally, its good enough for using. But actually there are a lot of strategies and researches on how to choose a good pivot. Like always choose the first or last or middle, or use median, median-of-k…etc But normally, using randomly pivot will give you an average O(nlogn). If you want to learn more about these strategies, just google it :)
Heap SortBefore we go to the concept and code, we should know what is a heap:
a heap is a specialized tree-based data structure that satisfies the heap property: If A is a parent node of B then the key of node A is ordered with respect to the key of node B with the same ordering applying across the heap.
In a max heap, the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node. In a min heap, the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node.
WikiPediaHeap (data structure) - wikipedia
Got any inspirations ? Think this way: Max heap =&amp;gt; the head of the heap is the max of the array. This is true for any max heap, so we remove the max and rebuild a heap with rest elements, we get the second largest… Yeah, you got it ?! :)
Now what we need to do is using array represent the heap which is pretty much a array tree:
for any element with index - idx:

left child : idx*2 + 1
right child: idx*2 + 2

Show me the code !!!
123456789101112131415161718192021222324252627282930313233343536373839// heapSort - here we use max heapvar heapSort = (list) =&amp;gt; &amp;#123;  buildHeap(list);  // now we have the max value  for(var i = list.length-1;i&amp;gt;=1;i--)&amp;#123;    // always put max value to the end of the current heap    // so the end of the array will always be sorted and gradually expanded to the entire array    swap(list,0,i);     // since we change the head of the heap    // so we need redo the heap to get the new max of the heap    heapify(list,0,i);   &amp;#125;  return list&amp;#125;buildHeap(list)&amp;#123;  // start from the second last level of the tree which is the parent of the last element  var mid = Math.floor(list.length / 2) - 1;  for(var i = mid;i&amp;gt;=0;i--)&amp;#123;    // make sure every node of the tree is heapify    heapify(list,i,list.length)  &amp;#125;&amp;#125;heapify(list,idx,len)&amp;#123;  // len means the number of elements current heap has  var left = 2*idx + 1,      right = 2*idx + 2,      largest;  // temp value to store the index of largest element of this tree unit  largest = left &amp;lt; len &amp;amp;&amp;amp; list[left] &amp;gt; list[idx] ? left: idx;  largest = right &amp;lt; len &amp;amp;&amp;amp; list[right] &amp;gt; list[len] ? right : largest;  // if we have a new largest, swap it and redo heapify to make sure entire heap is correct  if(largest !== idx)&amp;#123;    swap(list,largest,idx)    heapify(list,largest,len)  &amp;#125;&amp;#125;// swap function - same as before
Heap Sort is really fast, sometimes it is even faster than quicksort since it will guarantee the O(nlogn) even in the worst case. But normally in average case, the quicksort is a little faster.
BTWI believe I still have 2 posts for this serie, one will talk about the radix, and the other will be the counting and bucket sort. See ya.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Insertion Sort and Selection Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-1/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2015-10-29T05:00:00.000Z</pubDate><description>Sorting AlgorithmAs the most important and fundamental algorithm, sorting algorithm is always the best start to learn algorithm.
Among all the different sorting algorithms, we have 10 algorithms which are used a lot in practice, and I will introduce all these ten algorithms one by one. 
Today we will talk about: Selection Sort and Insertion Sort.
Selection SortSelection Sort is one of the most fundamental sort algorithms you would learn from any book about algorithm. The method and theory based on is really easy and clear:

input: a list of numbers need to be sorted
procedures:
create a new list to save the sorted elements
select the minimum element from the input list and push it into the new list, and remove it from the input list
repeat the second step until we don’t have any more elements in input list


output: the list you created to save the sorted elements

Easy, huh ? Let’s calculate the cost: the average time complexity would be n^2/2 which would be O(n^2), since we need check the input list n times with n/2 elements to check every time; and since we are using a new list to save the output, it would be O(n) space.
Can we optimize it ? Yes and no. For time complexity, we can not do any optimization since it is the theory that selection sort is using, we have nothing to do with that. But for space complexity, we can do something.
We can actually do the sort in-place which means we can sort the list within the list and return the same list as the input except it is sorted.
In order to do that, we can change the procedures to:

input: a list of numbers need to be sorted
procedures:
start from the first element, we loop over the list from it to the end of the list and select the minimum element from the input list and swap it with it(start element);
repeat it until we reach the last element of the input list(now the start element and the end element would all be the last element)


output: the input list 

By doing this way, we just need two spaces, one is used to save the index of the minimum element, another is used during the swap to save the one of the value that need to be swapped later. The space complexity would be O(1).
1234567891011121314function selectionSort(list)&amp;#123;    for(var i = 0; i &amp;lt; list.length; i++)&amp;#123;      var min = i      for(var j = i+1;j&amp;lt;list.length; j++)&amp;#123;        if(list[min]&amp;gt;list[j])&amp;#123;          min = j        &amp;#125;      &amp;#125;      var temp = list[i]      list[i] = list[min]      list[min] = temp    &amp;#125;    return list  &amp;#125;
Selection Sort is easy but not efficient, since it always costs O(n^2) even your input list is sorted when you pass it in.
Insertion SortNow we come to insertion sort which would a little more efficient than selection sort.
The theory is: consider the left part of the input list as sorted, and insert the new element into the proper position, since if one element always means it is sorted, so we always can do that by starting from the second element.
The procedures:

start from the second element(if you don’t have second element, you are done);
compare every element in the left(sorted part), if it is greater than your start element, shift it to the right by 1, if it is less than your start element, insert your start element before it;
repeat until the end of the list;

Time Complexity: O(n) in the best case(the list is sorted already), O(n^2) in the worst case, on average, it would be similiar to selection sort with O(n^2).
Space Complexity: O(1)
Lets implement it into real code:
1234567891011121314function insertionSort(list)&amp;#123;  for(var i = 1; i &amp;lt; list.length;i++)&amp;#123;    var temp = list[i]    var j = i    while(j&amp;gt;0 &amp;amp;&amp;amp; list[j-1]&amp;gt;temp)&amp;#123;      list[j] = list[j-1]      j--    &amp;#125;    list[j] = temp    // use shift instead of swap can reduce the cost of writing -- nearly 50%    // if you use swap, it will slower than selectionSort  &amp;#125;  return list&amp;#125;
Some people may be used to achieve insertion sort by using the swap too. You can, you just need compare and swap it with previous one until it reaches the right position. But the cost would be high since you will double your writes with swap.

I actually calculate the time cost in javascript, most of time, if you use swap, your insertion sort would be slower than selection sort.

Special NoteIn general, insertion sort would be faster than selection sort if you implement it in right way. But in some special cases, you may find selection sort is faster.
The different between selection sort and insertion sort:

selection sort reads the list a lot(n  (n+1) / 2, n is the length of the list) but only writes into the list a few times(= 2  (the length of your list));
insertion sort reads the list a lot too, but fewer than the selection sort(the worst case would be same with selection, best case would be equal to the length of the list), and meantime, it will write into the list much more times than selection sort(nearly the same with reading times);

So if it costs much more on reading instead of writing, you may consider choosing selection sort instead of insertion sort.
SummaryThat’s all I think you should know about selection sort and insertion sort. Next post I will discuss about bubble sort and merge sort with you. See ya!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Bubble Sort and Merge Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-2/</link><category>tech</category><tag>Algorithm,JS,Sort</tag><pubDate>2015-10-29T08:00:00.000Z</pubDate><description>IntroductionBubble sort is really cool but not so useful, it seems that you will never use it… But merge sort is really cool since it is really fast.
Bubble SortSo what is bubble sort, according to wikipedia:

Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. 

The whole process of sorting is like the bigger element “bubble” to the end of the list.

Input: A list of numbers with random order
Procedures:
Start from the head of the list, and compare every two adjacent numbers and swap them if they are in wrong order;
Record whether you did any swaps or not, if no, your list has been sorted, otherwise, you need to step 1 again;


Output: A sorted list

If you like, you can do a small optimization to the procedures above: since every iteration we will make sure the bigger element will “bubble” to the end of the list, so everytime we don’t need to check the last elements(they are already in ordered), and we will reduce the length for each iteration.
Here is a nice gif from wikipedia: 
The time complexity for bubble sort would be : O(n^2) for worst case, O(n) for best case, and O(n^2) on average.
The space complexity for bubble sort would be O(1) since we only need one space used to do the swap.
Now lets do the code:
1234567891011121314151617181920// bubbleSortfunction bubbleSort(list)&amp;#123;  var swapped  var len = list.length  do&amp;#123;    swapped = false    for(var j = 0;j&amp;lt; len-1;j++)&amp;#123;      reads += 2      if(list[j]&amp;gt;list[j+1])&amp;#123;        this.swap(list,j,j+1)        swapped = true        writes += 2      &amp;#125;    &amp;#125;    len = len - 1    // since everytime we will move the largest element to the end of the list, we can reduce the number of iteration without considering the last element every iteration  &amp;#125;while(swapped)  return list&amp;#125;
Merge SortNow we met all three different kinds of sorting, all of them have a O(n^2) of time complexity on average.
Lets do something faster: Merge Sort.
Imagine you separate your list into several really small lists with only one element or zero element in each of them. Then you merge every two small lists into one sorted list, and keep doing it repeatly.(it’s easy because you are merging two sorted lists)
The whole procedures will be:

Split the list recursively;
Merge the small lists until you merge them all;

Since we always split by half, the number of small lists we will have would be log(n), and the total cost would be close to (n / 2 * log(n)) on average(since we have at least 1 element list to merge with zero one, at most n/2 elements list to merge with n/2 elements). So the time complexity would be O(nlog(n)) all the time, and the space complexity would be O(n) since we will save origin input list with n small lists.
1234567891011121314151617181920// mergeSortfunction mergeSort(list)&amp;#123;  if(list.length &amp;lt;= 1) return list  var mid = Math.floor(list.length / 2)  return merge(mergeSort(list.slice(0,mid)),mergeSort(list.slice(mid)))&amp;#125;function merge(left,right)&amp;#123;  var nl = []  var il = 0, ir = 0  while(il&amp;lt;left.length &amp;amp;&amp;amp; ir&amp;lt;right.length)&amp;#123;    if(left[il] &amp;lt; right[ir])&amp;#123;      nl.push(left[il++])    &amp;#125;else&amp;#123;      nl.push(right[ir++])    &amp;#125;    // don't use shift because shift will actually cause a lot I/Os   &amp;#125;  nl = nl.concat(left.slice(il)).concat(right.slice(ir))  return nl&amp;#125;
SummaryMerge sort is kind useful, and if we don’t have quick sort which I will talk about next post, it would be a really good choice to do sorting. And even we have quick sort, merge sort still exists in many languages as part of their default sorting algorithm.
And also there are several optimizations for merge sort, if you are interested in, you can search it on google.
That’s all for today. Good night!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Substring Questions 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-substring-questions-1/</link><category>OJ</category><tag>LeetCode,Substring</tag><pubDate>2016-01-16T06:52:31.000Z</pubDate><description>3. Longest Substring Without Repeating CharactersQuestionGiven a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.
LeetCode3. Longest Substring Without Repeating Characters
Tags: Medium, String, Two Pointers, Hash Table
AnswersHash TableAt first, my idea is use a hashmap as a view window to tract all the letters of current substring, and everytime we found the repeated one, we just move the loop pointer to the last position of this repeated character, and continue looping to the end. But apparently it will cost much more than O(n) for the average case. So then I thought I don’t need the move the loop pointer back, just need a new pointer to indicate the start of the substring, and if I do that, I couldn’t empty the view window which is the hashmap since I will lose tract of the elements between the start and i, so I keep all elements in the hashmap, just make sure every valid repeated character is appeared after the current start pointer.
Here is the code:
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  if(s.length &amp;lt;=0)&amp;#123;return 0&amp;#125;  var view = &amp;#123;&amp;#125;, // store the current substring      max = 0, // store the max length      start = 0 // store the start of the current substring  for(var i = 0;i&amp;lt;s.length;i++)&amp;#123;    if(view[s[i]] &amp;amp;&amp;amp; view[s[i]] &amp;gt; start)&amp;#123;      max = Math.max(max,i-start)      // now we have a repeated element appeared in current substring      start = view[s[i]]    &amp;#125;    view[s[i]] = i+1  &amp;#125;  // in case no repeated element in this string  max = Math.max(max,i-start)  return max&amp;#125;;
Runtime: 376 ms
DPThis method is borrow from the discussion shortest O(n) DP solution with explanations. More concise!
12345678910111213141516171819202122232425262728293031323334353637/** * Solution (DP, O(n)): *  * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &amp;lt;character, index&amp;gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap *    we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k *    let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update *    entry in hashmap to mark the latest occurency of s[i+1]. *  * Since we scan the string for only once, and the 'm' will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. *//** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;number&amp;#125; */var lengthOfLongestSubstring = function(s) &amp;#123;  var charIndex = &amp;#123;&amp;#125;  var longest = 0, m = 0;  for (var i = 0; i &amp;lt; s.length; i++) &amp;#123;    m = Math.max((typeof charIndex[s[i]] === &quot;undefined&quot; ? -1:charIndex[s[i]]) + 1, m);    // automatically takes care of -1 case    charIndex[s[i]] = i;    longest = Math.max(longest, i - m + 1);  &amp;#125;  return longest;&amp;#125;
Runtime: 376
5. Longest Palindromic SubstringQuestionGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
LeetCode5. Longest Palindromic Substring
Tags: Medium, String
Answerstwo pointersWe need to take advantage of the features of the palindrom: xxx|xxx which is start from the separator, it is symetric.
12345678910111213141516171819202122232425262728/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s  var start = 0,end = 1;  for(var i = 0;i&amp;lt;s.length;)&amp;#123;    if(s.length - i &amp;lt;= (end-start+1)/2) break; // if the number of elements left is less than half of length of current longest palindrome, then we can break safely    var left = i, right = i; // left is from separator to left; vice versa for right    // skil the duplicate number, set all duplicate numbers as the separator of the palindrom since duplicate numbers definitely are palindrom     while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; s[right] == s[right+1]) right ++ ;    // update the i to the right next to right, no need to loop the duplicate number    i = right + 1    // now expand the left and right, try to enlarge the palindrom    while(right &amp;lt; s.length - 1 &amp;amp;&amp;amp; left &amp;gt;0 &amp;amp;&amp;amp; s[left-1] == s[right+1])&amp;#123;      // be careful about the condition in there: use &amp;lt; and &amp;gt; because maybe have 'bbb', so the s[left-1] and s[right+1] both are undefined, and they are equal...      left --      right ++    &amp;#125;    // update the longest if it is    if((right - left +1) &amp;gt; (end - start))&amp;#123;      start = left      end = right + 1    &amp;#125;  &amp;#125;  return s.slice(start,end)&amp;#125;;
Runtime: 164 ms
Brute Force CheckBasic idea is loop over entire string, and everytime we loop to a new character, we check whether it would produce new palindrome of (current length + 1) or (current length + 2). From this post
123456789101112131415161718192021222324252627/** * @param &amp;#123;string&amp;#125; s * @return &amp;#123;string&amp;#125; */var longestPalindrome = function(s) &amp;#123;  if(s.length &amp;lt; 2) return s;  var subs = '', currentLength = 1;  for(var i = 1;i&amp;lt;s.length;i++)&amp;#123;    if(isPalindrome(s,i-currentLength-1,i))&amp;#123;      //       subs = s.slice(i-currentLength-1,i+1)      currentLength += 2    &amp;#125;else if(isPalindrome(s,i-currentLength,i))&amp;#123;      subs = s.slice(i-currentLength,i+1)      currentLength += 1    &amp;#125;  &amp;#125;  return subs&amp;#125;var isPalindrome(s,begin,end) =&amp;gt; &amp;#123;  if(begin&amp;lt;0) return false;  while(begin &amp;lt; end)&amp;#123;    if(s[begin++] !== s[end--]) return false;  &amp;#125;  return true&amp;#125;
Runtime: 188 ms
And the detail explanations:

Example: “xxxbcbxxxxxa”, (x is random character, not all x are equal) now we are dealing with the last character ‘a’. The current longest palindrome is “bcb” with length 3.

check “xxxxa” so if it is palindrome we could get a new palindrome of length 5.
check “xxxa” so if it is palindrome we could get a new palindrome of length 4.
do NOT check “xxa” or any shorter string since the length of the new string is no bigger than current longest length.
do NOT check “xxxxxa” or any longer string because if “xxxxxa” is palindrome then “xxxx” got  from cutting off the head and tail is also palindrom. It has length &amp;gt; 3 which is impossible.’


Really smart!!!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Numbers 1</title><link>http://taoalpha.me/blog/2016/01/16/oj-oj-leetcode-numbers-1/</link><category>OJ</category><tag>LeetCode,Numbers</tag><pubDate>2016-01-17T02:22:20.000Z</pubDate><description>2. Add Two NumbersQuestionYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)Output: 7 -&amp;gt; 0 -&amp;gt; 8
LeetCode2. Add Two Numbers
Tags: Medium, Linked List, Math
AnswersCommon parts firstThe idea is to add the common parts first and store the carry number produced every round a addition.
Then deal with the remain, just be careful about the carry.
Then if we still have a carry number, create a new node and add it to our result.
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; l1 * @param &amp;#123;ListNode&amp;#125; l2 * @return &amp;#123;ListNode&amp;#125; */var addTwoNumbers = function(l1, l2) &amp;#123;  var head = new ListNode(-1),      cur = head,      carry = 0;  while(l1 &amp;amp;&amp;amp; l2)&amp;#123;    var nodeVal = l1.val + l2.val + carry,node = new ListNode(0);    if(nodeVal &amp;gt;= 10)&amp;#123;      carry = 1      node.val = nodeVal % 10    &amp;#125;else&amp;#123;      carry = 0      node.val = nodeVal    &amp;#125;    cur.next = node    cur = node    l1 = l1.next    l2 = l2.next  &amp;#125;  // deal with the remain  var remain = l1 || l2  while(remain)&amp;#123;    if(remain.val + carry &amp;gt;= 10)&amp;#123;      remain.val = (remain.val + carry) % 10      carry = 1    &amp;#125;else&amp;#123;      remain.val += carry      carry = 0    &amp;#125;    cur.next = remain    cur = cur.next    remain = remain.next  &amp;#125;  // if no remain  if(carry&amp;gt;0)&amp;#123;      var temp = new ListNode(carry)      cur.next = temp  &amp;#125;  return head.next&amp;#125;;
Runtime : 304ms
All in one loopActually you can find that the main logic of our two while loops are the same, we can combine them:
123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; l1 * @param &amp;#123;ListNode&amp;#125; l2 * @return &amp;#123;ListNode&amp;#125; */var addTwoNumbers = function(l1, l2) &amp;#123;  var head = new ListNode(-1),      cur = head,      carry = 0;  while(l1 || l2)&amp;#123;    var l1val = (l1 &amp;amp;&amp;amp; l1.val) || 0    var l2val = (l2 &amp;amp;&amp;amp; l2.val) || 0    var nodeVal = l1val + l2val + carry,node = new ListNode(0);    if(nodeVal &amp;gt;= 10)&amp;#123;      carry = 1      node.val = nodeVal % 10    &amp;#125;else&amp;#123;      carry = 0      node.val = nodeVal    &amp;#125;    cur.next = node    cur = node    l1 = (l1 &amp;amp;&amp;amp; l1.next) || null    l2 = (l2 &amp;amp;&amp;amp; l2.next) || null  &amp;#125;  // if no remain  if(carry&amp;gt;0)&amp;#123;      var temp = new ListNode(carry)      cur.next = temp  &amp;#125;  return head.next&amp;#125;;
Runtime: 320ms
The two methods should be at the same time complexity.
9. Palindrome NumberQuestionDetermine whether an integer is a palindrome. Do this without extra space.
LeetCode9. Palindrome Number
Tags: Easy,Math
AnswersCan not understand what without extra space means… but we can figure out some O(1) space methods…
Head and Tail Comparator1234567891011121314/** * @param &amp;#123;number&amp;#125; x * @return &amp;#123;boolean&amp;#125; */var isPalindrome = function(x) &amp;#123;  if(x&amp;lt;0)&amp;#123;return false&amp;#125;  var numDigits = Math.floor(Math.log10(x)) + 1,i = 1;  while(i&amp;lt;=numDigits/2)&amp;#123;    if( (Math.floor(x % Math.pow(10,numDigits - i+1) / Math.pow(10,numDigits-i))) !=         (Math.floor(x % Math.pow(10,i) / Math.pow(10,i-1))) )&amp;#123; return false &amp;#125;    i += 1  &amp;#125;  return true&amp;#125;;
Runtime: 768 ms
MathIt is not a pure math problem, but if you know math well, you can figure out some way like this:

reduce the x into half
store the reduced half into another number
compair the two

12345678910111213/** * @param &amp;#123;number&amp;#125; x * @return &amp;#123;boolean&amp;#125; */var isPalindrome = function(x) &amp;#123;  if(x&amp;lt;0 || (x !== 0 &amp;amp;&amp;amp; x % 10 == 0)) return false;  var rev = 0; // reverse  while(x&amp;gt;rev)&amp;#123;    rev = rev * 10 + x % 10    x = Math.floor(x / 10)  &amp;#125;  return (x == rev || x == Math.floor(rev/10))&amp;#125;
Runtime: 684 ms
17. Letter Combinations of a Phone NumberQuestionGiven a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below.Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want.
LeetCode17. Letter Combinations of a Phone Number
Tags: Medium, String, Backtracking
AnswersDFS - recursion123456789101112131415161718192021222324/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  // mapper that store all number-letters  var output = []  helper(digits,[],output,mapper)  return output&amp;#125;var helper = (digits,result,output,mapper) =&amp;gt; &amp;#123;  if(digits.length == 0)&amp;#123;    output.push(result.join(''));    return  &amp;#125;  for(var i = 0;i&amp;lt;mapper[digits[0]].length;i++)&amp;#123;    result.push(mapper[digits[0]][i])    helper(digits.slice(1),result,output,mapper)    result.pop()  &amp;#125;&amp;#125;
Runtime: 152 ms
DFS - iteratorSame as before, just use iterator instead of recursion
1234567891011121314151617181920/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  var output = [&quot;&quot;]  for(var i = 0;i&amp;lt;digits.length;i++)&amp;#123;    var x = digits[i]    var temp = []    for(var j = 0;j&amp;lt;mapper[x].length;j++)&amp;#123;      for(var t = 0;t&amp;lt;output.length;t++)&amp;#123;        temp.push(output[t]+mapper[x][j])      &amp;#125;    &amp;#125;    output = temp  &amp;#125;  return output&amp;#125;
Runtime: 156 ms
That’s weird… iterator should be faster than recursion… maybe just so few test cases can not test the real difference between these two …
BFS - iteratorIf we consider previous one as a DFS method, then we can use BFS solve it too. Basic idea is the length of each the combination in our final output should be equal to the length of digits. And for every iteration, we use a new digit, and we also need to add every letters this digit represents to every existed combinations we have.
For example: ‘23’
initial =&amp;gt; [‘’]‘2’ =&amp;gt; [‘a’,’b’,’c’]// now add each element of ‘def’ to each of these three string‘3’ =&amp;gt; [‘cd’,’ce’,’cf’,’bd’,’be’,’bf’,’ad’,’ae’,’af’]
123456789101112131415161718192021/** * @param &amp;#123;string&amp;#125; digits * @return &amp;#123;string[]&amp;#125; */var letterCombinations = function(digits) &amp;#123;  if(digits.length&amp;lt;=0)&amp;#123;return []&amp;#125;  var mapper = [0,1,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;];  var output = [&quot;&quot;]  for(var i = 0;i&amp;lt;digits.length;i++)&amp;#123;    var x = digits[i]    while(output[output.length-1].length == i)&amp;#123;      // the length of every combination in the output should be equal to the the number of digits we used      var t = output.pop()      for(var j = 0;j&amp;lt;mapper[x].length;j++)&amp;#123;        output.unshift(t+mapper[x][j])        // need to use unshift since we need add the new letter to every existed element in the output      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
Runtime: 140 ms
That’s it ^_^
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Blur on Background</title><link>http://taoalpha.me/blog/2015/12/31/tech-blur-on-background/</link><category>tech</category><tag>Blur,CSS3</tag><pubDate>2015-12-31T08:09:10.000Z</pubDate><description>Today I finally made my first angularJS app which is a simple todo app connected with my First nodejs cli tool: baby. They share the same data set, so you can think it as the UI for baby todo part (I will build the UI for other nice features, one by one).
I really like the interface of the Papaly, especially the speed dial dashboard !! So I also use a large image and the crystal blur block on my design, here I just want to share something with you :)
BlurBlur is quite popular in Web Design, you can see them all the time. But how we do that from the point of coding part ? Before CSS3 introduced the filter, people just modify the images manually and make them blur before actually use them in the design, and now we have CSS3, we can just use filter.
We all know make a image blur is pretty simple, but how we make part of image blur, and even more, how we make part of image blur be dynamic ? This is what I gonna talk about today :)
Without CSS3Let’s do it old fashion first. You want create a box within which all background image should be blur, and also the box may move to any place or even can be moved by users. How to do that? Quite simple, we can use two images, one is normal, the other is blur one. 
Then what you should know is background-attachment which adds the magic.
12345678910111213141516171819202122232425262728293031323334353637383940/* background-attachment can specify the position of the background image * fixed : the background is fixed with regard to the viewport, so it won't move with the element * background-attachment: fixed; * background-size:100%; * keep size 100% to fit the viewprot */html,body&amp;#123;  width:100%;  height:100%;  margin:0px;&amp;#125;.imgBlur&amp;#123;  width:100%;  height:100%;  margin:auto;  background-image:url(&quot;http://www166.lunapic.com/editor/premade/o-blur.gif&quot;);// image without blur  background-size:100%;&amp;#125;div.blurBox&amp;#123;  width:50%;  margin:auto;  height:200px;  color:white;  padding:30px;  text-align:center;  display:table;&amp;#125;div.blurBox.withoutcss3&amp;#123;  background-attachment:fixed;  background-size:100%;  background-image:url(http://www166.lunapic.com/editor/premade/blur.gif);// image with blur   display:none;&amp;#125;.blurBox span&amp;#123;  display:table-cell;  vertical-align:middle;&amp;#125;
With CSS3With CSS3, we don’t need the second image, we can just use blur.
123456789101112131415161718192021/* z-index is to make sure the content of the box won't be blur */div.blurBox.withcss3&amp;#123;  z-index:1;&amp;#125;div.blurBox.withcss3:before&amp;#123;  width:100%;  display:block;  content:&quot; &quot;;  height:100%;  background-image:url(http://www166.lunapic.com/editor/premade/o-blur.gif);  // now we don't need blur image  background-attachment:fixed;  // still need this since we need use the blur on the image  position: absolute;  background-size:100%;   -webkit-filter: blur(3px);  filter:blur(3px);  z-index:-1;&amp;#125;
Here is the demo I made with codepen:
See the Pen LGbajd by taoalpha (@taoalpha) on CodePen.


Advance SkillsPretty cool ha! Combine with before and after and other cool stuffs,  you can achieve a lot amazing effects, even this one : Depth of field effect with SVG filters
See the Pen Depth of field effect with SVG filters by Vaughan Curd (@vcurd) on CodePen.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Add a reading progressbar to your blog</title><link>http://taoalpha.me/blog/2016/01/16/tech-add-a-reading-progressbar-to-your-blog/</link><category>tech</category><tag>JS,progressbar</tag><pubDate>2016-01-16T21:37:42.000Z</pubDate><description>Yesterday, I added airbnb blog to my subscriptions, and found an interesting feature on this blog: when you scroll down, there will be a progressbar on the top of the page showing the progress of your reading on this post. So I just added it to my blog :)
Actually the logic is pretty simple, you calculate the distance you have scroll down, and then divided by the height of your post area, fixed with some margins and offset, added some styles and html, you will get your own reading progressbar :) I don’t know whether airbnb using this method or not since I didn’t look their code…
1234567891011121314151617181920212223// with jQuery( () =&amp;gt; &amp;#123;  $(window).scroll( () =&amp;gt; &amp;#123;    // listen to the scroll event    if(window.scrollY &amp;gt; 220)&amp;#123;      // the distance between the top of the document and start of your post area, only show when you actually start reading :)      var percentage = Math.ceil( ( (window.scrollY - 200 + $(window).height()) / $('section.entry').height() )*100 )      // calculate the percentage of reading, here I minus the distance at the top but add the height of your screen to make sure it will hit 100 when scroll down to the bottom      if(percentage&amp;lt;=100)&amp;#123;        // show and update the progressbar        $('div#progressbar').fadeIn(300).find('span.text').text(percentage+&quot;% READ&quot;)        $('div#progressbar').fadeIn(300).find('span.bg').css(&amp;#123;width:percentage+&quot;%&quot;&amp;#125;)      &amp;#125;      // hide it when read 100%      if(percentage &amp;gt;= 100)&amp;#123;        $('div#progressbar').fadeOut(300)      &amp;#125;    &amp;#125;else&amp;#123;      // hide if you scroll up to the top      $('div#progressbar').fadeOut(300)    &amp;#125;  &amp;#125;)&amp;#125;)()
And then you just need a html snippet like this on your post page and add your own styles for them:
1div#progressbar&amp;#10;  span.bg&amp;#10;  span.text
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode NSum Problem</title><link>http://taoalpha.me/blog/2016/01/13/oj-oj-leetcode-nsum/</link><category>OJ</category><tag>HashTable,LeetCode</tag><pubDate>2016-01-14T01:19:20.000Z</pubDate><description>1. Two SumQuestionGiven an array of integers, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution.
Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2
LeetCode1. 2Sum
Tags: Array, Hash Table
AnswersIndexOfBefore we think about hashtable, the more strightforward idea is that we subtract the current number from the target and then check whether the result is in the rest of the list or not.
12345678910111213/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var secondIndexOffset = nums.slice(i+1,nums.length).indexOf(target - nums[i])    if(secondIndexOffset&amp;gt;-1)&amp;#123;      return [i+1,i+secondIndexOffset+2]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 456 ms
Or we use while to save some time:
123456789101112131415/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        return [i+1,j+1]      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 336 ms
hashtableThe previous answer can solve the problem but it is too slow, it is O(n^2) way too slow. We need to speed it up.
Since we can assume each input would have exactly one solution which means that there should not have duplicate number in the nums or the duplicate numbers wouldn’t affect the result, so we can use a hashtable store all the numbers and the index of them to speed up the process.
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var mapper = &amp;#123;&amp;#125;  for(var i =0;i&amp;lt;nums.length;i++)&amp;#123;    mapper[nums[i]] = i+1  &amp;#125;  for(i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var remain = target - nums[i]    if(mapper[remain] &amp;amp;&amp;amp; mapper[remain] -1 !== i)&amp;#123;      return [i+1,mapper[remain]]    &amp;#125;  &amp;#125;&amp;#125;;
Runtime: 140 ms
Personal Follow Upif we can not assume that each input would have exactly one solution, then how to solve it?
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = []  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var j = i+1    while(j&amp;lt;nums.length)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(i,j)      &amp;#125;    &amp;#125;  &amp;#125;  return output&amp;#125;
If we want get all possible and no duplicate combinations(using values instead of indices) of two sum:
1234567891011121314151617181920212223242526272829/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var i = 0, j = nums.length-1  var output = []  nums.sort( (a,b)=&amp;gt; a - b)  while(i&amp;lt;j)&amp;#123;    if(nums[i]+nums[j] == target)&amp;#123;      output.push([nums[i],nums[j]])      i ++      j --      // remove the duplicate values      while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;        i++      &amp;#125;      while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;        j--      &amp;#125;    &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;      j --     &amp;#125;else&amp;#123;      i ++    &amp;#125;  &amp;#125;  return output&amp;#125;
Use hash table:
12345678910111213141516171819202122232425262728293031/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[]&amp;#125; */var twoSum = function(nums, target) &amp;#123;  var output = [],nnums = [],amapper = &amp;#123;&amp;#125;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    if(!amapper[nums[i]])&amp;#123;      nnums.push(nums[i])      amapper[nums[i]] = 1    &amp;#125;else&amp;#123;      amapper[nums[i]] ++    &amp;#125;  &amp;#125;  // build the hash of all elements and remove the duplicates  // store all possible combinations  for(var i = 0;i&amp;lt;nnums.length;i++)&amp;#123;    for(var j = i+1;j&amp;lt;nnums.length;j++)&amp;#123;      var sum = nnums[i]+nnums[j]      if(sum == target)&amp;#123;        output.push([nnums[i],nnums[j]])      &amp;#125;    &amp;#125;  &amp;#125;  // consider about the special case that two sub elements are same  if(amapper[target/2] &amp;gt;=2)&amp;#123;output.push([target/2,target/2])&amp;#125;  return output&amp;#125;
Compared with the two pointers method, this one would be a little slower - test with replacing this one with previous one in the findNSum function below.
18. 4SumQuestionGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d). The solution set must not contain duplicate quadruplets.
For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
LeetCode18. 4Sum
Tags: Array, Hash Table, Two Pointers, Medium
Answersreduce to 2Sum123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param &amp;#123;number[]&amp;#125; nums * @param &amp;#123;number&amp;#125; target * @return &amp;#123;number[][]&amp;#125; */var fourSum = function(nums, target) &amp;#123;  // sort  nums.sort( (a,b)=&amp;gt; a - b)  var output = []  findNSum(nums,target,4,[],output)  return output&amp;#125;;var findNSum = (nums,target,N,result,output)=&amp;gt;&amp;#123;  // base exit case  if(nums.length &amp;lt; N || N &amp;lt; 2) return  // 2Sum like before but don't need to sort the list again  if(N==2)&amp;#123;    // can replace below with any one of these 2Sum ways    var i = 0, j = nums.length-1    while(i&amp;lt;j)&amp;#123;      if(nums[i]+nums[j] == target)&amp;#123;        output.push(result.concat([nums[i],nums[j]]))        i ++        j --        // remove the duplicate values        while(i&amp;lt;j &amp;amp;&amp;amp; nums[i] == nums[i-1])&amp;#123;          i++        &amp;#125;        while(i&amp;lt;j &amp;amp;&amp;amp; nums[j] == nums[j+1])&amp;#123;          j--        &amp;#125;      &amp;#125;else if(nums[i]+nums[j] &amp;gt; target)&amp;#123;        j --       &amp;#125;else&amp;#123;        i ++      &amp;#125;    &amp;#125;  &amp;#125;else&amp;#123;    for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;      if(i==0 || (i&amp;gt;0 &amp;amp;&amp;amp; nums[i-1] != nums[i]))&amp;#123;        // recursively call findNSum        findNSum(nums.slice(i+1,nums.length), target-nums[i],N-1,result.concat([nums[i]]),output)      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;
Runtime: 328 ms
Since the nums is sorted, we can use pruning during the for loop to save a lot of time:
12// add this within the for loop before the recursionif(nums[i]*N &amp;gt; target || nums[nums.length-1]*N &amp;lt; target) break
Runtime: 228
Using Hash TableThink about using the hashtable store all value of two pairs, and then treat it like a twoSum problem, but will use a lot space.
SummaryAll NSum problems can be solved by the same way.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Dynamic scheduling crawler for FeedPusher</title><link>http://taoalpha.me/blog/2016/01/12/tech-dynamic-scheduling-crawler-for-feedpusher/</link><category>tech</category><tag>Crawler,FeedPusher,NodeJS</tag><pubDate>2016-01-12T08:12:44.000Z</pubDate><description>As I promised, I have been working on refactoring the feedpusher with pure JS/nodeJS from last week. Now I have set up the basic database struture and spider which has already been running for one week with 80 sites and 8k feeds stored into my mongodb on raspberry pi.
Today, I jsut set up a new process to crawl the updates which I called dynamic scheduling which means now the spider can decide whether this site needs to be recrawled this time or not by itself. Why? Most important reason is that as the number of sites goes bigger, the time it crawles all sites is longer, and also crawl every site everytime is not a good way.
Now I will explain how I do that with nodeJS.
TheoryOur purpose is let the spider decide when to crawl a specific website/rss link, or in another word, everytime the spider runs, it needs to decide which website should be recrawled this time.
What data I haveNow I have and I can store some data into my database that may be good for this purpose, but we want to use as few as possible, so I decide to use these two attributes:

lastCrawled: time I last crawled this website;
updateDuration: the duration between two continuous crawl of this site;

Dynamic SchedulingThe lastCrawled is pretty simple and we don’t have a lot things can do with it. But the updateDuration is the core of the dynamic scheduling, since we can increase it and tell the spider that this site needs a longer duration before next crawling and vice versa.
So the basic idea is:
The larger the updateDuration is, the longer the website get recrawled.
Rules
When to crawl: if current time minus the time lastCrawled is longer than the updateDuration, then the website needs to be recrawled;
Motivate: if this round of crawling got any updates(new feeds) of this website, then we decrease the updateDuration of this website which is like motivating this website because of the updates;
Penalize: if this round of crawling got no updates(new feeds) of this website, then we increase the updateDuration of this website which is like penalizing this website because of the later update than expected;

ResultsBased on these simple rules, the updateDuration of one site would be dynamic changing and will reflect the frequency of a website updates in some level.
CodingThe coding part is pretty stright forward, but since the spider need get a lot of data from the mongodb, so you might need a lot promises to make sure the order of different processes is under your control.
I will put the Pseudocode here, if you are interested in the real code, you can check my feedpusher code refactoring repo :)
PseudocodeThis is not a real pseudocode… but I believe you can bare with that :)
1234567891011121314151617181920212223242526272829303132333435363738394041424344// feed is the object of my core class I used for this spiderfeed.db.open((err, db) =&amp;gt;&amp;#123;  // connect with database  var allSites = [] // store all sites we crawled this time in order to update the lastCrawled and updateDuration later  // find all sites from the database  feed.findAllSites().then((data) =&amp;gt; &amp;#123;    var curTime = moment()    // Need use promise to make sure all finished before you update the lastCrawled and updateDuration    return Promise.all(data.filter( (v) =&amp;gt; &amp;#123;      // filter all sites that the time from lastCrawled has passed the updateDuration      return (((curTime - moment(v.lastCrawled)) / 3600 / 1000) &amp;gt; v.updateDuration)    &amp;#125;)    .map( (v) =&amp;gt;&amp;#123;      // crawl and store each feedUrl which is the link of the rss      allSites.push(v.feedUrl)      return feed.crawler(v.feedUrl)    &amp;#125;) )  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    // update the lastFCrawled for all sites    return feed.updateCrawled(allSites)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at crawler&quot;)    console.log(reason)    db.close()  &amp;#125;)  .then( ()=&amp;gt;&amp;#123;    console.log(feed.stats)    feed.updateDuration(allSites).then( () =&amp;gt; &amp;#123;      // Now update the updateDuration for all sites      db.close()    &amp;#125;,(reason)=&amp;gt;&amp;#123;      console.log(&quot;Broken at updatedDuration&quot;)      console.log(reason)      db.close()    &amp;#125;)  &amp;#125;,(reason)=&amp;gt;&amp;#123;    console.log(&quot;Broken at updatedCrawled&quot;)    console.log(reason)    db.close()  &amp;#125;)&amp;#125;)
Yup! currently it works pretty good! :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>ES6 Quiz With Answer</title><link>http://taoalpha.me/blog/2016/01/11/tech-es6-quiz-with-answer/</link><category>tech</category><tag>ES6,JS,Quiz</tag><pubDate>2016-01-11T08:15:24.000Z</pubDate><description>Origin Post
@kangax’s ES6 quiz, explained@kangax created a new interesting quiz, this time devoted to ES6 (aka ES2015). I found this quiz very interesting and quite hard (made myself 3 mistakes on first pass).
Here we go with the explanations:
Question 1:123456(function(x, f = () =&amp;gt; x) &amp;#123;  var x;  var y = x;  x = 2;  return [x, y, f()];&amp;#125;)(1)

[2, 1, 1]
[2, undefined, 1]
[2, 1, 2]
[2, undefined, 2]

The most complex question for me in this quiz. I didn’t get it right initially until read the spec and clarified with @kangax. First I answered [2, undefined, 1], which is “almost correct”, except one subtle thing. The correct answer here is the first one, [2, 1, 1], and let’s see why.
As we know, parameters create extra scope in case of using default values.
Parameter f is always the function (the default value, since it’s not passed), and it captures x exactly from the parameters scope, that is 1.
Local variable x shadows the parameter with the same name, var x;. It’s hoisted, and is assigned default value… undefined? Yes, usually it would be assigned value undefined, but not in this case, and this is the subtle thing we mentioned. If there is a parameter with the same name, then the local binding is initialized not with undefined, but with the value (including default) of that parameter, that is 1.
So the variable y gets the value 1 as well, var y = x;.
Next assignment to local variable x happens, x = 2, and it gets value 2.
By the time of the return, we have x is 2, y is 1, and f() is also 1. It’s also a tricky part: since f was created in the scope of parameters, its x refers to the parameter x, which is still 1.
And the final return value is: [2, 1, 1].

Question 2:123456(function() &amp;#123;  return [    (() =&amp;gt; this.x).bind(&amp;#123; x: 'inner' &amp;#125;)(),    (() =&amp;gt; this.x)()  ]&amp;#125;).call(&amp;#123; x: 'outer' &amp;#125;);

[‘inner’, ‘outer’]
[‘outer’, ‘outer’]
[undefined, undefined]
Error

Arrow functions have lexical this value. This means, they inherit this value from the context they are defined. And later it stays unchangeable, even if explicitly bound or called in a different context.
In this case both arrow functions are created within the context of {x: &amp;#39;outer&amp;#39;}, and .bind({ x: &amp;#39;inner&amp;#39; }) applied on the first function doesn’t make difference.
So the answer is: [&amp;#39;outer&amp;#39;, &amp;#39;outer&amp;#39;].

Question 3:1let x, &amp;#123; x: y = 1 &amp;#125; = &amp;#123; x &amp;#125;; y;

undefined
1
{ x: 1 }
Error

Variable y will eventually have value 1 since:
First, let x defines x with the value undefined.
Then, destructuring assignment { x: y = 1 } = { x } on the right hand side has a short notation for an object literal: the {x} is equivalent to {x: x}, that is an object {x: undefined}.
Once it’s destructured the pattern { x: y = 1 }, we extract variable y, that corresponds to the property x. However, since property x is undefined, the default value 1 is assigned to it.
So the answer is: 1.

Question 4:1234567(function() &amp;#123;  let f = this ? class g &amp;#123; &amp;#125; : class h &amp;#123; &amp;#125;;  return [    typeof f,    typeof h  ];&amp;#125;)();

[“function”, “undefined”]
[“function”, “function”]
[“undefined”, “undefined”]
Error

This IIFE is executed with no explicit this value. In ES6 it means it will be undefined (the same as in strict mode in ES5).
So the variable f is bound to the class h {}. Its typeof is a &amp;quot;function&amp;quot;, since classes in ES6 is a syntactic sugar on top of the constructor functions.
However, the class h {} itself is created in the expression position, that means its name h is not added to the environment. And testing the typeof h should return &amp;quot;undefined&amp;quot;.
And the answer is: [&amp;quot;function&amp;quot;, &amp;quot;undefined&amp;quot;].

Question 5:1(typeof (new (class &amp;#123; class () &amp;#123;&amp;#125; &amp;#125;)))

“function”
“object”
“undefined”
Error

This is an obfuscated syntax playing, but let’s try to figure it out :)
First of all, since ES5 era, keywords are allowed as property names. So on a simple object example, it can look like:
123let foo = &amp;#123;  class: function() &amp;#123;&amp;#125;&amp;#125;;
And ES6 standardized concise method definitions, that allows dropping the : function part, so we get the:
123let foo = &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
This is exactly what corresponds to the inner class () {} – it’s a method inside a class.
The class itself is anonymous, so we can rewrite the example:
12345let c = class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;new c();
Now, instead of assigning to the varialbe c, we can instantiate it directly:
123new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;;
The result of a default class is always a simple object. And its typeof should return &amp;quot;object&amp;quot;:
123typeof (new class &amp;#123;  class() &amp;#123;&amp;#125;&amp;#125;);
And the answer is: &amp;quot;object&amp;quot;.

Quetion 6:1typeof (new (class F extends (String, Array) &amp;#123; &amp;#125;)).substring

“function”
“object”
“undefined”
Error

Here we have a similar obfuscated example (but we already figured out this inlined typeof, new, and class thing above ;)), though the interesting part is the value of the extends clause. It’s the: (String, Array).
The grouping operator always returns its last argument, so the (String, Array) is actually just Array.
So what we’ve got here is:
12345class F extends Array &amp;#123;&amp;#125;let f = new F();typeof f.substring; // &quot;undefined&quot;
Since array instances do not have substring method, and our extended class F didn’t provide it either, the answer is &amp;quot;undefined&amp;quot;.

Question 7:1[...[...'...']].length

1
3
6
Error

Here we deal with the spread operator. It allows to spread all the elements to the array. It can work with any iterable object.
Strings are iterable, meaning that we can iterate over their chars (in this case char by char). So the inner [...&amp;#39;...&amp;#39;] results to an array: [&amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;]:
12345let s = '...';let a = [...s];console.log(a); // ['.', '.', '.']
Array are iterable as well. So the outer spread is applied on our new array:
1234let result = [...a];console.log(result); // ['.', '.', '.']console.log(result.length); // 3
As we can see spreading the array happens element by element, so the resulting array just copied all the elements, and looks the same – with just 3 string dots.
And the answer is: 3.

Question 8:1typeof (function* f() &amp;#123; yield f &amp;#125;)().next().next()

“function”
“generator”
“object”
Error

In this example we encounter a generator function. When executed, they return a generator object:
1let g = (function* f() &amp;#123; yield f &amp;#125;)();
Generator objects have next method, that returns the next value at the yield position. The returned value has iterator protocol format:
1&amp;#123;value: &amp;#60;returned value&amp;#62;, done: boolean&amp;#125;;
So on first next() we get:
1g.next(); // &amp;#123;value: f, done: false&amp;#125;
As we see, the returned value itself doesn’t have method next(), so trying to call it as a chain would result to an error:
1g.next().next(); // error
Notice though, that we could normally call it as:
12g.next(); // &amp;#123;value: f, done: true&amp;#125;g.next(); // &amp;#123;value: undefined, done: true&amp;#125;
So the answer is: Error.

Question 9:1typeof (new class f() &amp;#123; [f]() &amp;#123; &amp;#125;, f: &amp;#123; &amp;#125; &amp;#125;)[`$&amp;#123;f&amp;#125;`]

“function”
“undefined”
“object”
Error

The obfuscated example results to a Syntax Error since class name f() is not correct.
The answer is Error.

Question 10:1typeof `$&amp;#123;&amp;#123;Object&amp;#125;&amp;#125;`.prototype

“function”
“undefined”
“object”
Error

This one is very tricky :)
First, we deal with template strings.
They are capable to render values of variables directly in the strings:
123let x = 10;console.log(`X is $&amp;#123;x&amp;#125;`); // &quot;X is 10&quot;
However, in the example we have something that looks a bit strange: it’s not ${Object} how it “should be”, but the $.
No, it’s not another special syntax of template strings, it’s still a value inside ${}, and the value is {Object}.
What is {Object}? Well, as we mentioned earlier above, ES6 has short notation for object literals, so in fact it’s just the: {Object: Object} – a simple object with the property named &amp;quot;Object&amp;quot;, and the value Object (the built-in Object constructor).
Now it’s becoming more clear:
1234let x = &amp;#123;Object: Object&amp;#125;;let s = `$&amp;#123;x&amp;#125;`;console.log(s); // &quot;[object Object]&quot;
See what’s happened? The ${x} is roughly equivalent to the:
12345'' + x;// or the same:x.toString(); // &quot;[object Object]&quot;
Now, the string &amp;quot;[object Object]&amp;quot; obviously doesn’t have property prototype:
123&quot;[object Object]&quot;.prototype; // undefinedtypeof &quot;[object Object]&quot;.prototype; // &quot;undefined&quot;
So the answer is: &amp;quot;undefined&amp;quot;.

Question 11:1((...x, xs)=&amp;gt;x)(1,2,3)

1
3
[1,2,3]
Error

This one is the simplest. Rest parameters can appear only at the last postion. In this case ...x goes as a first argument of an IIFE arrow function, so results to a Parse Error.
And the answer is: Error.

Question 12:12345let arr = [ ];for (let &amp;#123; x = 2, y &amp;#125; of [&amp;#123; x: 1 &amp;#125;, 2, &amp;#123; y &amp;#125;]) &amp;#123;  arr.push(x, y);&amp;#125;arr;u

[2, { x: 1 }, 2, 2, 2, { y }]
[{ x: 1 }, 2, { y }]
[1, undefined, 2, undefined, 2, undefined]
Error

Several topics combined here: destructuring assignment, default values, and for-of loop.
However, we can quickly identify it’s an error, because of two one thing:
EDIT 1: @fkling42 pointed out that the variable y is in the environment, but is not initialized yet (being under TDZ – Temportal Dead Zone), and that’s the reason why it cannot be accessed
EDIT 2: @getify pointed out, that value 2 actually normally passes RequireObjectCoercible check, and hence there would be no error in destructuring let { x = 2, y } = 2;.

{ y } is a short notation of {y: y} and will fail, since variable y doesn’t exist in the scope; The variable y is in the scope, but is under TDZ, so cannot be accessed
(we wouldn’t reach this, because of the frist error, but): trying to destructure 2 will fail too will not fail, since to object coercion will be normally applied.

So the answer is: Error.

Question 13:123456(function() &amp;#123;  if (false) &amp;#123;    let f = &amp;#123; g() =&amp;gt; 1 &amp;#125;;  &amp;#125;  return typeof f;&amp;#125;)();

“function”
“undefined”
“object”
Error

This example is only on attention, since it’s a syntax error: the arrow function =&amp;gt; cannot be defined in this way, since we have a an object with the g (consice) method.
And the answer is: Error.

ConclusionI like such tricky quiz questions, it’s always fun to track the runtime semantics and parsing process manually. Of course, most of the things here are far from practical production code, and are interesting mostly from the theoretical viewpoint. Still I found it enjoyable.
I’ll be glad to discuss all the questions in the comments.
Good luck with ES6 ;)
Written by: Dmitry Soshnikov
http://dmitrysoshnikov.com
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Scalable and Modular Architecture for CSS</title><link>http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/</link><category>read</category><tag>CSS,Modularity,SMACSS</tag><pubDate>2016-01-11T00:13:50.000Z</pubDate><description>Modularity of Web DevAs your project becomes more complex, its more difficult to maintain the code, no matter what kind of language you are using. That’s why we use OOP for most of the projects, by doing that, it saves you a lot of time and energy. Since web development becomes more popular, more and more people start focusing on this area and come up with some fantastic ideas about how to apply modularity or OOP on web development.
We all know that a basic website would contains three basic parts: HTML/CSS/JS. HTML is in charge of the struture, the CSS will focus on the appearance, and JS will give your website more animation(now css can do that too) and interaction. Among all these three parts, HTML is the easiest one, there is not so many things to talk about except the semantic tag, H5..etc, if you want to improve the modularity, most times HTML is not what you care most. Instead, CSS and JS are your primary concern.
Scalable and Modular Architecture for CSS is a nice book focus on applying modularity to CSS, and here is the notes I wrote down after I read it. About JS, we will talk about it later :) You can start with a nice and good coding style.
Reading NotesCategories of RulesJonathan Snook groups CSS rules into five types of categories:

Base: Base rules are the defaults. They are almost exclusively single ele- ment selectors but it could include attribute selectors, pseudo-class selectors, child selectors or sibling selectors. Essentially, a base style says that wherever this element is on the page, it should look like this;
You can use some reset frameworks out there, just be sure you know everything it does before you actually put it in your project;


Layout: Layout rules divide the page into sections. Layouts hold one or more modules together;
Generally, a Layout style only has a single selector: a single ID or class name;
Sometimes, you may have different layouts base on different settings like user preference, then you can use more than one selectors;


Modules: Modules are the reusable, modular parts of our design. They are the callouts, the sidebar sections, the product lists and so on;
Each Module should be designed to exist as a standalone component;
Avoid using IDs and ele- ment selectors, sticking only to class names;
Only include a selector that includes semantics. A span or div holds none. A heading has some. A class defined on an element has plenty;
If you do wish to use an element selector, it should be within one level of a class selector;


State rules: State rules are ways to describe how our modules or layouts will look when in a particular state. Is it hidden or expanded? Is it ac- tive or inactive? They are about describing how a module or layout looks on screens that are smaller or bigger. They are also about de- scribing how a module might look in different views like the home page or the inside page;
A state is something that augments and overrides all other styles;
States should be made to stand alone and are usually built of a single class selector, sometimes you can use !important to address the state;
In a case where a state rule is made for a specific module, the state class name should include the module name in it;


Theme rules: Theme rules are similar to state rules in that they describe how modules or layouts might look. Most sites don’t require a layer of theming but it is good to be aware of it;
Focus on general appearance of your website like colors, borders etc;



And also using proper name for different categories can be beneficial for immediately understanding which category a particular style belongs to and its role within the overall scope of the page. Here is a simple example:
123456789101112/* Example Module */.example &amp;#123; &amp;#125;/* Callout Module */.callout &amp;#123; &amp;#125;/* Callout Module with State */.callout.is-collapsed &amp;#123; &amp;#125;/* Form field module */.field &amp;#123; &amp;#125;/* jsExample is a subclass or variation of example */.example-jsExample &amp;#123; &amp;#125;/* Inline layout  */.l-inline &amp;#123; &amp;#125;
Tips
Minimizing the Depth: The depth of applicability is the number of generations that are affected by a given rule;
Two Goals of SMACSS: Increase semantics and decrease reliance on specific HTML;
How to separate the files in your project:
Place all Base rules into their own file;
Depending on the type of layouts you have, either place all of them into a single file or major layouts into separate files;
Put each module into its own file;
Depending on size of project, place sub-modules into their own file;
Place global states into their own file;
Place layout and module states, including media queries that affect those layouts and modules, into the module files;


Organize styles in the following order:
Box: display, float, position, left, top, height, width…
Border: border;
Background: background;
Text: font-family, font-size, text-transform, letter-spacing…
Others: others;


Be Consistent;

SummaryThis book is pretty short with all valueable content. Strongly recommend after you get familiar with all basic css concepts.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (7)</title><link>http://taoalpha.me/blog/2015/06/26/read-javascript-the-definitive-guide-7/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-26T06:00:00.000Z</pubDate><description>概述阅读笔记Chapter 15 - Scripting Documents
Selecting:
document.getElementById(id): 通过id, 一个id对应一个元素;
document.getElementsByName(name): 通过name, 可多个;
document.getElementsByTagName(tagname): 通过标签名;
document.getElementsByClassName(class_name): 通过类名;
querySelectorAll(css_selector): 通过css的选择器, 返回所有匹配;
querySelector(css_selector): 返回首个匹配;


Trees of Nodes:
parentNode: 父节点;
childNodes: 子节点;
firstChild, lastChild: 首个或者最后一个子节点;
nextSibling, previousSibling: 下一或者上一兄弟姐妹节点;
nodeType: 节点类型, Document 节点返回9, 元素节点返回1, 文本节点返回3,注释节点返回8, DocumentFragment节点返回11;
nodeValue: 当前节点的文本内容;
nodeName: 标签名, 大写;


Trees of Elements: 忽略所有的文本节点和注释节点;
firstElementChild, lastElementChild: 返回首个或者最后一个元素节点;
nextElementSibling, previousElementSibling
childElementCount: 返回子元素节点的个数;


Attributes of Elements:
getAttribute()
setAttribute()
hasAttribute()
removeAttribute()


Dataset Attributes: 由HTML5引入, 所有带data-前缀的属性都算是合法的html元素属性.
Element Content:
innerHTML
outerHTML: 包含匹配元素自身标签;
insertAdjacentHTML(): 允许指定插入位置beforebegin, afterbegin, beforeend or afterend;
textContent: IE不支持
innerText: IE支持, 功能同上;


Creating,Inserting, and Deleting Nodes
document.createElement(tag_name)
document.createTextNode(text): 创建文本节点;
document.createComment(text): 创建注释节点;
document.createDocumentFragment(): 创建孤立节点;
node_name.cloneNode(): 复制当前节点;
element_node.appendChild(element_node_2): 由后插入;
element_node.insertBefore(element_node_2): 由前插入;
removeChild(): 移除当前节点n.parentNode.removeChild(n);;
replaceChild(): 替换


DocumentFragment: 孤立节点, 其没有母节点(null), 当appendChild()等操作针对其时, 操作执行对象自动变为其所有子节点, 且操作完成后, 其自身为空;
viewport: 表示实际展示内容的窗口, 在顶层网页中为去除浏览器菜单等等之外的部分, 而在iframe中则为iframe定义的frame大小;
document: 表示页面内容的窗口, 通常都大于viewport;
getBoundingClientRect(): 返回节点的长宽,上下左右边界属性width,height,top,left,bottom,right, 返回的结果是基于viewport的;
document.elementFromPoint(): 返回x,y处的元素节点 - 根据z-index, 从外到内的返回;
scroll(), scrollTo(), scrollBy(): 窗口滚动控制, 最后的scrollBy()传入的x,y表示在原有的基础上的增加值;
scrollIntoView(): 滚动到某个节点;
document.forms: 获取页面中所有form元素;
其他document属性:
cookie
domain
lastModified: 修改时间;
location: 等同于window.location
referrer
title
URL: 之前提到过, 其只保存打开时的当前链接, 不随页面内的动态变化而变化;



Chapter 16 - Scripting CSS
js可以通过node.style来访问元素样式属性, 可以获取, 赋予; 而通过更加复杂的函数变化, 就可以创造出一些很棒的动效来, 在css3之前, 所有的非gif或者flash动效基本都是通过js实现的.
window.getComputedStyle(element,&amp;quot;null or :first-line etc&amp;quot;)则可以获取某个元素(或者某个元素的伪类)的所有样式属性, 同时获取的值都会自动转为标准的绝对值(比如设定的百分比也会自动计算出来返回),但是其不能赋予;
disableStylesheet()可以禁止某个元素的所有样式, 如果传入的是数字, 那么会按照document.styleSheets的顺序查找, 如果是string, 则作为css selector查询对应的元素;
insertRule(rules,insert_index), deleteRule(rules) 即插入整条的结构化的css语句, IE下对应的函数为addRule(),removeRule();
document.createStyleSheet则可以创建一个新的样式表, 等价于在head里面创建一个style标签;

Chapter 17 - Handling Events
Events的类型
Device-dependent input events:mousedown, mousemove, mouseup, keydown, keypress, keyup, touchmove, gesturechange;
Device-independent input events: click
User interface events: focus, change
State-change events: loadstart, progress, loadend
API-specific events: dragstart, dragenter, dragover, drop, waiting, playing, seeking, volumechange etc
Timers and error handlers;


Handlers:
Event Handler Attributes: onclick=&amp;quot;&amp;quot;,window.onload = f();
addEventListener(event_name,function,[capturing event handler]): 添加事件, 最后的capturing通常为false;
removeEventListener(): 和上面的add相反;
stopPropagation(): js的事件触发是沿着DOM树向上传递的, 而通过stopPropagation()就能抑制这一环节;
preventDefault(): 很多元素有其自身的事件属性, 比如a标签的跳转, form元素的提交, 当我们想要取消其默认事件的发生时, 可以使用此函数来阻止其发生;



总的来说, 这一章内容其实很丰富, 但是其内容多数都是建立在之前的基本内容之上的. 着重需要知道的就是各种不同的事件, 其支持的元素, 类型以及触发的方式即可. 此类用法主要还是多用多练, 可以试试不同的event都包含那些属性~哈哈
Chapter 18 - Scripted HTTP
XMLHttpRequest:
Ajax: 由js端发起, 通过http请求和服务端交互;
Comet: 由服务端发起, js如果需要反应则使用Ajax回应, 通常由EventSource对象处理;
标准流程:new XMLHttpRequest()=&amp;gt;open(&amp;#39;type of request&amp;#39;, url,[],[username],[userpassword])=&amp;gt;setRequestHeader()=&amp;gt;send([content_body])&amp;lt;=onreadystatechange&amp;lt;=customized handler
通常GET类型的请求我们会通过encodeURIComponent来进行url拼接, 直接在url中体现, send()的时候就不用传值了;
POST类型的请求通常以json格式传递, 我们需要在send()中传入JSON.stringify()的数据, 当然如果是XML的POST, 那么直接传入对应的doc即可, 而像file这类的文件实体, 也是直接传入对应的实体即可;
起中Header部分我们只能自行设定部分, 而Content-Length,Date,Referer,User-Agent等等都由浏览器自动帮我们填上了;
readyState: UNSENT 0(open()还没执行); OPENED 1(open()已经执行);HEADERS_RECEIVED 2(headers已被接收),LOADING 3(正在接受返回),DONE 4(完毕).
XMLHttpRequest对象有一个onprogress的属性可以用来检测其执行进度, 它对应的属性值中包含了lengthComputable, loaded,total, 通过这三个就可以做一个简单的进度条跟踪请求的进度了;
如果是上传行为, 其onprogress属性存在于XMLHttpRequest_Object.upload.onprogress之中;
abort(): 用来取消请求;


EventSource:
标准流程: new EventSource(&amp;quot;url_to_server_file&amp;quot;) =&amp;gt; onmessage



Chapter 19 - The jQuery LibraryjQuery流行度的一大证据之一! 哈哈 我计划抽时间好好读一下jQuery的源码, 所以这里只是大概扫了一遍, 基本也都是应用层面的, 多数我差不多都使用过~哈哈
Chapter 20 - Client-Side Storage我在早先做chrome插件详见我的portfolio的时候, 写过一篇专门介绍web存储的文章. 恩, 当时写了不少patch系列, 哈哈, 改天写个脚本全部导出来转移过来.
恩
参考资料
JavaScript the Definitive Guide 6th edition 我现在就去写导入工具… 今天就到这里吧, 明天算是最后一篇就能完结本书啦~

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (2)</title><link>http://taoalpha.me/blog/2015/06/18/read-javascript-the-definitive-guide-2/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-18T10:00:00.000Z</pubDate><description>概述作为JS中的一等公民, function(函数)始终是JS的核心中的核心. 所以这里单独用一篇笔记来记录JavaScript: the definitive Guide一书第八章的内容. 主要介绍了函数的定义, 作用域, 参数, 声明以及执行等基础知识, 另外也着重介绍了其高级用法中的closure. 我将自己觉得重要的, 值得记录的部分都作为心得摘抄如下:
心得arguments对象对每一个function而言, 都自动会有一个内置的arguments对象, 用它就可以访问传入的参数了. 通常来说arguments对象我们只会用在不定长传参的函数上, 但arguments本身带有的一个函数却是可以在某些时刻发挥重要作用的~ 这个函数就是callee函数:
12345678// 递归自我调用函数在解决一些问题的时候是很常用的, 而通常情况下我们都会在函数内调用本函数名即可, 但是如果我们需要实现自我调用的函数正好是一个无名函数呢?// arguments.callee 即调用当前执行的函数function(x)&amp;#123;return x*arguments.callee(x-1)&amp;#125;// 如上, 就实现了一个很简单的&amp;gt;2阶乘计算了
需要特别注意的就是callee作为arguments对象的一个方法, 是可以跟随arguments作为参数传递的, 而且其作为参数的时候保持其所指代函数不变.
既然说到arguments, 就多说两句喽. 首先arguments算是一个类array的object. 它本身具有array的一些特性, 比如可以直接调用length函数(通常的object是不能通过.length直接调用获取长度的, 需要使用Object.keys(object_name).length才能获得). 但是它本身和array.length有很大的差别, 其中最大的一个差别就是: 无法通过.length直接更改数组长度.
123456var a = [1,3,4]a.length = 5console.log(a)// output: [1,3,4,undefined x 2](function(x)&amp;#123;arguments.length = 5;console.log(arguments)&amp;#125;)(10,1,2)// output: [10,1,2]
可以看到通过对arguments.length直接赋值, 并不会影响其本身的长度, 这一点和array本身有很大的差别.
PS. 上述示例是增加长度, 其实缩减长度也是一样的, 多余的元素会被自动删除. 所以, 通过直接向array.length赋值也算是一个修改array长度的方法喽~
PSS. 通常如果一个函数接受参数比较多的时候, 为了预防因为参数顺序而产生的问题, 可以采取传json格式的object作为参数, 这样就能够通过key而不根据顺序获取参数了.
Function的property请先看下述代码:
1234567891011f.temp = &quot;test&quot;function f(x)&amp;#123;  console.log(arguments.length);  console.log(arguments.callee.length);  console.log(f.temp);&amp;#125;f(1,2)// output: 2 1 &quot;test&quot;
首先, 我们看一下我们前两个输出值:
  如上所述,arguments.length即代表传入参数的数量, 我们传入了两个参数, 所以这里输出2, 没有任何问题. 那么后面的arguments.callee.length又是什么呢? 为什么它输出的是1呢? 
  根据之前的介绍, 我们当知道arguments.callee是代指当前的函数f(), 那么对应的arguments.callee.length即我们的函数f的length了. 对于Function这个对象而言, 它所拥有的length这一属性特指其声明的参数数量, 我们应该知道JavaScript作为一个很宽松的语言, 其函数定义后接受的参数是不定长的, 即便传入参数与函数声明的参数不相等也是不会抛出异常的, 那么有时候我们需要获取确保函数接受的参数和其声明的参数数量一致, 就可以使用函数自身的length属性来实现;
其次, 我们自定义了一个f的属性temp, 但是我们实在函数定义之前赋予这个属性的, 为什么依然能够在函数运行中输出呢? 
  这主要是因为js的执行顺序所致. js在载入执行过程中, 首先会将内部声明的函数都定义之后才会正式由上至下的逐次执行. 所以这里虽然我们把f.temp写在了函数定义之前, 但是js执行过程中, 还是首先定义了函数f, 接着才开始运行我们的f.temp赋值语句. 自然就不会报错说f没有定义了~
PS. 其实不止是Function, 即便是普通的变量声明, 也是编译和执行分开进行的, 比如var a = 2;也是拆解为var a; a = 2两步执行的, 而声明都是发生在编译过程, 待编译过程全部结束后, 才会由上到下一次执行, 这也是为什么, 单纯的声明可以出现在代码的任意部位都不会影响其所在作用域的生效, 不会爆出not defined的错误;
reserved word, identifier, keyword这三个作为基础知识, 可以说是每门语言都共通的概念,  但很多时候我们都不会用到或者不会特意去区分这三个名词, 而最近因为看原版书, 经常会出现三个词的交叉, 所以这里特别google了以下, 试图总结下三者的区别:

identifier: 通常我们把我们定义的变量名, 函数名, 类名, 标签名,宏定义名, 类型名等称为identifier, 取其标识之意, 用以作为其名称以便代用;
reserved word: 与identifier相对, reserved word则是指由语言规定而保留的一些词, 这些词有着特定的用途而不能被用作identifier;
keyword: 作为语言语法的组成部分之一, keyword通常都会有着特定的含义, 绝大多数的keyword都是reserved word, 但也有少量语法中存在keyword不是reserved word的情况, 比如fortran就没有reserved word的概念, 它的所有keyword都可以用作identifier;

reserved word和keyword确实在很大程度上是共同的, 除了上述说的类似fortran语言这种情况外, 也存在reserved word不是keyword的情况, 比如java中的goto就是一个reserved word, 但本身又不是一个keyword, 所以可以说goto这个词基本在java中是完全废弃的~ 那他们为啥要定义这个goto呢?? 有一种说法是这样情况通常是为未来版本预留的~ 还有一种说法是JVM作者James Gosling最初加了goto的支持, 但后来发现完全没必要, 就又去掉了, 但是为了兼容性问题,也一直没有把goto从reserved word此表中删去.
PS. 很多时候也有人完全不区分reserved word和keyword的区别, 完全等同二者为”不能用来做identifier的词”.
closure - 闭包在javascript中, 一个function由两部分组成: 函数执行的代码以及代码执行的环境. 而这两个组合到一起后也有个专属的名称, 即closure. 不过单独一个独立函数的closure并没有什么值得说的意义, 因为其执行的环境, 即我们称之为scope的东西, 随着函数的执行开始与结束会自动的被创建并清理掉, 所以通常情况下closure都单指在嵌套函数中. 当存在嵌套的函数时, 并且函数之外存在一个reference指向函数的话, 事情就变得好玩多了:
12345678910111213141516171819202122232425262728function f()&amp;#123;  var id = 1;  return function()&amp;#123;console.log(id++)&amp;#125;&amp;#125;f()();f()();f()()// output: 1,1,1// 每次我们调用`f()`,都会自动创建一个包含了其局部变量`id`的对象, 而嵌套的函数`f()()`会自动继承母函数的作用域;// 但每次随着调用结束, 因为没有任何外部引用, 所以创建的对象都会自动的被回收, 如此就导致每次调用`f()()`都会输出1了;var k = f();k();k();k()// output: 1,2,3// 同样是调用`f()`, 但是我们首先引入了一个新的变量`k`引用`f()`函数; // 这样随着`f()`的调用和结束, 其创建的`call`对象(即包含了局部变量id的那个对象)就因为还存在外部引用而得以保留// 所以后面连续调用`k()`的过程中, 本身的嵌套函数就始终共享着`call`对象的作用域, 如此每次输出的时候都是先获取了局部变量id, 然后在执行`id++`,所以输出为1,2,3// 不喜欢`f()()`这种调用方式, 也不想单独创建新变量来增加引用? 当然可以, 只需要借助下`anonymous function`即可:var f = (function()&amp;#123;    var id = 1;    return function()&amp;#123;console.log(id++)&amp;#125;  &amp;#125;)();f();f();f()// output: 1,2,3// `anonymous function`是自执行的函数, 这里相当于把之前的`var k = f()`以及`f()`的声明定义合二为一了.
可以说上述基本就是closure最基本的内容了, 而closure作为js的高级用法之一, 掌握了它, 你就能做很多有意思的操作了. 一个简单的例子就是: 你可以参照closure的原理来模拟实现浏览器探查元素(inspector)的breakpoint功能.
因为原作trimpath上的文章已经无法访问, 所以转载了一个类似的如下, 略作了简单的修改(加了几句更友好的提示和显示每一步的运算结果):
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// This function implements a breakpoint. It repeatedly prompts the user// for an expression, evaluates it with the supplied self-inspecting closure,// and displays the result.  It is the closure that provides access to the// scope to be inspected, so each function must supply its own closure.// // Inspired by Steve Yen's breakpoint() function at// http://trimpath.com/project/wiki/TrimBreakpoint//function inspect(inspector, title) &amp;#123;    var expression, result;    // You can use a breakpoint to turn off subsequent breakpoints by    // creating a property named &quot;ignore&quot; on this function.    if (&quot;ignore&quot; in arguments.callee) return;    while(true) &amp;#123;        // Figure out how to prompt the user        var message = &quot;&quot;;        // If we were given a title, display that first        if (title) message = title + &quot;\n&quot;;        // If we've already evaluated an expression, display it and its value        if (expression) message += &quot;\n&quot; + expression + &quot; ==&amp;gt; &quot; + result + &quot;\n&quot;;        else expression = &quot;&quot;;        // We always display at least a basic prompt:        message += &quot;Enter an expression to evaluate, or just click cancel to see the next step of current calculation.&quot;;        // Get the user's input, displaying our prompt and using the        // last expression as the default value this time.        expression = prompt(message, expression);        // If the user didn't enter anything (or clicked Cancel),        // they're done and so we return, ending the breakpoint.        if (!expression) return;        // Otherwise, use the supplied closure to evaluate the expression        // in the scope that is being inspected.         // The result will be displayed on the next iteration.        result = inspector(expression);    &amp;#125;&amp;#125;function factorial(n) &amp;#123;        var inspector = function(x) &amp;#123;                return eval(x);        &amp;#125;        inspect (inspector, &quot;Entering factorial()&quot;);        var result = 1;        while (n &amp;gt; 1)&amp;#123;                result = result * n;                n--;                inspect(inspector, &quot;factorial() loop with current result:&quot;+result);        &amp;#125;        inspect(inspector, &quot;Exiting factorial()&quot;);        return result;&amp;#125;inspect(function (x) &amp;#123;return eval(x);&amp;#125;, 'Hello')factorial(5)// 通过closure, 它就可以检测factorial执行的各个环节, 从而更容易的找到你在不同环节的问题.
虽然closure让你可以写出更加复杂的js代码, 但是本身closure的使用还是要慎重的, 因为closure需要存储函数对象在内存中而不销毁, 所以如果函数主体庞大, 那么对于内存的压力和运行性能都是会有影响的~
Function constructor类似Array, String等都有着一个对应的类, 可以允许你通过new来创建对象. Function也有自己对应的Function()类, 可以通过:new Function()来创建函数, 其接收不定长参数, 最后一个参数始终作为函数运行主体. 不过通常来说这种方法定义函数远没有我们常用的function关键词来的方便, 所以使用上倒是少了很多~ 不过有几点还是值得注意的:

new ClassFunction() 是把function作为constructor的一种用法, 你可以简单的理解为: var cc = new ClassFunction(params) ==&amp;gt; var cc = new Object();ClassFunction.call(cc,params)
new Function()不接收函数名参数, 即其创建的都是anonymous function;
new Function()不继承作用域, 几遍其是在嵌套函数中定义, 也只继承global域, 不会继承上层函数的作用域;

谜题12345678910111213var name = &quot;The Window&quot;;var object = &amp;#123;  name : &quot;My Object&quot;,  getNameFunc : function()&amp;#123;    console.log(this);    return function()&amp;#123;      return this.name;    &amp;#125;;  &amp;#125;&amp;#125;;console.log(object.getNameFunc()());// output: Object&amp;#123;name:&quot;My Object&quot;&amp;#125;; &quot;The Window&quot;
上述定义中, 为什么嵌套函数没有继承上层函数的this呢? 反而继承了全局的this?
猜测解答: this这个关键字是个比较特殊的关键字, 它具有一个很有趣的特点就是: 当一个函数作为函数而不是方法来调用的时候, this指向的是全局对象, 只有当它是方法的时候, 其指向的才是所属对象; 题目来源阮一峰博客. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (4)</title><link>http://taoalpha.me/blog/2015/06/23/read-javascript-the-definitive-guide-4/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-23T07:00:00.000Z</pubDate><description>概述第六版和第五版的最大区别在于ECMAScript 5的引入, 这是目前发布的最新的js版本, 有着最新的属性和函数, 目前主流浏览器基本都已经完全支持. 本文为阅读5-9章内容的笔记总结, 主要是覆盖了JS中的语句和典型对象.
阅读笔记Chapter 5 - Statements
switch/case中使用的是===进行比较判断的, 而不是==;
with带入scope chain的对象只有读取权限, 没有写入功能, 即with后, 可以获取其代入的对象, 但其内声明的变量都依然归于gloabl或者local之中;
debugger是ECMAScript 5引入的一个新的statement, 起主要作用是和浏览器结合使用, 用于创建断点以便查错使用;
use strict也是ECMAScript 5引入的, 严格来说不算statement而是directive, 不过两者很是相近; 其使用必须位于js整体的起始位置或者是一个function主体的起始位置;
use strict的使用会开启代码的strict mode, 为了提升效率, 错误追踪以及更好的安全性, 其语法要求会更加严格, 简单列举如下:
停用with语句;
所有变量必须声明才能调用;
所有独立声明的函数而非对象的方法定义的, 其this域都默认为undefined, 而函数如果通过apply,call调用, 其this域为传入对象;
对未声明变量的赋值或者不能写入的对象进行写入, 都会抛出异常;
eval调用会自动创建临时局部scope, 不再能直接对母域新建声明了;
arguments成为传入参数的硬拷贝, 和传入参数名之间不在绝对相等, 即改变一方不会引起另一方的改变, 同时停用其caller,callee方法;
delete用于变量, 函数或者函数参数的时候会抛出异常, 操作对象的某个未声明属性也会抛出异常;
对象(包括函数)创建中不能出现同名属性(参数);
直接声明的八进制数是不允许的(即0开头的数字);
eval,arguments作为keywords对待, 不能赋值, 或赋予其他变量, 也不能用于identifier;




Chapter 6 - Objects
Property Attributes (ECMAScript 5之后引入可自定义配置, 之前默认三者皆有.)
writable: 可赋值;
enumerable: 可递归;
configurable: 可配置 - 可删除也可修改;


Object Attributes
portotype: 指向当前对象的属性继承对象;
class: 指代对象所属类别;
extensible: 指示当前对象是否能够新增属性 (ECMAScript 5引入);


Object Categories and Property Types:
native object: js中内置的对象, 包含Arrays, functions, dates, regular expressions等;
host object: 由js运行环境所定义的对象, 比如常见的浏览器, 就包含了HTMLElement对象;
user-defined: 执行js代码的时候创建的对象;
own property: 直接由对象中定义的属性;
inherited property: 由对象的prototype object继承来的属性;


Prototype:
任何一个对象(除了Object.protytpe)的出现都必然包含了第二个对象的存在: new Array() =&amp;gt; Array.prototype;
Object.prototype是唯一一个没有母继承的对象了, 它是最顶部的类;
类似new Array() =&amp;gt; Array.prototype =&amp;gt; Object.prototype这样的两个prototype就组成了Array的prototype chain;
Object.create() 是ECMAScript 5引入的新的创建对象的方法, 其接受两个参数, 第一个参数会作为新建对象的prototype传入, 第二个则是用来描述新对象的属性的. 如果你传入null, 则新建对象是完全没有prototype的, 只有Object.create(Object.prototype)才是等价于我们常用的{} or new Object();
获取某个object的未定义属性将返回undefined, 但是获取undefined或者null的某个属性则会抛出异常;


getter &amp;amp;&amp;amp; setter
ECMAScript 5新引入的两个accessor properties, 分别对应某个属性的调用和赋值;
只有setter的属性只有写入权限, 只有getter的属性则是只读权限;


property attributes
value, writable, enumerable, and configurable
对应的accessor property: get, set, enumerable, and configurable
Object.getOwnPropertyDescriptor(object_name, property_name) 获取某个属性的特征描述;
Object.defineProperty(object_name, property_name,{property_attribute:attribute_value}) 对某个属性设定其特征描述;



下例即为利用Object.defineProperty自定义的一个extend()函数:
123456789101112131415161718192021222324252627282930// Example 6-3. Copying property attributes/** Add a nonenumerable extend() method to Object.prototype.* This method extends the object on which it is called by copying properties* from the object passed as its argument. All property attributes are* copied, not just the property value. All own properties (even non-* enumerable ones) of the argument object are copied unless a property* with the same name already exists in the target object. */Object.defineProperty(Object.prototype,  &quot;extend&quot;,  &amp;#123;    writable: true,    enumerable: false,    configurable: true,    value: function(o) &amp;#123;      // Define Object.prototype.extend      // Make it nonenumerable      // Its value is this function      // Get all own props, even nonenumerable ones      var names = Object.getOwnPropertyNames(o); // Loop through them      for(var i = 0; i &amp;lt; names.length; i++) &amp;#123;        // Skip props already in this object        if (names[i] in this) continue;        // Get property description from o        var desc = Object.getOwnPropertyDescriptor(o,names[i]);        // Use it to create property on this Object.defineProperty(this, names[i], desc);      &amp;#125;    &amp;#125;  &amp;#125;);

Object Attributes;
Object.getPrototypeOf() ECMAScript 5引入, 可用于获取某个对象的prototype;
p.isPrototypeOf() 同上, 用于判断某个对象是否为另一个对象的prototype;
Object.isExtensible(),Object.preventExtensions()则分别是用于判断一个object是否是可扩展的, 以及禁止其可扩展性的(此操作不可复原);
Object.seal()类似Object.preventExtensions(), 不过它同时禁掉了properties的configurable属性,Object.isSealed()则是对应用于判断是否sealed的函数;
Object.freeze()比Object.seal()还要严格,所有属性都变为可读了, 对应的查询函数为:Object.isFrozen();
Object.preventExtensions(),Object.seal(),Object.freeze()都是只针对当前object而言的;
class属性目前基本没啥用, 有点等价或者说更细化的typeOf or instanceOf了;



Chapter 7 - Arrays这里主要记录ECMAScript 5引入的一些新的方法, 3已有的可以查看 阅读笔记-2

forEach(value,index,array_itself): array自身的循环调用函数, 相当于for(i in array_name){}, 区别在于其不支持break等可以跳出循环的语句, 如果你想要提前结束循环, 就需要通过try/catch包裹并利用抛出异常来结束循环;
map(): 也算是循环的一种, 遍历每个元素并传递给传入的函数, 最终返回一个新数组;
filter(): 顾名思义, 这是对数组进行筛选的, 值得一提的是filter()会自动跳过空白,所以对于稀疏数组通过filter()可以去除所有空白, 在加上undefined判断, 就可以去除所有空值了;
every() 和 some(): every()是当数组每个元素都使传入函数为真的时候返回真, some()则是只要一个为真即返回为真, 需要注意的事, 对于空数组, every()会返回真, 而some()会返回为假;
reduce(function,initial_value) 和 reduceRight(): 通过执行传入函数而对数组元素进行整合,计算,判断, 最终返回一个结果: var max = a.reduce(function(x,y) { return (x&amp;gt;y)?x:y; });即返回数组的最大值; reduceRight()与reduce()一致, 只是循环顺序相反, 从右到左; 当没有声明初始值时, 采用第一个执行元素作为初始值;
indexOf() 和 lastIndexOf: 顾名思义, 获取数组中某个元素的index, 前者获取首个匹配元素的index, 后者获取最后一个匹配元素的index;

Chapter 8 - Functions
Functions的调用有四种:
直接调用;
作为对象的方法调用;
作为constructor调用;
通过call,apply方法调用(间接调用);


call() 和 apply:
call和apply都是间接调用的方法, 允许一个函数临时客串为某个object的方法;
一定程度上, 可以等价于o.m = f;o.m();delete o.m;
其接受的第一个参数会成为函数运行的this域, 如果是非strict mode下, 传入null/undefined则会自动将global作为this, 而如果传入的是primitive datatype, 则自动转为对应的wrapper object, 即string =&amp;gt; String;
call和apply的区别主要体现在后面的参数上, 前者以分散元素传入, 后者则以整体数组形式传入, 所以用apply可以把原本只支持不定长参数的函数转换为接受数组的函数:var biggest = Math.max.apply(Math, array_of_numbers);;
apply对类array元素处理方式同array元素;


bind(): 很是类似call和apply, 本质也是把某个函数作为某个对象的方法调用, 实现则是通过把object和function绑定, 形成一个新函数从而每次调用新函数都等价于调用了object.funtion, bind接受多个参数, 其首个以后的参数都会作为this域成员代入函数中, 并按序成为函数自身的参数function f(y,z) { return this.x + y + z };var g = f.bind({x:1}, 2);g(3) // 2被赋予了y, 新的3则给了z;
higher-order function: 作用于另一个函数之上的函数;

partial and memoization 这两个都是function programing中常用的方法:

partial: 类似bind()这种会把传入参数默认分配到函数自身的部分接受参数上的做法就是partial application;
memoization: 将函数运行过程的计算结果缓存起来的方式;



123456789101112131415161718192021222324function array(a, n) &amp;#123; return Array.prototype.slice.call(a, n || 0); &amp;#125;// 用以处理类array元素(转为真正的array)function partial(f /*, ... */) &amp;#123;  var args = arguments;  // 存储partial的参数  return function() &amp;#123;    var a = array(args, 1);    // 取出首位以后的参数    var i=0, j=0;    for(; i &amp;lt; a.length; i++)      if (a[i] === undefined) a[i] = arguments[j++];      // 这里的arguments是第二层参数      // 将空元素逐个替换成第二层参数里的值, j自动随着执行+1    a = a.concat(array(arguments, j))    // 组成新的参数数组    return f.apply(this, a);    // 调用f函数, 并传入参数a  &amp;#125;;&amp;#125;var f = function(x,y,z)&amp;#123;return x*y*z&amp;#125;partial(f,undefined,2)(1,3)// x:1,y:2,z:3
123456789101112131415// Return a memoized version of f.// It only works if arguments to f all have distinct string representations.function memoize(f) &amp;#123;  var cache = &amp;#123;&amp;#125;;  return function() &amp;#123;    var key = arguments.length + Array.prototype.join.call(arguments,&quot;,&quot;);    if (key in cache) return cache[key];    else return cache[key] = f.apply(this, arguments);  &amp;#125;;&amp;#125;// 应用方式类似;var factorial = memoize(function(n) &amp;#123;return (n &amp;lt;= 1) ? 1 : n * factorial(n-1); &amp;#125;);factorial(5) // 此时会自动缓存4,3,2的阶乘值. 对于一些复杂的运算, 如此可以很好的加快运算速度.
Chapter 9 - Classes and Modules除了 阅读笔记-2中包含的, 由于ECMAScript 5所引入的那些object property自然都可以应用到新的class中, 从而创建更为复杂有效的函数. 其实js中目前不存在class这个关键词, 所以其模仿的class, 说白了就是一个复杂一些的函数对象.
而因为其内容驳杂繁多, 我么会在后面的应用中有很多实践的机会, 这里就不一一描述了.
参考资料
JavaScript the Definitive Guide 6th edition
Functional Javascript

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (5)</title><link>http://taoalpha.me/blog/2015/06/24/read-javascript-the-definitive-guide-5/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-24T08:00:00.000Z</pubDate><description>概述在十到十二章中, 第十章的正则表达式内容最为丰富, 也是目前应用即为广泛的内容之一. 不过这里也主要是结合js的应用, 实际上正则表达式本身就是一个很值得研究的话题, 有不少书都在谈这个话题, 我后面要读的书目中恰巧就有这么一本, 后面会更加详细的学习以下正则表达式的方方面面.
十一章算是非常前沿, 高端或者说冷门的点了, 随着浏览器的盛行以及技术的进步, 安全问题始终都是一个很重视的点, 而在这种攻防演练中也促进了js本身的进步, 而主流浏览器本身更是走在了js的最前沿. 各种新的属性都是由他们引入而逐渐成为标准的;
十二章主要是对走出浏览器的JS做了一个简单的介绍, 而NodeJS的大名在近几年在前后端, 全端领域都可谓是人尽皆知. 我也会在之后阅读相关书籍的时候做更详细的笔记记录.
阅读笔记Chapter 10 - Pattern Matching Regular Expressions
normal repetition characters:
{m,n} 匹配m-n次;
{m,} 匹配至少m次;
{m} 匹配恰好m次;
? 匹配0或1次;
+ 匹配1或多次;
* 匹配0或多次;


Nongreedy repetition:
??, +?, *? 在常规的匹配后加上?就能让匹配尽可能发生的短, 它会在允许范围内, 找到尽可能短的匹配;


Alternation, Grouping, Reference:
| 表示匹配前者或者后者;
(...) 成组, 以组的形式来使用*,+,?等, 同时会记录组的匹配以用于Reference;
(?:...) 只是成组, 不记录匹配, 不能用于reference, 也不算做reference的序号中去;
\n 引用, n表示序号, 从1开始, 代表之前第几个group的匹配, 用于匹配开头结尾相同且多样的有奇效:/([&amp;#39;&amp;quot;])[^&amp;#39;&amp;quot;]*\1/ 匹配单引号或者双引号内的内容;
需要注意的就是, reference不能用于[]的character class之中!


anchor characters:
^: 匹配开头;
$: 匹配结尾;
\b: 匹配词边界, /\bJava\b/ =&amp;gt; Java
\B: 匹配非词边界, /\B[Ss]cript\B/ =&amp;gt; JavaScript, postscript...
?=p: 表示内容需要匹配p规则,但是返回的命中中不包含这部分;
?!p: 表示内容不匹配p规则;


flags:
i: 大小写敏感, 即区分大小写;
g: 全局匹配, 默认是匹配首个;
m: 多行匹配;


String Methods for Pattern Matching:
search(): 返回匹配词的位置或者-1代表无返回;
replace(): 支持正则匹配替换, 同时支持替换时使用$n代表是正则匹配的引用, 比如text.replace(/&amp;quot;([^&amp;quot;]*)&amp;quot;/g, &amp;#39;“$1”&amp;#39;);即替换&amp;quot;&amp;quot;为“”;
match(): 返回包含了匹配的结果, 返回结构为数组格式;
split(): 接受正则匹配作为其分隔符, 比如: &amp;quot;1, 2, 3&amp;quot;.split(/\s*,\s*/); =&amp;gt; [&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;], 就去掉了本来直接split()多余的空格;


RegExp prototype method:
exec(): 基本等同match(), 不过接受的是string类型去匹配, 而由正则去调用, 当表达式加了全局flag后, exec()每次执行会记录其上次匹配的位置并从此开始新的匹配, 比如:var pattern = /Java/g;pattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).indexpattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).index就会相继输出0,28两个位置;
test(): 用以检测表达式是否匹配了传入的string, 其执行逻辑(g模式下记录上次匹配位置)和exec()一样;



Chapter 11 - JavaScript Subsets and Extensions本章主要介绍一些目前主流浏览器支持但是还没有写入JavaScript官方版本中的一些js语言的子集(非官方版本)和扩展属性:

subsets: 通常是为了确保不确定安全性的代码能够安全的运行而出现的(除了Crockford’s JavaScript: The Good Parts);
ADsafe, 最早一个因为安全因素设计的子集语言, 会禁止对绝大多数全局变量的访问;
dojox.secure: 算是Dojo toolkit的一个扩展;
Caja: 其包含了两个子集, 一个是Cajita, 比较严格, 类似ADsafe 和 dojox.secure; 还有个是Valija, 则比较接近如今ECMAScript 5的strict mode了;
Microsoft Web Sandbox;
FBJS: facebook使用的一个自己;通常子集都需要对应一个verifier, 来确保代码符合其要求;


extensions:
const: 声明常量, 比如: const pi = 3.14;;
let: 块变量声明, 相当于缩小版的var, 作用域仅存活在最近的一个块结构里, 你可以用{}来自行创建一个block;
destructing: 允许多变量结构化赋值: let [x,y] = [1,2];let [r,theta] = polar(1.0, 1.0); function polar(x,y){...};甚至这种all = [first,second] = [1,2,3,4]; 或者这种let transparent = {r:0.0, g:0.0, b:0.0, a:1.0}; let {r:red, g:green, b:blue} = transparent;;
for/each: 和for/in循环不同, for/each遍历对象的属性值而不是属性名, 且可操作类array对象;
for/in: 从js 1.7(mozilla的js引擎版本号)开始, for/in也不局限在array和常规object了, 只要是可循环的元素都可以使用了;
yield: 从python中引入的;
Array Comprehensions:  还是从Python中借用的, let evensquares = [x*x for (x in range(0,10)) if (x % 2 === 0)];
try/catch: 支持多catch;



Chapter 12 - Server-Side JavaScript随着js的发展, 慢慢的超出了其本身的作用域: 浏览器. 随着Google V8引擎为js包入了unix的常用API: files,processes,streams,sockets等, js开始走出浏览器进入server端了. 正式命名为Node.JS. 想来很多人可能都听过, 因为后面我的数目中也包含了相关的书, 且本章内容也没见过太多, 所以就一起留到以后吧~
参考文献:
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (6)</title><link>http://taoalpha.me/blog/2015/06/25/read-javascript-the-definitive-guide-6/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-25T10:00:00.000Z</pubDate><description>概述正式进入本书第二部分的内容, 核心主要围绕在浏览器内的js. 包含了最基本的使用方式, 方法, 因浏览器而增加的各种属性方法, 操作css, dom的方法, 以及常用的一些js框架, 库等, 同时还包含了目前浏览器大热的安全领域.
阅读笔记Chapter 13 - JavaScript in Web Browsers
异步:
defer: 使浏览器在解析并加载渲染完HTML的DOM后加载此js脚本;
async: 使浏览器在尽快执行js脚本, 但在下载js脚本时不停止DOM的解析, 优先级高于defer;
使用方式为在script中增加关键字即可: &amp;lt;script defer src=&amp;quot;deferred.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;;
注意在使用defer/async的时候, js中不能使用document.write();
document.readyState的变化过程: loading(async downloading, normal executing) =&amp;gt; interactive (defer/async executing) =&amp;gt; complete(defer/async done, event handlers invoked);


Compatibility Check:
按照目前的浏览器格局, 基本上一个浏览器就有着一种js的版本, 除了标准版本的基础功能之外, 所有的扩展功能, 各家与各家的实现方式都略有不同, 所以在使用过程中, 就需要我们考虑到兼容性的问题;
Can I Use…, 这是一个非常优秀的检测某个属性, 方法的浏览器支持度, 拿不准的都可以在这里进行查询确认, 其还支持css和html5的检测;
IE5的时候引入了一个Conditional Comments的技巧, 是通过特殊的html注释从而让浏览器识别其IE版本, 比如&amp;lt;!--[if lte IE 7]&amp;gt;&amp;lt;![endif]--&amp;gt;就代表IE7及以下, 而写在这个if里面的内容就会在IE7及以下的浏览器中被识别并作为页面html的一部分而提取出来(仅限IE浏览器), 其他的浏览器都会自动当做注释不理会此部分;
IE的JS也支持Conditional Comments, 比如/*@cc_on @if (@_jscript)...@end @*/, 这里面@cc_on...@*/是整个Conditional Comments, 而里面的@if (@_jscript)...@end则是判断部分, 其中@_jscript是IE自身js编译器的名称;


Accessibility:
对于身体原因而有不便的人, js的支持效果会大打折扣, 所以根据这部分人的情况而优化自身的网页结构, 目前也是网页设计的一大核心之一;


Security:
随着js的发展使用, 其危害性也日益提升;
目前的保障安全手段主要有:限制其功能,限制其使用范围和情景,敏感权限默认关闭虚人工开启;
The Same-Origin Policy: js只允许读取与当前执行环境域名相同域名下的windows属性, 那么怎么界定相同域名呢:
来自不同的网络服务器;
来自相同的网络服务器, 不同的端口;
同一网络服务器, 同一端口, 不同的http协议(http,https);
以上, 都认为是不同域名;


如何舒缓此规则:
document.domain: 考虑到同级子域名也会被禁止, 那么通过设定document.domain为同一母域名即可实现同级子域名的跨域;
Cross-Origin Resource Sharing: 通过http请求新增的Access-Control-Allow-Origin头部, 服务器就可以指定其允许跨域的程度了;
cross-document messaging: HTML5新增了一些很强大的API,cross-document messaging API就是其中之一, 它允许不同的document之间的js进行通讯;





Chapter 14 - The Window Object
Timers:
setTimeout(): 延时触发;
setInterval(): 定时循环执行;
clearTimeout(): 清除延时触发;
clearInterval(): 清除定时循环;


Location:
window.location === document.location 两者皆为当前页面url, 并随页面url变化而更新;
document.URL 也是指代加载后的当前页面, 但不随页面内动态变化引起的url变化而变化;
Location这个对象本身包含了多个属性分别指代url的不同部分:protocol表示网络协议, host, hostname通常都指示域名,前者包含端口, port表示端口, pathname表示以域名根目录为/的相对路径, search表示url中?以后的部分但不包含hash部分, hash则是表示url#以后的部分;
Location还包含了三个常用的函数:assign(),replace(),reload(), 其中前两者功能都一样, 都是用以加载新页面的, 不过replace()加载的同时将当前页面从history中去除了(就是不能后退后之前页面了), 而assign()还保留着; reload()就更不用说了, 只是单纯的重载页面;


History:
back(),forward(): 等价于浏览器的后退,前进按钮;
go(n): 接受数字作为参数, 表示向前或者后退n个页面;
如果页面中有iframe, 那么其history会自动合并到主界面的history中;


Navigator:
appName: 浏览器的名称;
appVersion: 浏览器版本号;
userAgent: 用户代理, 对应HTTP的USER-AGENT;
platform: 操作系统;
onLine: 是否连通网络, HTML5支持;
geolocation: 用户地理位置信息, HTML5支持;
javaEnabled(): 对Java扩展的支持, 非标准;
cookiesEnabled(): 能够设置cookie, 非标准;


Screen:
width,height: 当前屏幕的长宽尺寸;
availWidth,availHeight: 去除功能区等部分之后的实际展现内容的屏幕尺寸;
colorDepth: 显示屏幕的bits-per-pixel;


Dialog Boxes:
alert(): 弹出对话框, 展示传入的信息;
confirm(): 自带OK,Cancel按钮的对话框, 返回对应的boolean值;
prompt(): 附带输入框, 返回输入的值;
上述三个类型的对话框的样式结构都无法调整, 是浏览器默认设定的;
showModalDialog(): 则更加复杂, 它可以支持弹出一个页面, 其接受的第一个参数即为页面的url, 后面的参数则是弹出窗口的属性; 在chromium中已经被禁止了


onerror handler:
用于处理错误信息的, 你完全可以定制这个函数来更好的显示js中的错误信息;


Document Elements As Window Properties:
当一个html元素被赋予了id时, 其id对应名称的全局变量不存在时, 其自动转为全局变量, 属性名称即为id名, 但如果id名已经被使用, 则不生效;
对于&amp;lt;a&amp;gt; &amp;lt;applet&amp;gt; &amp;lt;area&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;form&amp;gt; &amp;lt;frame&amp;gt; &amp;lt;frameset&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;img&amp;gt; &amp;lt;object&amp;gt;这样的元素, 其name值和id效果是一样的, 且name值支持多个元素相同, 会自动生成类array形式, 对于iframe, 对应的属性会指向其内嵌窗口的window对象;


Multiple Windows and Frames:
通过js打开的新窗口都可以被js获取到, 并进行操作, 但是需要符合same-origin的原则;
frame嵌入的窗口可以通过parent.frames属性来获取, 也可以通过其自带的contentWindow来获取;



谜题
Q: 在测试same-origin的时候, 发现有些网站可以设定子域名的document.domain为母域名, 有些不能? 比如在google的搜索结果页, 就可以, 但是在github pages中想要设置为github.io就不可以, 会出现&amp;#39;github.io&amp;#39; is a top-level domain.这样的错误?

参考资料
JavaScript the Definitive Guide 6th edition
Can I Use …
host and hostname

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (1)</title><link>http://taoalpha.me/blog/2015/06/17/read-reading-javascript-the-definitive-guide-1/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-17T10:00:00.000Z</pubDate><description>概述“JavaScript: the definitive guide”可谓是JS入门必读数目之一了. 今天正好读到第7章, 做一简单总结. 前7章的内容都集中在JS中的基本知识上, 包含了:

数据类型: 最简单的primitive datatypes: string, number, boolean , 两个空值类型: null, undefined(通常认为空值类型属于promitive的一种),以及稍微复杂点的: object类型;
变量问题: 变量规则, 变量作用域问题;
基础表达式和操作符: 操作符的优先级问题, 多操作数和单操作数以及执行顺序等;
陈述语句: 包含了if/for/while/do/with/switch(case)/break/continue/return/var/identifiers/empty statement等等;
Object: json格式object以及常规的array类型对象的分别介绍以及自身结构属性, 异同点等;

心得break/continue 后接 label:  break/continue是通常用于for/white/do等循环语句中用以做状态判断的, 但本身其还有另一种用法, 就是通过后接标记语句的用法来是break或者continue能针对标记语句操作, 比如下面这个跳出多层嵌套的例子:
12345678910test:&amp;#123;  for(var i = 0; i&amp;lt; 10; i++)&amp;#123;    for(var j = 0; j&amp;lt; i*5; j++)&amp;#123;      console.log(j);      if(j==3) break test;    &amp;#125;  &amp;#125;&amp;#125;// continue test; 也是同样的用法
但需要注意的即使:

continue 语句(带有或不带标签引用)只能用在循环中;
break 语句(不带标签引用),只能用在循环或 switch 中;

with 语句在js中经常涉及到变量作用域的问题, 而with语句的存在就是可以将某个object放入到其子语句的作用域链中, 什么意思呢? 首先通常来说, 在函数内, 其作用域链由全局作用域(全局对象)和本地作用域(local对象)组成, 我们在引用变量的时候就是在作用域链上逐个查询. 而with的作用就是把某个object插入到作用域链中去, 从而能够直接访问其子元素:
1234567891011a = &amp;#123;&quot;nae&quot;:&quot;hhh&quot;,&quot;test&quot;:&quot;results&quot;&amp;#125;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;nae = &quot;sl&quot;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;// 证明with引入的作用域甚至还在global域之上
不过呢, 通常很少人会去用with的, 因为它过于吃力不讨好了, 其对性能的影响是没有什么优化空间的, 与其使用with, 不如直接定义全局变量或者变量的简写(有一种with的用法是为了省略书写冗长的变量名)更为方便了.
sort内嵌比较函数:sort()本身作为array类型内置的几个函数之一, 默认通常是按照字母表来排序的, 但是其本身也是支持自定义排序规则的, 只需要我们把规则传入即可:
12345678910// 以数字序列为例var a = [12,3,5,8]a.sort()// output: [12,8,5,3]a.sort(function(a,b)&amp;#123;return a - b;// 返回&amp;lt;0, 则a排在b前面, &amp;gt;0 则b在前面, =0则表示相等;&amp;#125;)// output: [3,5,8,12]
利用这一方法你就可以定制你的排序规则了, 甚至可以按照奇偶性排序都可以做到~ 比如 偶数在前: return a % 2-b % 2; 哈哈
concat,slice,splice这三个函数分别都是对array类型的元素进行母串增减获取子串而出现的, 其中有几点需要注意的:

concat()函数支持数字多参数分别传入, 也支持数组传入的形式, 效果都是一样的, 但是concat()不支持递归解套, 即如果你传入的是多层嵌套的数组, concat()只会解套一次; 此外, concat()的操作是不影响母串的;
slice和splice都可以用于获取子数组使用的, 其区别主要有两点, slice()接受的两个参数都代表的是index, 分别是起始次序到终止元素次序, 取子串时计算首位参数的元素,不计算第二位参数所代表的元素, 而splice则传入的两个参数分别是起始元素次序和要截取元素个数,即同样都是(1,2), 后者代表截取第二个元素起始共计两个元素的子串, 前者则只获取第二个元素; 此外, slice()返回子串而不修改原数组, splice()则会在返回子串的同时修改原数组(原数组为去除子串的结果);
splice()除了可以用获取子串外, 还能用于给母串添加元素. splice()可以接受超过2个参数, 从第三个参数起, 多出来的参数都是作为插入元素的, 执行的顺序则是删减完后当前位置插入, 即splice(2,2,1,3,4)表示的就是删掉第三个元素开始共计两个元素, 然后在同样的位置插入1,3,4三个元素, 同时, splice()也接受数组传入, 但是它不主动进行解套;

除了splice(), 上面的sort()的操作也是针对a数组进行的操作, 其结果也是针对a生效的, 即a的值是会被改变的;
pop,push,shift,unshift除了splice()之外, 我们通常用于直接操作母串增减的就是pop,push,shift,unshift四个了, 下面简单介绍下四者的区别:

pop, push分别代表对母串最后一个元素的进出栈操作, pop是弹出最后一个元素, push则是在最后一个元素的后面继续压入新元素, 同样也支持数组元素压入, 但是不自动解套;
shift, unshift和pop,push基本类似, 不同的地方在于操作的位置和后者相反, 是在栈头的位置, 即首位元素处; shift用于移出首位元素, unshift用于在首位增加元素, 接受数组, 也不自动解套, 同时多参数传入时, 作为整体一次性压入, 即unshift(2,3),压入后为[2,3,...].

这里比较独特的就是unshift多参数的压入问题了, 按我的预期其实是逐个元素压入, 这样顺序就是和传参相反, 但结果确实整体压入, 顺序与传参一致了~
谜题书中第七章介绍说在array中如果直接赋值的index是超限(&amp;gt;2^32-1), 负值或者对应表达式的结果是此类值时, 会自动转为string传入定义, 这就引发了一个问题: 一旦如此定义后, 此变量还是array吗?
我在console中简单的测试了下:
1234567891011121314151617181920var a = [1,2,3]// a.length == 3a[-1.2] = &quot;hehe&quot;a// output: [1,2,3]  where is a[-1.2] ?a[-1.2]// output: &quot;hehe&quot;  WTF???a.length// output: 3 ??console.log(a)// output: [1,2,3,-1.2:'hehe']console.log(a.length)// output: 3a instanceof Array// ouput: Truea[&quot;h&quot;] = &quot;hh&quot;a// output: [1,2,3]console.log(a)// output: [1,2,3,-1.2:&quot;hehe&quot;,h:&quot;hh&quot;]
问题: a依然还是一个Array(亦或者不是?), 但用json定义的方式赋值的那几个值还是有效的, 可获取的, 但是为什么直接print出来的时候没有这些值呢, 甚至长度都不包含定义的这几个指? 为什么console.log()可以打出来呢?
猜测解释: a最初被定义为array, 但是却被json方式传值, 存储到了其内存中, 但是调用a时依然按照array来打印, 所以会自动滤除掉不符合array的几个值(只会按照index来找值). 但是console.log()是打出来其存储内容, 所以就按照其内存存储形式打印出来了.
</description><source>TaoAlpha</source><author>TaoALpha</author></item></channel></rss>