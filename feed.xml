<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TaoAlpha's Blog</title><link>http://taoalpha.me/blog</link><pubDate>2016-01-09T04:38:57.619Z</pubDate><description></description><language>en</language><generator>hexo</generator><item> <title>OJ LeetCode Sort 3</title><link>http://taoalpha.me/blog/2016/01/06/oj-oj-leetcode-sort-3/</link><category>OJ</category><tag>LeetCode,OJ,Sort</tag><pubDate>2016-01-07T03:23:37.000Z</pubDate><description>324. Wiggle Sort IIQuestionGiven an unsorted array nums, reorder it such that nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]….
Example:(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6].(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].
Note:You may assume all input has valid answer.
Follow Up:Can you do it in O(n) time and/or in-place with O(1) extra space?
LeetCode324. Wiggle Sort II
Tags: medium, sort
AnswersSort and insertAfter several examples, you will find a pretty clear relation between the output and the input: all the small numbers will follow by a larger number. So how about we sort the list first and insert smaller half of the list into the larger half.
12345678910111213/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;void&amp;#125; Do not return anything, modify nums in-place instead. */var wiggleSort = function(nums) &amp;#123;    nums.sort( (a,b)=&amp;gt;&amp;#123;return a-b&amp;#125;)    var mid = Math.floor(nums.length / 2)    var left = nums.splice(0,mid+1)    for(var i = 0,j=0;i&amp;lt;=mid;i++)&amp;#123;        nums.splice(j,0,left[i])        j += 2    &amp;#125;&amp;#125;;
T: O(n^2) - since the splice is O(n) too, S: O(1) - though we store half of the list, but all we use is n space in total all the time
One disadvantage of this method is that it alwasy has a result even when there should not be one. But since the question said we can assume all input has valid answer…so..
Sort and ReplaceNow we use a little more space to speed up our answer.
12345678910111213141516/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;void&amp;#125; Do not return anything, modify nums in-place instead. */var wiggleSort = function(nums) &amp;#123;    var sorted = nums.slice(0).sort( (a,b) =&amp;gt; &amp;#123;return a-b&amp;#125;);    // copy the origin list and sort the copy-list as sorted    var mid = Math.ceil(nums.length / 2),i=0,p=0    // mid is the start index of large half    for(; i &amp;lt; sorted.length; i++)&amp;#123;        if(i % 2 === 0) nums[i] = sorted[p++];        // start with small number -&amp;gt; all index with even number should be smaller number(start from 0)        else nums[i] = sorted[mid++];        // all index with odd number should be larger number, use large half of the sorted list    &amp;#125;&amp;#125;
T: O(n), S: O(n)
164. Maximum GapQuestionGiven an unsorted array, find the maximum difference between the successive elements in its sorted form.
Try to solve it in linear time/space.
Return 0 if the array contains less than 2 elements.
You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
leetcode164. Maximum Gap
Tags: Sort, Hard
AnswersBucket SortWe still need use sort, question is which sort we should choose. Since required linear time/space, we have to use bucket sort, and the core problem would be how to decide the number of buckets we want to set. 
According to the Pigeonhole principle, the maximumGap &amp;gt;= (max_value - min_value) / (len - 1), so we use this minMaxGap as our number of buckets (to make sure that the distribution of our numbers in different buckets are as equal as possible).
1234567891011121314151617181920212223242526272829303132/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;number&amp;#125; */var maximumGap = function(nums) &amp;#123;  if(nums.length &amp;lt; 2) return 0  var min = Math.min.apply(Math,nums)  var max = Math.max.apply(Math, nums)  var bucketCount = Math.ceil((max - min) / (nums.length - 1))  var buckets = []  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var remain = Math.floor((nums[i] - min) / bucketCount);    if(!buckets[remain]) buckets[remain] = []    buckets[remain].push(nums[i]);  &amp;#125;  var sorted = []  for(i = 0;i&amp;lt;buckets.length;i++)&amp;#123;    if(buckets[i])&amp;#123;      buckets[i].sort( (a,b)=&amp;gt;&amp;#123;return a-b&amp;#125;)      sorted = sorted.concat(buckets[i])    &amp;#125;  &amp;#125;    var maxGap = 0  for(i = 1; i&amp;lt; sorted.length;i++)&amp;#123;    if(sorted[i]-sorted[i-1] &amp;gt; maxGap)&amp;#123;      maxGap = sorted[i] - sorted[i-1]    &amp;#125;  &amp;#125;  return maxGap&amp;#125;
Runtime: 240 ms
Bucket Sort Speed UpIn the above answer, we sorted the list using bucket sort and insertion sort, then calculate the maxGap among all these numbers. But actually we don’t need sort the list, we only need to calculate the distance between the min of next bucket and the max of previous bucket, the maxGap must be the max of them, also since we only the max and min of the bucket, we don’t even need to store all the numers in the bucket, we just store the max and min.
123456789101112131415161718192021222324252627282930313233343536/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;number&amp;#125; */var maximumGap = function(nums) &amp;#123;  if(nums.length &amp;lt; 2) return 0  var min = Math.min.apply(Math,nums)  var max = Math.max.apply(Math, nums)  var bucketCount = Math.ceil((max - min) / (nums.length - 1))  if(bucketCount == 0) bucketCount = 1  // deal with cornercase like [1,1]  var buckets = &amp;#123;&amp;#125;  for(var i = 0;i&amp;lt;nums.length;i++)&amp;#123;    var remain = Math.floor((nums[i] - min) / bucketCount);    if(!buckets[remain])&amp;#123;      buckets[remain] = &amp;#123;&amp;#125;      buckets[remain].max = buckets[remain].min = nums[i];    &amp;#125;else&amp;#123;      if(nums[i] &amp;gt; buckets[remain].max)&amp;#123;        buckets[remain].max = nums[i]      &amp;#125;      if(nums[i] &amp;lt; buckets[remain].min)&amp;#123;        buckets[remain].min = nums[i]      &amp;#125;    &amp;#125;  &amp;#125;  var maxGap = 0,preMax = null  for(i in buckets)&amp;#123;    if(preMax &amp;amp;&amp;amp; (buckets[i].min - preMax &amp;gt; maxGap))&amp;#123;      maxGap = buckets[i].min - preMax    &amp;#125;    preMax = buckets[i].max  &amp;#125;  return maxGap&amp;#125;
Runtime: 168 ms
56. Merge IntervalsQuestionGiven a collection of intervals, merge all overlapping intervals.
For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18].
leetcode56. Merge Intervals
Tags: Sort, Array, Hard
AnswersSort by startFirst, we sort the intervals by the start of each interval, then we compare the start and end of adjacent intervals, merge if there is overlap or push the previous merged or independent interval to the final output.
12345678910111213141516171819202122232425262728293031/** * Definition for an interval. * function Interval(start, end) &amp;#123; *     this.start = start; *     this.end = end; * &amp;#125; *//** * @param &amp;#123;Interval[]&amp;#125; intervals * @return &amp;#123;Interval[]&amp;#125; */var merge = function(intervals) &amp;#123;  if(intervals.length &amp;lt; 1) return []  // special condition  var output = []  intervals.sort( (a,b) =&amp;gt; &amp;#123;return a.start - b.start&amp;#125;)      // sort by the start  var prev = intervals[0]  for(var i = 1;i&amp;lt;intervals.length;i++)&amp;#123;    if(prev.end &amp;gt;= intervals[i].start)&amp;#123;      prev = new Interval(Math.min(prev.start,intervals[i].start),Math.max(prev.end,intervals[i].end))      // merge, need to consider several corner case, make sure the start of new interval is the min of two start, and the end should be the max    &amp;#125;else&amp;#123;      output.push(prev)      prev = intervals[i]    &amp;#125;  &amp;#125;  output.push(prev)  // push the last merged or leftover interval into the output  return output&amp;#125;;
Runtime: 200 ms
This one is pretty easy with a hard tag… can not understand why…
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Sort 2</title><link>http://taoalpha.me/blog/2016/01/05/oj-oj-leetcode-sort-2/</link><category>OJ</category><tag>LeetCode,OJ,Sort</tag><pubDate>2016-01-05T21:29:58.000Z</pubDate><description>147. Insertion Sort ListQuestionSort a linked list using insertion sort.
LeetCode147. Insertion Sort List
Tag: sort,medium
AnswerInsertion sort as required.
12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; head * @return &amp;#123;ListNode&amp;#125; */var insertionSortList = function(head) &amp;#123;  if(head == null || head.next == null)&amp;#123;return head&amp;#125;  var helper = new ListNode(-1) // need a helper node to insert the smallest node into the head of the listNode  var outer = head // outer loop, the node that would be inserted into proper position  var inner = helper // inner loop, the node that outer node should be inserted after  var next = head // next loop node  while(outer)&amp;#123;    // store the next node of the outer =&amp;gt; for next loop    next = outer.next    // find the proper position that the outer node should inserted into    while(inner.next &amp;amp;&amp;amp; inner.next.val &amp;lt; outer.val)&amp;#123;      inner = inner.next    &amp;#125;    // insert    outer.next = inner.next    inner.next = outer    // start over every outer loop    inner = helper    // loop for next    outer = next  &amp;#125;  return helper.next&amp;#125;;
Runtime: 236 ms
274. H-IndexQuestionGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.
According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”
For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.
Note: If there are several possible values for h, the maximum one is taken as the h-index.
LeetCode274. H-Index
Tag: sort,medium
AnswersSort firstFirst, we need know that the return value would be one between 0 and the length of the list.
Then, according to the definition of h-index, what we need is the max h that has at least h papers has a referrence number greater than h.
So we sort the list first, and then loop the list reversely, try to find the max fit value that let the number of papers left in the list = length - index &amp;lt;= citations[index]
1234567891011121314151617/** * @param &amp;#123;number[]&amp;#125; citations * @return &amp;#123;number&amp;#125; */var hIndex = function(citations) &amp;#123;  if(citations.length&amp;lt;=0)&amp;#123;return 0&amp;#125;  var sorted = citations.sort((a,b)=&amp;gt;&amp;#123;return a - b&amp;#125;)  // sort in javascript is a in-place function, you don't need use another array  // default sort function compare everything as a string  var h_index = 0  for(var i = sorted.length;i&amp;gt;=0;i--)&amp;#123;    if(sorted.length - i &amp;lt;= sorted[i])&amp;#123;      h_index = Math.max(h_index,sorted.length-i)    &amp;#125;  &amp;#125;  return h_index&amp;#125;;
Runtime: 152 ms
HashtableSince we use sort, the time comlexity would be O(nlogn) or even worse. We can use hashtable to speed up.
We store all the citations into one table as a ‘value-count’ pair, and store all value greater that length of the list into one place, since the h-index could only be the value between 0 to the length.
Now we have all possible h-indexs, what we need is to find the max fit one, the only fit rule is that the number of papers that have a referrence greater than h is greater or equal to h.
123456789101112131415161718192021222324/** * @param &amp;#123;number[]&amp;#125; citations * @return &amp;#123;number&amp;#125; */var hIndex = function(citations) &amp;#123;  if(citations.length&amp;lt;=0)&amp;#123;return 0&amp;#125;  var countTable = &amp;#123;&amp;#125;  for(var i = 0;i&amp;lt;citations.length;i++)&amp;#123;    var key = citations[i]    if(citations[i] &amp;gt;= citations.length)&amp;#123;      key = citations.length    &amp;#125;    countTable[key] = countTable[key] || 0    countTable[key] ++   &amp;#125;  var sum = 0  for(h = citations.length;h&amp;gt;=0;h--)&amp;#123;    sum += countTable[h] || 0    if(sum &amp;gt;=h)&amp;#123;      return h    &amp;#125;  &amp;#125;  return 0&amp;#125;;
Runtime: 152 ms
179. Largest NumberQuestionGiven a list of non negative integers, arrange them such that they form the largest number.
For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.
Note: The result may be very large, so you need to return a string instead of an integer.
LeetCode179. Largest Number
Tag: sort,medium
AnswerConsider all elements as string instead of number would solve this problem, can not use the default sort, because default sort would compare the each character, so ‘9’ would be smaller that ‘96’, we need to define the sort function by ourselves.
Also need to consider about some corner cases: start with 0.
123456789/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;string&amp;#125; */var largestNumber = function(nums) &amp;#123;  return nums.sort( (a,b)=&amp;gt;&amp;#123;return (b + '' + a) - (a + '' + b)&amp;#125;).join(&quot;&quot;).startsWith(&quot;0&quot;) ? &quot;0&quot; : nums.sort( (a,b)=&amp;gt;&amp;#123;return (b + '' + a) - (a + '' + b)&amp;#125;).join(&quot;&quot;)  // return nums.sort( (a,b)=&amp;gt;&amp;#123;return (b + '' + a) - (a + '' + b)&amp;#125;).join(&quot;&quot;).replace(/^0*/g,'') || &quot;0&quot;  // also we can remove all the leading 0s and it will be empty string then we can just return 0&amp;#125;
Runtime: 176 ms
You can also use radix sort, and combine each bucket before other buckets, but the code would be very complex.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>OJ LeetCode Sort 1</title><link>http://taoalpha.me/blog/2016/01/04/oj-oj-leetcode-sort-1/</link><category>OJ</category><tag>LeetCode,OJ,Sort</tag><pubDate>2016-01-04T08:42:13.000Z</pubDate><description>AsideThis is a new category special for coding practice. I will use this category record all the coding problems I met and solved or unsolved.
And of course, all answers I list will be written in JavaScript :)
242. Valid Anagramtag: sort, easy
QuestionGiven two strings s and t, write a function to determine if t is an anagram of s.
For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false.
Note:You may assume the string contains only lowercase alphabets.
Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case?
LeetCode242. Valid Anagram
AnswersHashTable1234567891011121314151617181920212223/** * @param &amp;#123;string&amp;#125; s * @param &amp;#123;string&amp;#125; t * @return &amp;#123;boolean&amp;#125; */var isAnagram = function(s, t) &amp;#123;  var letterMap = &amp;#123;&amp;#125;  s.split('').forEach( (v) =&amp;gt;&amp;#123;    letterMap[v] = letterMap[v] || 0    letterMap[v] ++  &amp;#125;  t.split('').forEach( (v) =&amp;gt;&amp;#123;    letterMap[v] = letterMap[v] || 0    letterMap[v] --  &amp;#125;  for(var i in letterMap)&amp;#123;    if(letterMap[i] != 0)&amp;#123;      return false    &amp;#125;  &amp;#125;  return true&amp;#125;// should be O(n) both for time complexisity and space complexity
Pass the online judge, Runtime: 212 ms.
sort12345678/** * @param &amp;#123;string&amp;#125; s * @param &amp;#123;string&amp;#125; t * @return &amp;#123;boolean&amp;#125; */var isAnagram = function(s, t) &amp;#123;  return s.split('').sort().join(&quot;&quot;) == t.split(&quot;&quot;).sort().join(&quot;&quot;)&amp;#125;
Pass and the run time is : 180-200 ms
The runtime of javascript is so unstable, seems that they actually run the code in user’s browser :)
I guess these two methods are most common ways to solve this easy problem. I looked at the dicuss and didn’t find any new ways, so I guess that’s it.
About how to deal with the unicode. I tested it under nodejs, and the default sort function can handle the unicode by itself :) And also even it can not, we can also encoding it and save the unicode as a string and do it like the normal english letter.
75. Sort Colorstag: sort, medium
QuestionGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note:You are not suppose to use the library’s sort function for this problem.Modify the nums in-place.
Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.
Could you come up with an one-pass algorithm using only constant space?
LeetCode75. Sort Colors
AnswersSort123456789101112131415161718/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;void&amp;#125; Do not return anything, modify nums in-place instead. */var sortColors = function(nums) &amp;#123;  // insertion sort  for(var i = 1;i&amp;lt;nums.length;i++)&amp;#123;    var temp = nums[i]    for(var j=i-1; j&amp;gt;=0;j--)&amp;#123;      if(temp&amp;lt; nums[j])&amp;#123;        nums[j+1] = nums[j]      &amp;#125;else&amp;#123;        break      &amp;#125;    &amp;#125;    nums[j+1] = temp  &amp;#125;&amp;#125;;
Runtime: 152 ms
123456789101112131415161718/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;void&amp;#125; Do not return anything, modify nums in-place instead. */var sortColors = function(nums) &amp;#123;  // counting sort  var bucket = [0,0,0]  nums.forEach( (v) =&amp;gt; &amp;#123;    v == 0?bucket[0]++ : v == 1 ? bucket[1]++ : bucket[2] ++  &amp;#125;)  var j = 0  bucket.forEach( (v,i) =&amp;gt;&amp;#123;    while(v&amp;gt;0)&amp;#123;      nums[j++] = i      v--    &amp;#125;  &amp;#125;)&amp;#125;;
Runtime: 152 ms
One passMove all 0s to the head of the array and all 2s to the tail, using unshift() and push().
12345678910111213141516/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;void&amp;#125; Do not return anything, modify nums in-place instead. */var sortColors = function(nums) &amp;#123;  var len = nums.length  for(var i = 0;i&amp;lt;len;i++)&amp;#123;    if(nums[i] == 0)&amp;#123;      nums.unshift(nums.splice(i,1)[0])    &amp;#125;else if(nums[i] == 2)&amp;#123;      nums.push(nums.splice(i,1)[0])      i--      len --    &amp;#125;  &amp;#125;&amp;#125;;
runtime: 160ms
Same idea but using swap instead of unshift() and push().
123456789101112131415161718192021/** * @param &amp;#123;number[]&amp;#125; nums * @return &amp;#123;void&amp;#125; Do not return anything, modify nums in-place instead. */var sortColors = function(nums) &amp;#123;  var head = 0,tail = nums.length-1  for(var i = 0;i&amp;lt;=tail;i++)&amp;#123;    if(nums[i] == 0)&amp;#123;      var temp = nums[i]      nums[i] = nums[head]      nums[head] = temp      head ++    &amp;#125;else if(nums[i] == 2)&amp;#123;      var temp = nums[i]      nums[i] = nums[tail]      nums[tail] = temp      tail --      i --    &amp;#125;  &amp;#125;&amp;#125;;
Runtime : 156ms
148. Sort Listtag: sort, medium
QuestionSort a linked list in O(n log n) time using constant space complexity.
LeetCode148. Sort List
Answersconstant space =&amp;gt; in-placeO(nlogn) =&amp;gt; quick-sort(worst O(n^2)),merge-sort
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Definition for singly-linked list. * function ListNode(val) &amp;#123; *     this.val = val; *     this.next = null; * &amp;#125; *//** * @param &amp;#123;ListNode&amp;#125; head * @return &amp;#123;ListNode&amp;#125; */var sortList = function(head) &amp;#123;   // merge sort    // deal with the one node situation   if(head == null || head.next == null)&amp;#123;return head&amp;#125;   return mergeSort(head, null);&amp;#125;;var mergeSort = (head,tail) =&amp;gt; &amp;#123;  if(head.next == tail)&amp;#123;    head.next = null    return head  &amp;#125;  var middle = findMiddle(head,tail)  var left = mergeSort(head,middle)  var right = mergeSort(middle,tail)  return merge(left,right)&amp;#125;var merge = (left,right) =&amp;gt;&amp;#123;  var head = new ListNode(-1), node = head  while(left != null &amp;amp;&amp;amp; right != null)&amp;#123;    if(left.val &amp;lt; right.val)&amp;#123;      node.next = left      node = left      left = left.next    &amp;#125;else&amp;#123;      node.next = right       node = right      right = right.next    &amp;#125;  &amp;#125;  var remail = null  if(left == null &amp;amp;&amp;amp; right != null)&amp;#123;    remail = right  &amp;#125;else if(left != null &amp;amp;&amp;amp; right == null)&amp;#123;    remail = left  &amp;#125;  node.next = remail  return head.next&amp;#125;var findMiddle = (head,tail) =&amp;gt;&amp;#123;  // find the middle node given the head and tail  var slow = head,fast = head  tail = tail || null  while(fast != tail)&amp;#123;    fast = fast.next    if(fast != tail)&amp;#123;      fast = fast.next    &amp;#125;    slow = slow.next  &amp;#125;  return slow&amp;#125;
Runtime: 252 ms
Didn’t try quick sort, but according to the discuss of this problem, seems it doesn’t work(will TLE, maybe because of the worst case), and the code would be very complex.
ghat’s it. Everytime I solve several problems, I will post on this blog under the OJ category. :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Blur on Background</title><link>http://taoalpha.me/blog/2015/12/31/tech-blur-on-background/</link><category>tech</category><tag>Blur,CSS3</tag><pubDate>2015-12-31T08:09:10.000Z</pubDate><description>Today I finally made my first angularJS app which is a simple todo app connected with my First nodejs cli tool: baby. They share the same data set, so you can think it as the UI for baby todo part (I will build the UI for other nice features, one by one).
I really like the interface of the Papaly, especially the speed dial dashboard !! So I also use a large image and the crystal blur block on my design, here I just want to share something with you :)
BlurBlur is quite popular in Web Design, you can see them all the time. But how we do that from the point of coding part ? Before CSS3 introduced the filter, people just modify the images manually and make them blur before actually use them in the design, and now we have CSS3, we can just use filter.
We all know make a image blur is pretty simple, but how we make part of image blur, and even more, how we make part of image blur be dynamic ? This is what I gonna talk about today :)
Without CSS3Let’s do it old fashion first. You want create a box within which all background image should be blur, and also the box may move to any place or even can be moved by users. How to do that? Quite simple, we can use two images, one is normal, the other is blur one. 
Then what you should know is background-attachment which adds the magic.
12345678910111213141516171819202122232425262728293031323334353637383940/* background-attachment can specify the position of the background image * fixed : the background is fixed with regard to the viewport, so it won't move with the element * background-attachment: fixed; * background-size:100%; * keep size 100% to fit the viewprot */html,body&amp;#123;  width:100%;  height:100%;  margin:0px;&amp;#125;.imgBlur&amp;#123;  width:100%;  height:100%;  margin:auto;  background-image:url(&quot;http://www166.lunapic.com/editor/premade/o-blur.gif&quot;);// image without blur  background-size:100%;&amp;#125;div.blurBox&amp;#123;  width:50%;  margin:auto;  height:200px;  color:white;  padding:30px;  text-align:center;  display:table;&amp;#125;div.blurBox.withoutcss3&amp;#123;  background-attachment:fixed;  background-size:100%;  background-image:url(http://www166.lunapic.com/editor/premade/blur.gif);// image with blur   display:none;&amp;#125;.blurBox span&amp;#123;  display:table-cell;  vertical-align:middle;&amp;#125;
With CSS3With CSS3, we don’t need the second image, we can just use blur.
123456789101112131415161718192021/* z-index is to make sure the content of the box won't be blur */div.blurBox.withcss3&amp;#123;  z-index:1;&amp;#125;div.blurBox.withcss3:before&amp;#123;  width:100%;  display:block;  content:&quot; &quot;;  height:100%;  background-image:url(http://www166.lunapic.com/editor/premade/o-blur.gif);  // now we don't need blur image  background-attachment:fixed;  // still need this since we need use the blur on the image  position: absolute;  background-size:100%;   -webkit-filter: blur(3px);  filter:blur(3px);  z-index:-1;&amp;#125;
Here is the demo I made with codepen:
See the Pen LGbajd by taoalpha (@taoalpha) on CodePen.


Advance SkillsPretty cool ha! Combine with before and after and other cool stuffs,  you can achieve a lot amazing effects, even this one : Depth of field effect with SVG filters
See the Pen Depth of field effect with SVG filters by Vaughan Curd (@vcurd) on CodePen.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Related Articles and generate API files in Hexo</title><link>http://taoalpha.me/blog/2015/12/27/tech-related-articles-and-generate-api-files-in-hexo/</link><category>tech</category><tag>hexo,js,related article</tag><pubDate>2015-12-28T01:54:43.000Z</pubDate><description>Why?Since I have migrated my entire blog to hexo, so I need to rewrite a lot modules :) Today we talk about related articles and how to generate api files in your hexo blog.
HowRelated ArticlesUnlike jekyll, hexo doesn’t have a built-in module to populate the related articles (meanwhile, jekyll’s built-in related articles are sucks, so many people build themselves, I did once before, you can check this Optimize jekyll(in chinese) if you want.), so I have to write one for myself.
The idea is pretty simple and similiar with last one I did for jekyll, use the tag to compare different posts, it they have some common tags, they should be similiar, or related.
So I query the post according to current post’s category and get all posts with same category as current one, then for each post, I compared its tags with current post’s, if there is some intersect between them, I will count it as a related article to current post.
The code is simple too(written in jade):
1- var posts = []&amp;#10;- if(page.categories)&amp;#123;&amp;#10;-   var cat = page.categories.toArray()[0].name&amp;#10;-   var existTags = page.tags.toArray().map(function(v)&amp;#123;return v.name&amp;#125;)&amp;#10;-   var prePosts = site.categories.findOne(&amp;#123;name: cat&amp;#125;).posts&amp;#10;-   if(prePosts.toArray().length&amp;#62;0)&amp;#123;&amp;#10;-     var someCatPosts = prePosts.sort(&amp;#39;date&amp;#39;, -1).toArray()&amp;#10;-     someCatPosts.forEach(function(v)&amp;#123;&amp;#10;-       var tags = v.tags.toArray().map(function(t)&amp;#123;return t.name&amp;#125;).filter(function(n)&amp;#123;return existTags.indexOf(n)!=-1&amp;#125;)&amp;#10;-       if(tags.length&amp;#62;0 &amp;#38;&amp;#38; posts.length &amp;#60; 5 &amp;#38;&amp;#38; v.permalink != page.permalink)&amp;#123;&amp;#10;-         posts.push(v)&amp;#10;-       &amp;#125;&amp;#10;-     &amp;#125;)&amp;#10;-   &amp;#125;&amp;#10;- &amp;#125;&amp;#10;if posts.length &amp;#62; 0&amp;#10;  div.relatedposts.sidenav&amp;#10;    h2= &amp;#34;Related Posts:&amp;#34;&amp;#10;    ul.article-list&amp;#10;      each post in posts&amp;#10;        li&amp;#10;          a(href=url_for(post.permalink))= post.title
API GeneratorSince I use static blog, I don’t have any tools or modules like php to deal with post and get request, but what I can do is I can host json files with data I want to put in and treat it as a API(since most API just return a json with proper content), like I have latest.json to show the latest 10 posts of my blog, you can view it through this link.
Yup. This is the basic idea, and how to do it? We need build a plugin for hexo :)
A plugin for hexo is a normal module for node, so you need to define the package.json and the index.js, its totally fine that you only have one js file if you don’t need to deal with complicated logic things. But this time, I use two js files, the index.js would load the config from the hexo and assing the task to different generators. :)
And this is modified from the source code of hexo-generator-sitemap :)
Since they are using pretty much the same logic, I just remove the built-in modules: sitemap and feed generator, and combine them into one.
Here it is:
12345678910111213141516171819202122232425262728// this is the index.jsvar merge = require('utils-merge');var pathFn = require('path');// load the config from the hexo.config and combine them with some default configurationsvar config = hexo.config.api = merge(&amp;#123;  sitemap:&amp;#123;    src: &quot;sitemap.jade&quot;,    desc: &quot;sitemap&quot;,    path: &quot;sitemap.xml&quot;  &amp;#125;,  feed:&amp;#123;    src: &quot;feed.jade&quot;,    desc: &quot;feed&quot;,    path: &quot;feed.xml&quot;  &amp;#125;&amp;#125;, hexo.config.api);var gen = require('./lib/generator');// assign them to different generatorsfor(var item in config)&amp;#123;  (function(item)&amp;#123;hexo.extend.generator.register(item, function(locals)&amp;#123;    return gen(item,hexo.config,locals)  &amp;#125;)  &amp;#125;)(item)&amp;#125;
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// this is the ./lib/generator.jsvar jade = require('jade');var pathFn = require('path');var fs = require('fs');// main functions, current only deal with the latest posts if it is a json file task :)// if it is xml task, then it will render the default template ( sitemap.jade, feed.jade)module.exports = function(item,config,locals)&amp;#123;  var api = config.api  if(api[item].path.endsWith(&quot;json&quot;))&amp;#123;    var posts = locals.posts.toArray()      .sort(function(a, b)&amp;#123;        return b.updated - a.updated;      &amp;#125;);    var data = [],count = 0    posts.forEach( (post) =&amp;gt; &amp;#123;      if(count &amp;gt; (api[item].limit || 10))&amp;#123;        return      &amp;#125;      var temp = &amp;#123;&amp;#125;      post.date = new Date(post.date).toLocaleDateString()      api[item].attr.forEach( (v)=&amp;gt;&amp;#123;        if(v == &quot;summary&quot;)&amp;#123;          temp[v] = post.content.replace(/(&amp;lt;([^&amp;gt;]+)&amp;gt;)/ig,'').slice(0,200)        &amp;#125;else&amp;#123;          temp[v] = post[v]        &amp;#125;      &amp;#125;)      count ++      data.push(temp)    &amp;#125;)    data = JSON.stringify(data)  &amp;#125;else&amp;#123;    // for xml(now only support sitemap, feed since I only these two templates :)    var templateSrc= pathFn.join(__dirname, '../'+api[item].src);    var tmpl = jade.compile(fs.readFileSync(templateSrc, 'utf8'));    var posts = [].concat(locals.posts.toArray(), locals.pages.toArray())      .filter(function(post)&amp;#123;        return post.sitemap !== false;      &amp;#125;)      .sort(function(a, b)&amp;#123;        return b.updated - a.updated;      &amp;#125;);    var data= tmpl(&amp;#123;      config: config,      posts: posts    &amp;#125;);  &amp;#125;  return &amp;#123;    path: api[item].path,    data: data  &amp;#125;&amp;#125;
That’s it.
I love hexo!! I love JS!!! :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Raspberry Pi Setup</title><link>http://taoalpha.me/blog/2015/07/05/tech-raspberry-pi-setup/</link><category>tech</category><tag>Raspberry Pi,node,python,wifi</tag><pubDate>2015-07-05T11:00:00.000Z</pubDate><description>概述今天介绍下如何配置一个树莓派, 主要是一些树莓派的基本配置, 多数大家google以下也是可以找到的, 这里算是汇总了一下.
内容主要包括:

树莓派系统安装;
初始化配置;
nodejs环境配置;
python环境配置;
wifi环境配置;

树莓派的基础设定树莓派系统安装目前在树莓派的官网主要提供了两种安装系统的方式, 一种是直接烧制, 通过将已下载的img文件利用对应的工具烧制到格式化好的SD卡中, 制作出直接可用的启动盘; 另一种则是通过官方发布的NOOBS来进行启动安装.

直接制作法:
有过制作系统经验的朋友都应该了解这种方法, 不同平台也有不同的工具可以用以制作, 这里就没啥好说的了. mac下可以按照官网的Guide逐步操作即可.

NOOBS法:
NOOBS法其实并不是直接烧制一个好的系统进去, 而是一个类似winpe, 而且更简易的启动程序. NOOBS法分为2个版本, 一个是包含了十个左右的预装系统, 另一个则是单纯的NOOBS, 需要联网下载选择的系统进行安装; 通常做启动化设定的话, 用离线版的肯定比较省事~
下载完NOOBS后, 直接将NOOBS压缩包解压到你已经格式化好的SD卡上, 然后插入树莓派启动就能进入下面的就界面了:

选择你想要安装的系统, 选择install即可(此处可以选择多系统, 根据你的SD卡等具体情况即可).


那么如何选择呢? 对我而言, 很简单, 第一次安装的时候, 手头没有HDMI线, 那么没有屏幕的话, 用NOOBS的话无法操作, 所以就直接烧的系统, 这样就可以直接启动, 然后通过ssh配置即可; 后来因为玩坏了python, 怎么改都没改好,于是就决定重装, 而手头正好有HDMI线了, 所以这次就试用了下NOOBS, 觉得也很省事, 尤其是可以直接装多系统(我装了标准R和Arch)~
初始化配置一旦你安装好系统后, 就可以开始启动系统了. 插上电源, 插上SD卡即可. 因为无屏的情况居多, 所以下面就以无屏作为基本环境, 目前pi基本都默认开启了SSH, 所以我们可以直接通过ssh登录设定.

首先的首先, 你需要一个网线… 可以直接链接你的树莓派和路由器或者你的电脑;
首先, 你需要你pi的ip, 如此才能进行ssh登录: 这个很简单, 登录到你的路由器管理页面, 通过客户端列表查看你的树莓派被分配到的ip地址(如果你是直连笔记本的话, 记得设定你的笔记本网络分享,然后通过arp -a, windows下, 扫描出你的树莓派的分配ip即可);
连接, 找到ip后, 就可以通过ssh登录了, 默认的初始用户名和密码是: pi -&amp;gt; raspberry;
基本配置: 通过raspi-config命令就可以对树莓派做一些基本的配置, 比如内存分配啊, 超频啊, 修改密码,设定主机名啊等等, 其中超频(overclock)这部分大家要谨慎一些处理, 可以从低到高的逐步超频, 目前亲测B+下超频到turbo 1000的话基本还是毫无压力的, 而如果你不需要图形界面的话, 那么可以把GUI的内存分配到最低: 16;

nodejs以及python环境配置因为个人属性, 所以还是比较集中在node和python中, 像java等环境我就基本不管了. 下面介绍下node和Python在pi里面的配置:

nodejs
目前RASPBIAN 3.18下node还是不默认支持的, 需要我们手动安装, 主要有下面几个安装方式:

源码编译:
这种方法最为简单, 而且通常可以直接安装到最新版本, 从官网下载到源码包解压后自己./configure``make``make install就是漫长的等待了…至少半天吧… 毫不夸张..

预编译安装:
主要是因为node的编译时间太长…所以有人发布了编译好的版本可以直接下载使用, 具体可以参考此文: Download compiled version of Node.js 0.12.0 Stable for Raspberry Pi here.

包管理安装:
node官网还提供了如何通过包管理的方式来安装node, 详细的区分不同系统的可以看Installing Node.js via package manager~ RASPBIAN是基于debian的, 所以我们参考 debian 的话即可;

通过deb包安装:
此种方法也是个人比较推荐的, 简单易行. 目前node-arm中更新的最新deb包是0.12.1的版本. 基本也够用了~ 下载deb包后直接dpkg -i 包即可;


可能会出现的问题:

版本过低: 默认通过apt-get获取的node版本似乎只到0.6吧, 记不清了, 反正最多不过0.10, 此种情况下, 可以先执行apt-get update &amp;amp; apt-get upgrade等或者通过nodesource更新以下源;
illegal instruction: 有时候你安装了node之后, 可能会发现输入node命令都会提示illegal instruction, 此种问题主要是因为树莓派的cpu所致, 而且是V8的问题, 并非nodejs的问题, 具体的细节大家可以google了解下, 具体的解决办法呢, 我也不确定, 只知道我apt-get upgrade了以下后重启了下就ok了…


python
RASPBIAN 目前的python版本是多版本的, 包含了2.7.3和3.2, 而因为我通常的开发环境是2.7.6, 所以这里介绍下如何替换python的方法.

源码编译:
python相比nodejs而言要省时很多… 不过也很慢… 不推荐;

pythonbrew:
这里介绍一个很赞的办法: pythonbrew. 这是一个python管理工具, 它可以帮助你在多版本python下进行转换. 安装方法很简单: pythonbrew Github.
其中可能出现环境配置问题导致找不到bin/pythonbrew文件, 你可以通过手动将/usr/local/pythonbrew拷贝一份到~/.pythonbrew中即可解决;
安装后的使用非常便捷, 只需要利用pythonbrew install 版本号以及pythonbrew switch 版本号就能切换python版本了~



Tip: 除非迫不得已, 不要乱动系统的python版本;

结合virtualenv和pythonbrew, 你就可以实现独立的版本环境了~哈哈


wifi环境配置树莓派本身是没有无线网卡的, 所以如果想要让其支持无线上网的话, 你需要自己购买一个无线网卡接入, 并且安装对应的驱动.本人用的是realtek的无线网卡, 插入后通过lsusb查看到已经检测到设备后, 就可以通过apt-get install firmware-realtek安装配套的驱动.
当你通过ifconfig查看到wlan0的时候, 就证明你的无线网络支持已经可以了, 接下来就需要配置对应的无线属性了:
打开/etc/network/interfaces, 如果你喜欢vim, 可以通过apt-get install vim安装vim, 打开根据你的需要修改对应的属性: 比如wlan的ip分配是manualordhcp或者是static. 然后在对应wpa-conf的设定文件中添加对应的network即可:
1network=&amp;#123;&amp;#10;    ssid=&amp;#34;SCHOOLS NETWORK NAME&amp;#34;&amp;#10;    psk=&amp;#34;SCHOOLS PASSWORD&amp;#34;&amp;#10;    id_str=&amp;#34;school&amp;#34;&amp;#10;&amp;#125;&amp;#10;&amp;#10;network=&amp;#123;&amp;#10;    ssid=&amp;#34;HOME NETWORK NAME&amp;#34;&amp;#10;    psk=&amp;#34;HOME PASSWORD&amp;#34;&amp;#10;    id_str=&amp;#34;home&amp;#34;&amp;#10;&amp;#125;
如果你有多个无线网需要支持的话, 可以在其中添加多个network块即可;
开启root在上述命令中你会发现很多都需要sodu执行, 这是因为你默认使用的是pi账户, 而非root. 默认情况下root账户是关闭的, 需要你重新开启:
很简单, 给root设定一个密码即可:sudo passwd root, 同时如果你需要用root登录ssh的话, 请确保/etc/ssh/sshd_config中的PermitRootLogin yes.
总结树莓派可谓是极佳的学习硬件的工具, 其开放性极强, 扩展性极强, 它能做什么完全由你决定. 这里分享国内外几个不错的社区给大家:

极客范儿
PiWeekly
RasPi Tv
Raspberry Pi Beginner - Youtube Channel

参考资料
树莓派的官网
NOOBS GUIDE
Installing Node.js via package manager
Download compiled version of Node.js 0.12.0 Stable for Raspberry Pi here
node-arm
pythonbrew Github
Automatically connect a Raspberry Pi to a Wifi network
SETTING WIFI UP VIA THE COMMAND LINE

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Restore your database in Raspberry Pi from kernel panic error</title><link>http://taoalpha.me/blog/2015/10/14/tech-raspberry-pi-kernel-panic-data-restore/</link><category>tech</category><tag>Database,Raspberry Pi,Restore</tag><pubDate>2015-10-14T13:00:00.000Z</pubDate><description>BackgroundMy Raspberry Pi suddenly stopped running(connection lost when I was connecting with my pi through ssh) when I was doing something really normal(like modifying a file…) And then I tried to connect my pi with a screen and it showed the mysterious Kernel Panic error…
Possible SolutionsFrom the communityI did some search on google and found some people already met this problem before. And there was some answers mentioned about using fsck to repaire the boot partition.
You need run the fsck in a linux environment which means you need another linux system and load your Pi system sd-card as an external USB and run the command as follow:
1# first you need find the right partition - you can use&amp;#10;# sudo fdisk -l&amp;#10;sudo fsck.ext4 -v /dev/xxx&amp;#10;# replace the xxx with the name of your Pi partition
Unfortunately, this method didn’t work on my situation… ಥ_ಥ
From the StackOverFlowThere is a similar method like the one above with more details on Kernel panic, unable to mount root fs on unknown-block after restart.
Apparently.. it didn’t work either…
From you?Data RestoreFinally I gave up recovering my pi… but I hoped I can get my data back at least since I have near 6~7 million data in my database… And I definitely don’t want to re-crawl them again…
I found it was pretty easy.
Mount the Pi in your another linux systemFirst, like before, you need another linux system to mount the system partition of your Pi and copy paste your important data.
1sudo mkdir any_path_you_want&amp;#10;# this is your mount point&amp;#10;sudo mount /dev/xxx path-to-your-mount-point&amp;#10;# now you can access the files in your old pi system
PermissionRemember to run every command as root since you need the permission to do that.
Normally, you just need to copy paste all data you want to save. If the files are too many and large, you may need to use tar -zcvf tar_ball_name path_to_files_or_folders to compress them.
DatabaseSince I use mysql as my primary database, and mysql always saves all data under /var/lib/mysql, I just need to compress the entire folder and move it to another backup hard drive.
You will find there is a really big file, ibdata1, which saves all your data and indexes… Don’t delete it!!!
Restore DatabaseAfter you backup all you need, you can format your sd card now and re-install a system for your pi. After you install the mysql-server, you will find the /var/lib/mysql like before. Now just decompress the tar file you compressed before.
Before you jump into mysql and see whether your data has restored or not, you need change the owner and permission for your ‘new files’ under the mysql folder.
1sudo chown -R mysql:mysql /var/lib/mysql&amp;#10;sudo find /var/lib/mysql/ -type d -exec chmod 700 &amp;#123;&amp;#125; \;&amp;#10;sudo find /var/lib/mysql/ -type f -exec chmod 660 &amp;#123;&amp;#125; \;&amp;#10;sudo chmod 644 /var/lib/mysql/debian-5.5.flag
All these are to give your current mysql the right permission to all the files.
Now you are all set. Go and enjoy your data back in one piece!
ibdata1
The file ibdata1 is the system tablespace for the InnoDB infrastructure.It contains several classes for information vital for InnoDB

Table Data Pages
Table Index Pages
Data Dictionary
MVCC Control Data
Undo Space
Rollback Segments
Double Write Buffer (Pages Written in the Background to avoid OS caching)
Insert Buffer (Changes to Secondary Indexes)

Click to check more details : What is the ibdata1 file in my /var/lib/mysql directory?

There is a wonderful answer on StackOverFlow about reducing the size of ibdata1 : What is the best way to reduce the size of ibdata in mysql?.
If you have some unicode characters in your database and you find them become “question marks” after you restore your database, don’t panic ^_^. Just change the default character set for your database:
1# /etc/mysql/my.cnf&amp;#10;[client]&amp;#10;# ...&amp;#10;default-character-set=utf8&amp;#10;&amp;#10;[mysqld]&amp;#10;# ...&amp;#10;character-set-server=utf8&amp;#10;collation-server=utf8_general_ci
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>用 Raspberry Pi 做 NAS 和 采集器</title><link>http://taoalpha.me/blog/2015/08/20/tech-raspberry-pi-as-nas-and-crawlers/</link><category>tech</category><tag>Crawler,NAS,Raspberry Pi</tag><pubDate>2015-08-20T10:00:00.000Z</pubDate><description>引子在之前Raspberry Pi Setup一文中介绍了树莓派的初始配置. 这几天乘着还没开学, 就赶紧把树莓派重新跑起来, 虽然悲催的因为网络设定导致我的树莓派无法联网只能强制重刷了… 好在之前在家里就一直用 samba 把重要的脚本都存在了外置盘上, 而已抓取的数据也有早起的备份, 丢失的数据就没办法了..
所以正好相当于重新设定了一遍 NAS 和 diango , 本文做简单介绍, 方便后续查看.
NASNAS 全称是: Network-attached Storage. 简单说就是在一个网络组中用来存储数据的地方, 而在这个网路组的所有用户都可以在相应的权限下查看, 编辑.
通常一个低配的 NAS 也要差不多100多刀左右, 当然其读写速度, 性能都是很棒的, 买来即用~ 不过作为穷屌丝一枚, 手头又有几个闲置的移动硬盘和 U 盘. 于是就参考网上的教程用树莓派做个简易的 NAS , 供个人和室友使用还是绰绰有余了~
Samba想要实现自用的 NAS, 主要依赖的就是 Samba 这个服务了. Samba 是基于 SMB 协议的一个服务. 利用它多平台的特性可以方便的在多平台上进行数据交换. 而自建 NAS 的核心即是: 以树莓派为搭载平台, 将链接其上的闲置硬盘作为共用存储器.
Samba 的安装和配置都很简单:
1apt-get install samba samba-common-bin&amp;#10;# &amp;#20462;&amp;#25913; /etc/samba/smb.conf &amp;#24320;&amp;#21551;&amp;#23433;&amp;#20840;&amp;#26435;&amp;#38480;, &amp;#21462;&amp;#28040; `security = user`&amp;#30340;&amp;#27880;&amp;#37322;&amp;#21363;&amp;#21487;&amp;#10;# &amp;#36825;&amp;#37324;&amp;#20027;&amp;#35201;&amp;#26159;&amp;#30830;&amp;#20445;samba &amp;#30340;&amp;#29992;&amp;#25143;&amp;#24517;&amp;#39035;&amp;#26159;&amp;#31995;&amp;#32479;&amp;#30340;&amp;#29992;&amp;#25143;&amp;#20043;&amp;#19968;&amp;#10;&amp;#10;# &amp;#28982;&amp;#21518;&amp;#28155;&amp;#21152;&amp;#19979;&amp;#38754;&amp;#20869;&amp;#23481;&amp;#21040; /etc/samba/smb.conf &amp;#20013;&amp;#10;#[public]&amp;#10;#&amp;#27492;&amp;#22788;&amp;#25226;&amp;#20844;&amp;#20849;&amp;#30424;&amp;#30340;&amp;#21517;&amp;#23383;&amp;#35774;&amp;#23450;&amp;#20026;&amp;#20102; public, &amp;#21487;&amp;#20197;&amp;#20462;&amp;#25913;&amp;#10;#  comment = Public Storage&amp;#10;#  &amp;#22791;&amp;#27880;&amp;#21517;&amp;#10;#  path = /nas&amp;#10;#  path &amp;#36873;&amp;#25321;&amp;#33258;&amp;#24049;&amp;#25346;&amp;#36733;&amp;#30828;&amp;#30424;&amp;#30340;&amp;#20301;&amp;#32622;, &amp;#21021;&amp;#22987;&amp;#24212;&amp;#35813;&amp;#26159;/dev/sdan &amp;#36825;&amp;#31181;&amp;#26684;&amp;#24335;&amp;#30340;, &amp;#21487;&amp;#20197;&amp;#36890;&amp;#36807; `mount /dev/sdan /newpath`&amp;#26469;&amp;#20462;&amp;#25913;;&amp;#10;#  valid users = pi nas&amp;#10;#  &amp;#20998;&amp;#37197;&amp;#29992;&amp;#25143;&amp;#26435;&amp;#38480;, &amp;#36825;&amp;#37324;&amp;#32473;&amp;#20104;&amp;#20102; pi &amp;#21644; nas &amp;#20004;&amp;#20010;&amp;#29992;&amp;#25143;&amp;#30340;&amp;#35775;&amp;#38382;&amp;#26435;&amp;#38480;&amp;#10;#  read only = no&amp;#10;#  create mask = 0777&amp;#10;#  public = yes&amp;#10;#  writable = yes&amp;#10;#  directory mask = 0777&amp;#10;#  guest ok = yes&amp;#10;#  browseable = yes
其中, 如果希望每次开机自动挂载硬盘到自定义位置, 可以通过修改/etc/fstab文件来实现:1#&amp;#22312;&amp;#21407;&amp;#26377;&amp;#22522;&amp;#30784;&amp;#19978;&amp;#28155;&amp;#21152;(&amp;#20462;&amp;#25913; `/sda1` &amp;#20026;&amp;#20320;&amp;#30340;&amp;#30828;&amp;#30424;&amp;#21021;&amp;#22987;&amp;#25346;&amp;#36733;&amp;#20301;&amp;#32622;):&amp;#10;/dev/sda1       /nas            ext4    defaults          0       0
在完成设定后, 就需要重启 samba 服务并添加对应用户了. 因为我们开启了security = user, 所以这里需要给 samba 添加系统用户, 比如默认的 pi 用户, 或者 root. 当然你可以通过useradd来给系统创建新用户.
创建用户后, 就可以给 samba 添加用户了.
smbpasswd -a username 即可添加用户, smbpasswd -e nas 则启用此用户.
设定好对应用户的 samba 密码后即可通过你的电脑访问你的共享盘了, 你可以通过 connect 到 smb://192.168.x.x(你的 pi 地址), 然后输入对应的用户名密码即可~
PS. 如果你是用的 NTFS 的硬盘, 那么还需要安装ntfs-3g来实现对硬盘的读写功能, 如果你用的是 mac 的盘, 那么还需要安装hfsplus和hfsutils来实现同样的目的~ 上述都可以通过apt-get直接安装.
到此, 你的简易 nas 就算是完成了~ 可以享受喽~
采集器玩 python, 怎么能不写爬虫呢? 哈哈 因为树莓派低功耗, 全天候运行的特性, 作为爬虫可谓是绝佳的好平台 ^_^
支持库安装首先为了跟随时代潮流, 我选择3.4作为 python 主版本~ 2.7.6作为辅助. 这里可以通过Pythonbrew来实现轻松管理 python 版本的目的. (注: pythonbrew 安装3.4的时候要使用3.4.0这种具体到小版本号的名称安装, 不然会找不到 package 的)
3.4已经自带了pip, 所以就可以不用自己安装了~ 接下来利用 pip 来安装支持库.
1pip install django&amp;#10;# &amp;#25105;&amp;#27604;&amp;#36739;&amp;#20064;&amp;#24815;django &amp;#30340;&amp;#26694;&amp;#26550;&amp;#20102;, &amp;#22914;&amp;#26524;&amp;#20320;&amp;#21916;&amp;#27426; flask &amp;#20063;&amp;#21487;&amp;#20197;&amp;#26681;&amp;#25454;&amp;#33258;&amp;#24049;&amp;#30340;&amp;#21916;&amp;#22909;&amp;#35843;&amp;#25972;&amp;#10;pip install beautifulsoup4&amp;#10;# html &amp;#35299;&amp;#26512;&amp;#24211;, &amp;#24403;&amp;#28982;, &amp;#20320;&amp;#20063;&amp;#21487;&amp;#20197;&amp;#21033;&amp;#29992; xpath &amp;#26469;&amp;#30828;&amp;#35299;~&amp;#10;pip install mysqlclient&amp;#10;# &amp;#36825;&amp;#20010;&amp;#26159; MySQLdb&amp;#30340;&amp;#19968;&amp;#20010; fork, &amp;#20294;&amp;#26159;&amp;#25552;&amp;#20379;&amp;#20102; python3&amp;#30340;&amp;#25903;&amp;#25345;, &amp;#29992;&amp;#26469;&amp;#20462;&amp;#22797;&amp;#25903;&amp;#25345; p3 &amp;#19979; django &amp;#20351;&amp;#29992; mysql .&amp;#10;# &amp;#22914;&amp;#26524;&amp;#19978;&amp;#36848;&amp;#25253;mysql &amp;#30340;&amp;#38169;&amp;#35823;&amp;#25110;&amp;#32773;mysql_config not found, &amp;#35831;&amp;#30830;&amp;#20445;&amp;#20320;&amp;#24050;&amp;#32463;&amp;#23433;&amp;#35013;&amp;#20102; mysql &amp;#20197;&amp;#21450; libmysqlclient-dev&amp;#10;pip install pymysql&amp;#10;# &amp;#20064;&amp;#24815;&amp;#29992;&amp;#36825;&amp;#20010;&amp;#20570;&amp;#25235;&amp;#21435;&amp;#25554;&amp;#20837;&amp;#20102;... &amp;#21487;&amp;#20197;&amp;#29992; MySQLdb &amp;#30340;~&amp;#10;pip install git+ssh://git@github.com/Supervisor/supervisor.git&amp;#10;# &amp;#22240;&amp;#20026; supervisor &amp;#22312; pip &amp;#30340;&amp;#29256;&amp;#26412;&amp;#19981;&amp;#25903;&amp;#25345; p3, &amp;#25152;&amp;#20197;&amp;#38656;&amp;#35201;&amp;#33258;&amp;#24049;&amp;#30452;&amp;#25509;&amp;#21033;&amp;#29992; pip &amp;#23433;&amp;#35013; git &amp;#19978;&amp;#30340;&amp;#29256;&amp;#26412;.&amp;#10;# &amp;#38656;&amp;#35201;&amp;#20808;&amp;#28155;&amp;#21152; sshkey &amp;#21040; github &amp;#19978;, &amp;#19981;&amp;#28982;&amp;#26080;&amp;#27861; clone &amp;#30340;~ &amp;#30456;&amp;#20851;&amp;#35831;&amp;#26597;&amp;#30475; github &amp;#23448;&amp;#26041;&amp;#20171;&amp;#32461;.
到此, 基本库就算是差不多全了.
django1django-admin startproject PROJECT_NAME&amp;#10;# &amp;#21019;&amp;#24314;&amp;#26032;&amp;#39033;&amp;#30446;&amp;#10;django-admin startapp APP_NAME&amp;#10;# &amp;#21019;&amp;#24314;&amp;#26032; app
修改 project 里的 settings.py, 替换 database 的配置(根据你是用的 db 库修改), 添加 APP_NAME 到 INSTALLED_APPS 里.
采集APP根据自己的情况修改 APP 的 models.py 创建表结构.
同步数据库:
1python manage.py migrate&amp;#10;# &amp;#21516;&amp;#27493; django &amp;#30340;&amp;#25968;&amp;#25454;&amp;#24211;&amp;#10;python manage.py makemigrations APP_NAME&amp;#10;# APP &amp;#34920;&amp;#32467;&amp;#26500;&amp;#36801;&amp;#31227;&amp;#10;python manage.py sqlmigrate crawlers 000x&amp;#10;# APP SQL &amp;#36801;&amp;#31227;(&amp;#21487;&amp;#20197;&amp;#39044;&amp;#35272;&amp;#19979; SQL). &amp;#36825;&amp;#37324;&amp;#30340;000x &amp;#26159;&amp;#26681;&amp;#25454;&amp;#19978;&amp;#19968;&amp;#27493; makemigrations &amp;#24471;&amp;#21040;&amp;#30340; version &amp;#32534;&amp;#30721;, &amp;#19968;&amp;#33268;&amp;#21363;&amp;#21487;&amp;#10;python manage.py migrate&amp;#10;# &amp;#21516;&amp;#27493;&amp;#25968;&amp;#25454;&amp;#24211;, &amp;#27491;&amp;#24335;&amp;#29983;&amp;#25928;
此外, 记得创建一个 admin user 并且把 admin 的静态文件转移过来~ (需要在 project 的 settings.py 中设定STATIC_ROOT路径)
python manage.py createsuperuser
python manage.py collectstatic
通过这个就可以登录 django 的 admin 后台了~
采集脚本接下来就是数据库的填充了~ 这里就得根据自己的情况来写爬虫喽~
supervisor 自启动supervisor 是很好的系统任务管理工具. 利用它可以更方便的管理我们的 django 以及其他的项目, 如果有的话.
上面安装支持库中已经成功的为 python 3 安装了 supervisor, 所以这里我们就可以直接进入到配置环节了:
1[supervisord]&amp;#10;[program:pragram_name]&amp;#10;directory=path_to_django_project&amp;#10;command=python manage.py runserver&amp;#10;autorestart=true&amp;#10;autostart=true
DONE! 保存这一配置文件到你的任意目录中, 只要记得启动supervisord的时候利用-c指定到这一配置文件即可.
nginx 映射为了让我们能够在局域网的其他机器上直接访问我们的 django, 我们需要把 nginx 映射到我们的 django 去~
最简单的方法就是, 利用proxy_pass http://127.0.0.1:8000;将80端口直接导向我们的 django server 所在.
123456789101112131415161718server &amp;#123;    listen   80;    server_name localhost;    access_log  /var/log/nginx/access.log;    error_log /var/log/nginx/error.log debug;    rewrite_log on;    location / &amp;#123;        proxy_pass http://127.0.0.1:8000;        proxy_redirect  off;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &amp;#125;    location /static/ &amp;#123;        root path_to_project;    &amp;#125;&amp;#125;
 如此, 通过 supervisord -c path_to_supervisor_conf 就可以启动你的 django 了~ 稍等片刻, 你就可以通过访问你的树莓派 ip 看到成功搭建的 django 欢迎页面了~
PS. 如果不喜欢手动加载 supervisor 配置, 也可以把配置文件放到 supervisor 的系统配置目录中, 然后就可以通过supervisord  start supervisor_program_name来启动了~
恩, 就到这里了~ 下一步就是在我的树莓派上搭建一个每天任务跟踪的服务了~ 这个还需要好好想想~ ^_^
参考
django Getting started
MySQL database connector for Python (with Python 3 support)
pip install from git repo
mysql_config not found when installing mysqldb python interface

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>A simple python script to analyse all ips in nginx access log</title><link>http://taoalpha.me/blog/2015/06/20/tech-python-script-analyse-ips-in-nginx-access-log/</link><category>tech</category><tag>nginx,python</tag><pubDate>2015-06-20T05:00:00.000Z</pubDate><description>I wrote this script and this post several months ago on my previous blog, mainly used during my application. And I think it is pretty useful. So I move it in and hope it can help you in some way.
=============The Origin==============
As time gets closer to the March, I feel more and more nervous… And since most of HCI programs I submitted require you submit your portfolio website, I want to keep watching my nginx access log and get a summary about where all the accesses come from. So I wrote a simple python script to get all the ips from the nginx-access.log and analyse the ip with the json API provided by ipinfo.io.
Here is the script, anyone who want to get more information about your access ip and also don’t want or don’t know how to use the google analysis maybe can give a try:

before you run this script, you should create two empty output files: ipdetails.txt, errorips.txt in this example. you can change the filename if you want, just remember to change the name in script too.
Hope this script can help you! Thanks. Have a nice day!
=================PS==================
You can find some spamips from the internet, and almost most of them are pretty large, maybe 30-50 megabytes~ And according to my experience, I think it would be alright if you don’t import the spamips file~
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>preventDefault and stopPropagation in JS</title><link>http://taoalpha.me/blog/2015/11/19/tech-preventDefault-and-stopPropagation-in-JS/</link><category>tech</category><tag>JS,jQuery,propagation</tag><pubDate>2015-11-19T09:00:00.000Z</pubDate><description>IntroductionWhen we deal with event on DOM, jQuery always very helpful. But javascript has this mechanic called event bubbling is quite annoying. So be careful when you deal with them.
Event BubblingWe all know DOM elements can be nested inside each other which is great for structure. But it causes some troubles when you want to deal with the event on the children and parent separately. Because if we do nothing with that, the event like ‘click’ happened on children will trigger the same event for parents too, which is event bubbling.
Event CapturingAll browsers except IE&amp;lt;9, there are two stages of event processing, one is event bubbling, another is event capturing. Opposite with event bubbling, the event capturing will go down along the html structure and trigger the corresponding event. And by default: All methods of event handling ignore the caputiring phase. Using addEventListener with last argument true is only the way to catch the event at capturing.
How to deal with themIn JavaScript, we have two handy fucntions called stopPropagation() and preventDefault() can help us deal with the event bubbling and event capturing. Former one can stop the event bubbling so click or other events happened on children won’t affect parents events. Latter one can prevent default event handlers defined in this element so you can rewrite the event handlers by youself.
When you need deal with themWhen you need deal with event bubbling? It depends, but most times, you will deal with that when you want to assign events on an area instead of a specific elements.
SummaryEvent bubbling and capturing are really cool stuffs and let you do some fantastic things. But also they are pretty annoying that may cause a lot troubles when you want to detect the bugs in your code…
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>First CLI tool with NodeJS</title><link>http://taoalpha.me/blog/2015/12/07/tech-my-first-cli-tool-with-nodejs/</link><category>tech</category><tag>CLI,JS,NodeJS</tag><pubDate>2015-12-07T06:00:00.000Z</pubDate><description>IntroductionBriefly speaking, NodeJS is like using JS on back-end stuff. Its really cooooooool and exctied for every JS developer !!!
I just started to learn Node, and in order to learn it better, I made a small cli tool for myself, it’s quit helpful actually.
Meet BabyI named this tool as ‘baby’ with a lot of reasons… :)
What it can do ? It can do a lot and also the power of it is increasing everyday :) since I always put my repeatly work together and build a command for that :)
Here list a few of them:

edit: you can set your favorite editor in the config file, and then you can use baby e file_name to edit it, why you want to do that? why not just use my favorite editor? Because baby can monitor your changes!!! And if you enable the ‘global summary’, it can record all you modifications and tell you how many changes you made in total :);
ssh: this is just for myself, since I always need to log in my aws server or digital ocean server with a pem file a secret settings, so I wrote this and made it simple(with short names);
npm: I love npm! And also I use yeoman to build my webapp workflow, one thing is that as time goes on, you will find that all you modules will become outdated or not the latest version, so I used a script to loop over all outdated packages and updated them to wanted version or to latest version;
tool: this is a collection of small commands, like the only one I have now is print the structure of the files under the current path;
todo: I always made a todo app when I first learn some new languages or frameworks, so I did again for node, you can add, edit, mark as done or mark as undone and also clean or empty the tasks list, next I will make a webpage for it using angularJS since I am learning that now :)
serve: will create a server with current path and look for the index.html file by default;
cdn: since I am a web developer, so I always need to search the JS modules or plugins, so I download all the names and links from the cdnjs, and build a trie tree for the names, now I can just use baby cdn name to show the matches and links;

….
There are and will be a lot new features added to my baby, you can check it out from my github - baby
ByeNext post I will talk about how to make a cli tool for yourself with nodejs. :)
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JS实现中文日期的方法</title><link>http://taoalpha.me/blog/2015/05/12/tech-js-date-to-chinese/</link><category>tech</category><tag>js,日期转换</tag><pubDate>2015-05-12T09:00:00.000Z</pubDate><description>这是一篇草稿转正的文章, 一直忘记发布了.
当时为了让blog左侧随机图不至于太空, 所以加入了天气预报的彩蛋. 目前还没做太复杂的地理位置判定, 所以按照我所在位置给予的北京天气, 之后会考虑修改成地理位置相关的天气.
因为要显示天气和日期, 英文的比较好说, 只需要用默认的toDateString()函数转换即可. 中文的则需要做一个简单的转换, 下述是我所使用的方法, 其实就是把日期数字和中文汉字对等起来而已~12345678910var day = new Date(dt).getDate()var month = new Date(dt).getMonth()var Dcharacters = [&quot;&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;,&quot;七&quot;,&quot;八&quot;,&quot;九&quot;,&quot;十&quot;]var Mcharacters = [&quot;&quot;,&quot;十&quot;,&quot;二十&quot;,&quot;三十&quot;]// 汉字对应的版本, 因为日月转换规则一致, 所以可以共用的~// 设计的规则是分成十位和个位进行分别转换, 所以因为考虑到都有没有(十位/个位)的情况, 首个元素都给予的是空值var ZdataM = Mcharacters[Math.floor(month/10)]+Dcharacters[month % 10+1]// 月份的转换, 十位+个位var ZdataD = Mcharacters[Math.floor(day/10)]+Dcharacters[day % 10]// 日子转换: 十位+个位
没有做全部日期测试, 所以如果您发现任何问题请及时告诉我哈~
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Jekyll 筛选 tag 的实现</title><link>http://taoalpha.me/blog/2015/05/07/tech-jekyll-tips-2/</link><category>tech</category><tag>jekyll,jekyll tags,js,tips</tag><pubDate>2015-05-07T11:00:00.000Z</pubDate><description>对于blog而言, 利用categories和tags的筛选是非常方便的, 而在jekyll部署的静态博客中也能轻松的实现这一点的. 本文(也即本博客)中效果主要模仿简书.
展现categories以及tags
首先我们需要设定了tags的post… 这样你的site.tags才会有数据~ 具体的tags设定方法可以参照 心得(1)接着就是如何展现tags数据了~ 以本文为例, 我总计有三个category, 因为要实现不同category下的tag只出现在自己的category页面下方, 所以在展现tags的时候需要做一个category的判定.

1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% assign tags = &amp;#34;all&amp;#34; %&amp;#125;&amp;#10;// &amp;#35774;&amp;#32622;&amp;#21464;&amp;#37327;, &amp;#36825;&amp;#37324;&amp;#29992;all&amp;#26469;&amp;#34920;&amp;#31034;&amp;#40664;&amp;#35748;&amp;#30340;&amp;#31532;&amp;#19968;&amp;#20010;tag, &amp;#20195;&amp;#34920;&amp;#20840;&amp;#37096;tags&amp;#30340;&amp;#24773;&amp;#20917;&amp;#10;&amp;#123;% for post in site.posts %&amp;#125;&amp;#10;    // &amp;#21462;&amp;#25152;&amp;#26377;&amp;#30340;post&amp;#20986;&amp;#26469;&amp;#36880;&amp;#19968;&amp;#21028;&amp;#23450;, &amp;#36825;&amp;#37324;&amp;#26410;&amp;#26469;post&amp;#24456;&amp;#22810;&amp;#30340;&amp;#35805;, &amp;#20250;&amp;#36827;&amp;#34892;&amp;#25968;&amp;#37327;&amp;#38480;&amp;#21046;, &amp;#30446;&amp;#21069;&amp;#25968;&amp;#37327;&amp;#22826;&amp;#23569;, &amp;#23601;&amp;#31961;&amp;#30528;&amp;#29992;&amp;#21862;&amp;#10;    &amp;#123;% for tag in post.tags %&amp;#125;&amp;#10;        // &amp;#21462;post&amp;#33258;&amp;#24049;&amp;#30340;tags&amp;#20986;&amp;#26469;, &amp;#36880;&amp;#19968;&amp;#36827;&amp;#34892;&amp;#21028;&amp;#23450;&amp;#26159;&amp;#21542;&amp;#24050;&amp;#32463;&amp;#22312;tags&amp;#25968;&amp;#32452;&amp;#21015;&amp;#34920;&amp;#20013;&amp;#20102;&amp;#10;        &amp;#123;% unless tags contains tag %&amp;#125;&amp;#10;            // &amp;#20026;&amp;#20102;&amp;#21435;&amp;#25481;&amp;#37325;&amp;#22797;&amp;#30340;tag~&amp;#10;            &amp;#123;% capture tags %&amp;#125;&amp;#123;&amp;#123; tags &amp;#125;&amp;#125;|&amp;#123;&amp;#123; tag &amp;#125;&amp;#125;&amp;#123;% endcapture %&amp;#125;&amp;#10;            // &amp;#25226;&amp;#25152;&amp;#26377;&amp;#19981;&amp;#22312;tags&amp;#25968;&amp;#32452;&amp;#20013;&amp;#30340;tag&amp;#37117;&amp;#21152;&amp;#21040;tags&amp;#20013;&amp;#10;        &amp;#123;% endunless %&amp;#125;&amp;#10;    &amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#123;% assign alltags = tags | split: &amp;#39;|&amp;#39; %&amp;#125;&amp;#10;// &amp;#29983;&amp;#25104;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#25968;&amp;#32452;, &amp;#20284;&amp;#20046;&amp;#26412;&amp;#36523;liquid&amp;#20013;&amp;#27809;&amp;#26377;&amp;#30452;&amp;#25509;append&amp;#25968;&amp;#32452;&amp;#30340;&amp;#26041;&amp;#27861;... &amp;#30475;&amp;#21040;&amp;#27492;&amp;#22788;&amp;#30340;&amp;#26379;&amp;#21451;&amp;#26377;&amp;#30693;&amp;#36947;&amp;#30340;&amp;#35831;&amp;#19981;&amp;#21533;&amp;#21578;&amp;#30693;~&amp;#10;&amp;#60;ul class=&amp;#34;tags&amp;#34;&amp;#62;&amp;#10;&amp;#123;% for tag in alltags %&amp;#125;&amp;#10;// &amp;#23637;&amp;#29616;tag&amp;#10;&amp;#60;a href=&amp;#34;javascript:;&amp;#34; data-rel=&amp;#34;&amp;#123;&amp;#123; tag &amp;#125;&amp;#125;&amp;#34; class=&amp;#34;filter tag &amp;#123;% if tag == &amp;#39;all&amp;#39;  %&amp;#125;active&amp;#123;% endif %&amp;#125;&amp;#34; &amp;#62;&amp;#123;&amp;#123; tag &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#10;// &amp;#36825;&amp;#37324;&amp;#30340;data-rel&amp;#26159;&amp;#20026;&amp;#20102;&amp;#31579;&amp;#36873;&amp;#20570;&amp;#30340;&amp;#20934;&amp;#22791;, &amp;#21518;&amp;#25991;&amp;#20250;&amp;#20171;&amp;#32461;&amp;#10;&amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#60;/ul&amp;#62;&amp;#10;&amp;#123;% endraw %&amp;#125;
如此基本就实现了tags在特定category下的展现.
根据tag进行筛选有了tags之后, 就可以进一步做筛选了. 基本的思路是在不考虑分页的情况下, 筛选基本就是针对当前展现出来的文章列表做对应的展现隐藏控制.

利用data-rel(随意指定data后面的名称即可)存储要筛选的tag, 如上;在post中加上tags的数据标签:

1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#60;li class=&amp;#34;post&amp;#34; data-filter=&amp;#34;&amp;#123;&amp;#123; post.tags|join:&amp;#39; &amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#10;// &amp;#22240;&amp;#20026;post.tags&amp;#26412;&amp;#36523;&amp;#23601;&amp;#26159;&amp;#19968;&amp;#20010;array&amp;#31867;&amp;#22411;, &amp;#25152;&amp;#20197;&amp;#36825;&amp;#37324;&amp;#30452;&amp;#25509;&amp;#29992;&amp;#31354;&amp;#26684;&amp;#38142;&amp;#25509;&amp;#22635;&amp;#20837;&amp;#19968;&amp;#20010;`data-filter`&amp;#20013;&amp;#21363;&amp;#21487;;&amp;#10;&amp;#123;% endraw %&amp;#125;

利用js实现点击筛选的控制:

123456789101112131415161718192021222324$(&quot;.filter&quot;).on(&quot;click&quot;, function () &amp;#123;    // 由tag点击事件出发    var $this = $(this);    if ( !$this.hasClass(&quot;active&quot;) ) &amp;#123;        // 排除当前已选tag, 新tag标记active        $(&quot;.filter&quot;).removeClass(&quot;active&quot;);        $this.addClass(&quot;active&quot;); // set the active tab        var $filter = $this.data(&quot;rel&quot;);         // 获得要筛选的tag名称        $filter == 'all' ?             // 对all做单独判断, 基本就是全展现            $(&quot;.post&quot;)            .not(&quot;:visible&quot;)            .fadeIn()         : // 否则的话, 利用filter进行tag匹配的判断            $(&quot;.post&quot;)            .fadeOut(0)            .filter(function () &amp;#123;                // 判断post中是否包含此tag, 这里用array来判断而不是直接文本判断就是为了防止出现类似tag和tags这种局部包含的误判                return $(this).data(&quot;filter&quot;).split(&quot; &quot;).indexOf($filter)!=-1;             &amp;#125;)            .fadeIn(1000);     &amp;#125; // endif&amp;#125;); // endon
这里都用的是fadeIn,fadeOut的动效, 你当然可以修改成自己的~ 这里的实现主要参照了jQuery filter with fancybox, 不过原理其实很简单的~
tags限制随着post的增多, 你会发现自己的tags也越来越庞大, 如果全部展现的话, 一是太多, 二呢, 展现也不方便, 毕竟我目前的css样式只考虑了两行的情况, 所以呢, 还是需要对tags的展现做一些限制的.
有两种思路:

利用jekyll的plugin直接在生成层控制, 每次随机出一些tag就行了;

利用js在展现层控制, 所有tag都生成出来, 但是由js控制随机展现一部分;


最终我用的还是第二种思路, 第一种思路主要缺点是在编译生成的时候控制的话, 只有每次重新编译才会重新生成, 和我希望的访问随机需求不符合.
实现方法也很容易, 基本就是利用Math.random()来生成随机数即可.
12345678910function randomTags()&amp;#123;    var originArray = $('ul.tags').find('a.tag')    originArray.eq(0).show();    // 确保 all 每次都展现    for (i=0;i&amp;lt;10;i++)&amp;#123;        var index = Math.floor(Math.random()*originArray.length)+1        // 没有做虑重处理, 所以很可能展现出来的tag没有10个; 想做的话也容易, 循环过程中加个是否显示了的判断即可, 这里就不做了~        originArray.eq(index).show();    &amp;#125;&amp;#125;
如上, 对于jekyll的tags和categories的探索就先这样了~ 以后有什么更加有趣的想法或者发现了再补充~
See ya.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Jekyll 简介</title><link>http://taoalpha.me/blog/2015/05/07/tech-jekyll-tips-1/</link><category>tech</category><tag>jekyll,jekyll tags,tips</tag><pubDate>2015-05-07T16:00:00.000Z</pubDate><description>环境部署 Jekyll作为静态博客, 以简单易部署而出名, 尤其是随着github对于静态博客的支持, 更是发展势头极为良好, 很多人都从大而繁杂的wordpress转移到了小而轻巧的Jekyll, 也有很多人选择了另一款小而精的静态博客:hexo, 至于他们之间的好坏, 孰优孰劣, 可以参考知乎原文:arBox、Jekyll、Octopress、ghost、marboo、Hexo、Medium、Logdown、prose.io，这些博客程序有什么特点？.
 这里就简单介绍下github下如何部署Jekyll.


首先, 你得有个github帐号…(废话)… 然后你需要新建一个yourname.github.com(或者io结尾也可以)的repo, 并且在设置中开启github pages;
接下来就是组织Jekyll的文件结构了, 这部分推荐在本地环境中操作, 因为你可以在本地的jekyll环境下随时测试预览调整, 不用每次都上传到github上在线查看; 一般来说, 你不需要完全从头进行的, 完全可以在jekyll的示例网站中寻找自己喜欢的主题样式, 然后clone到本地后, 在其基础上修改完成, 比如我现在这个就是在我自己的设定基础上融合了beiyuu的一些结构和设置, 然后参照简书修改的;
Jekyll是基于Ruby的, 所以如果想要搭建本地环境, 请确保你已经安装了Ruby~ 有了Ruby后, 你就可以参照官网的安装指南一步步操作了;
在本地测试通过后, 你只需要push到github中, github就会自动帮你编译, 你就可以通过你的github page网址进行访问了;


文件结构关系 Jekyll的文档结构是非常简单的, Jekyll是基于Ruby的, 所以如果想要搭建本地环境, 请确保你已经安装了Ruby~ 有了Ruby后, 你就可以参照官网的安装指南一步步操作了;
1234567891011121314151617181920.├── _config.yml├── _drafts|   ├── begin-with-the-crazy-ideas.textile|   └── on-simplicity-in-technology.markdown├── _includes|   ├── footer.html|   └── header.html├── _layouts|   ├── default.html|   └── post.html├── _posts|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile|   └── 2009-04-26-barcamp-boston-4-roundup.textile├── _data|   └── members.yml├── _site├── .jekyll-metadata└── index.html   // from Jekyll documentation


如上, 一个完整而又基础的jekyll文档结构基本就是这样了. 其中_config.yml是全局的配置文件, 你可以在这里配置你的固定链接, 插件, 高亮以及设定很多的默认值等等;
_drafts和_posts文件夹都是博文所在地, 区别在于_drafts是存放草稿的地方, 除非在测试环境下加上–watch`的参数是不会出现在blog中的;
_layouts以及_includes分别是模板以及复用代码块所在, 基本上重复性代码都可以视情况放在这两个当中, 整页性的复用(模板)就放在_layouts中, 块结构的复用则放在_includes中;
_site基本不用管, 因为它是jekyll编译后的产物, 也基本就是你所看到的网站的正常版本;
_data, 这个涉及比较高端的用法… 我目前都没有开始接触, 所以放在以后的系列中介绍吧;
index.html, 作为blog的首页;


需要注意的事情是:


和正常的网站文件结构类似, jekyll对文件夹的解析也是类似的, 我们可以在根目录下随意的建立文件夹, 从而创造二级路径;
如果你像我一样把blog整个放到二级路径下, 建立一个独立的首页的话, 请注意记得在_config.yml中配好你的post页面地址(如果你希望所有的post页面都在你的yoursite/blog/your-post的话), 且把_posts转移到blog文件夹中, 但是诸如_layouts等则不需要调整;


Tags 以及 Categories 作为blog, 即便是简单的静态博客, 如果没有category和tag系统的, 也绝对不能算是一个好的博客系统,jekyll当然是一个好的博客系统啦~


Categories: Jekyll的category关键字是内置的, 只需要在post的顶部定义号对应的category关键字, 多个的话用array的方式定义即可, 比如category: [cat1,cat2], 而在liquid语法中, 则完全可以通过 site.categories.cat1 来访问对应的分类;
Tags: 基本和categories一样, 关键字是tags, 同样可以支持多个tag, 一样使用site.tags.tagname来访问; 


Liquid语法 Liquid Template Language是一种非常常用的模板语言, 它的语法很有特点, 粗糙理解的话, 就是一种简单的替换语法, 识别特定的结构和模式, 做特定的行为.
 Liquid 来自于shopify, 其代码也是由Shopify在github上维护的, 如果想要详细了解其中的语法和用法, 以及Liquid目前的广泛用途, 都可以前往其github上的wiki查看.
 一些常用的语法: 1if : &amp;#123;% if statement %&amp;#125; &amp;#123;% elsif %&amp;#125; &amp;#123;% endif %&amp;#125;&amp;#10;for : &amp;#123;% for statement %&amp;#125; &amp;#123;% endfor %&amp;#125;&amp;#10;unless : &amp;#123;% unless statement %&amp;#125; &amp;#123;% endunless %&amp;#125;&amp;#10;assign : &amp;#123;% assign statement %&amp;#125; (&amp;#36171;&amp;#20540;)&amp;#10;capture : &amp;#123;% capture %&amp;#125; &amp;#123;% endcapture %&amp;#125; (&amp;#25429;&amp;#33719;&amp;#36171;&amp;#20540;)&amp;#10;case : &amp;#123;% case condition %&amp;#125; &amp;#123;% when 1 %&amp;#125; &amp;#123;% when 2 or 3 %&amp;#125; &amp;#123;% else %&amp;#125; &amp;#123;% endcase %&amp;#125;&amp;#10;comment : &amp;#123;% comment %&amp;#125; &amp;#123;% endcomment %&amp;#125;&amp;#10;raw : &amp;#123;% raw %&amp;#125; &amp;#20197;&amp;#21450; endraw
 常用的管道用法:
1&amp;#21464;&amp;#37327;&amp;#24341;&amp;#29992;&amp;#31526;&amp;#21495; : &amp;#123;&amp;#123; variable_name &amp;#125;&amp;#125;&amp;#10;&amp;#22823;|&amp;#23567;|&amp;#39318;&amp;#23383;&amp;#27597;&amp;#22823;&amp;#20889; : &amp;#123;&amp;#123; v_name | upcase | downcase | capitalize &amp;#125;&amp;#125;&amp;#10;&amp;#25490;&amp;#24207;|&amp;#36830;&amp;#25509;|&amp;#20999;&amp;#20998;|&amp;#26367;&amp;#25442; : &amp;#123;&amp;#123; v_name | sort | join:&amp;#34;join-symbol&amp;#34; | split: &amp;#34;split-symbol&amp;#34; | replace: &amp;#34;replace-char&amp;#34; &amp;#125;&amp;#125;
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Jekyll 添加 tag 专属页面</title><link>http://taoalpha.me/blog/2015/06/01/tech-jekyll-tag-page/</link><category>tech</category><tag>jekyll,jekyll tags,ruby</tag><pubDate>2015-06-01T05:00:00.000Z</pubDate><description>Tag的运用Tag可以算是blog的标配了, 借用tag我们才能够让blog更好的归档, 既丰富了博客的内容体系, 也更便于筛选.而jekyll默认虽然给了tag的域, 但是却并不会自动开启tag的专属页面, 这个页面还需要我们自己来创建的. 建立tag专属页面的方法也有几种, 考虑到很多人都用github page作为自己jekyll的博客, 那么这里就按照有无插件辅助来区分以下方法吧(github page不支持插件~ 想要了解如何在github page中使用jekyll插件?)
无插件实现方法如果不使用插件的话, 其实基本思路就和之前不使用插件建立tech, dandp两个分类页是一样的, 通过创建对应的tagpage template, 以及对应的tag单页引用相应的模板即可.
创建tagpage template首先我们需要根据具体的需求创建一个tag页面的模板, 以我自己的为例:
1&amp;#123;% raw %&amp;#125;&amp;#10;---&amp;#10;layout: home_base&amp;#10;---&amp;#10;&amp;#10;&amp;#60;nav id=&amp;#34;bread&amp;#34;&amp;#62;&amp;#10;  &amp;#60;h2&amp;#62;&amp;#60;a href=&amp;#34;/blog&amp;#34;&amp;#62;All Posts&amp;#60;/a&amp;#62; &amp;#62;&amp;#62; Posts with tag: &amp;#123;&amp;#123; page.tag &amp;#125;&amp;#125;&amp;#60;/h2&amp;#62;&amp;#10;&amp;#60;/nav&amp;#62;&amp;#10;&amp;#123;% assign cposts = site.tags[page.tag] %&amp;#125;&amp;#10;&amp;#60;article&amp;#62;&amp;#10;  &amp;#60;ul class=&amp;#34;article-list&amp;#34;&amp;#62;&amp;#10;    &amp;#123;% for post in cposts %&amp;#125;&amp;#10;    ... &amp;#60;!-- &amp;#22635;&amp;#20805;&amp;#23637;&amp;#31034;&amp;#20869;&amp;#23481; --&amp;#62;&amp;#10;    &amp;#123;% endfor %&amp;#125;&amp;#10;  &amp;#60;/ul&amp;#62;&amp;#10;&amp;#60;/article&amp;#62;&amp;#10;&amp;#123;% endraw %&amp;#125;
上述就创建了一个非常简单的tag单页模板.
创建tagpage 单页留意上述的模板代码, 你就会发现我们是通过site.tags来筛选所有博文, 从而实现筛出特定tag的博文的目的的. 那么如果我们需要创建tag的专属页, 我们就需要在单页上指定tag, 所以单页的内容很简单:
1&amp;#123;% raw %&amp;#125;&amp;#10;---&amp;#10;layout: tagpage&amp;#10;tag: jekyll&amp;#10;---&amp;#10;&amp;#123;% endraw %&amp;#125;
如此就创建了一个jekyll的tag单页, 那么访问路径设定呢? 有两种方法(都以/tag/jekyll为例):

通过新建文件夹tag, 然后在其中再新建jekyll文件夹, 在jekyll文件夹下创建index.html或者index.md文件, 填写上述代码即可;
在根目录下创建jekyll.md文件, 然后在上述代码的基础上加上permalink: /tag/jekyll即可;

如此就算是实现了不用插件的情况下对特定tag创建的tag专属页了.
## Update更新一种无插件创建tag页的方法: 思路是展现全部post在一个页面, 加上tag属性, 然后通过js借助url的parameter来实现过滤tag的功能;### 创建全部post的单页这一点基本和上述模板一致, 只需要将site.tags.TAGNAME换成site.posts就行, 然后将post.tags数据写到对应的li的class或者data-中. 这一点类似我之前给目录页加tag筛选功能的做法. 只是控制部分转移到url的参数了.### 筛选过滤接下来就是获取url参数以及控制筛选的过程了.12345678910111213141516function getUrlParameter(sParam)&amp;#123;  // 默认你是通过&quot;xxxx?tag=xxx&quot;的结构传递tag的, 当然你可以根据具体的情况(比如#)修改  // location.search可以自动返回?及之后的字串  var rParams= window.location.search.substring(1);  var aParams = rParams.split('&amp;amp;');  for (var i = 0; i &amp;lt; aParams.length; i++)   &amp;#123;    var sParameterName = aParams[i].split('=');    if (sParameterName[0] == sParam)     &amp;#123;      return sParameterName[1];    &amp;#125;  &amp;#125;&amp;#125;获取后则是针对所有posts的一个遍历筛选了. 当然如果你前期模板建立的时候就按照tag把blog聚合成块的话, 那么此时筛选甚至可以做的更简单一些, 如下:1234567891011window.onload = function() &amp;#123;  var tag = getUrlParameter('tag');  if (tag &amp;amp;&amp;amp; document.getElementById('tag-' + tag)) &amp;#123;    document.getElementById('tag-' + tag).style.display = 'block';    document.getElementById('tagTitle').innerHTML = tag;  &amp;#125; else &amp;#123;    document.getElementById('tagTitle').innerHTML = 'Illegal Tag Query';  &amp;#125;&amp;#125;;// 如上需要你模板定义是按照tag将博文提前聚合成块~Inspired by: Wenli Zhang - Jekyll Tag Searching 

插件自动生成不用插件的方法的劣势显而易见. 而引入插件就是帮助我们客服这种缺点的. 既然我们不想要手动的去维护tag数据, 而是希望比较一劳永逸的每次build时自动创建. 那么如何操作呢? 其实也很简单:
首先我们需要以下几个材料:

_plugins文件夹, 位于根目录下;
tagpage template文件, 同无插件法;

有了上述基本材料, 我们就可以开始写我们的标签页生成插件了.
jekyll是基于ruby的, 所以jekyll的插件也都是ruby来写的, 有兴趣的朋友可以自行学习以下, 没兴趣的朋友可以直接那我下面的代码用, 按照我备注的部分修改下即可:1234567891011121314151617181920212223242526272829303132333435363738module Jekyll  class TagIndex &amp;lt; Page    def initialize(site, base, dir, tag)      @site = site      @base = base      @dir = dir      @name = 'index.html'      self.process(@name)      self.read_yaml(File.join(base, '_layouts'), 'tagpage.html')      // _layouts和tagpage.html即是我们的tagpage template所在了      self.data['tag'] = tag      tag_title_prefix = site.config['tag_title_prefix'] || 'Posts Tagged &amp;amp;ldquo;'      tag_title_suffix = site.config['tag_title_suffix'] || '&amp;amp;rdquo;'      // 写在单页里面title域的部分      self.data['title'] = &quot;#&amp;#123;tag_title_prefix&amp;#125;#&amp;#123;tag&amp;#125;#&amp;#123;tag_title_suffix&amp;#125;&quot;    end  end  class TagGenerator &amp;lt; Generator    safe true    def generate(site)      if site.layouts.key? 'tagpage'      // 如果你用的模板名称不是&quot;tagpage.html&quot;的话, 记得修改这里的名字        dir = site.config['tag_dir'] || 'tag'        // 如果你想要自己定义tag单页存储的路径, 或者说是访问路径中的tag前缀, 可以在config里面设定 tag_dir 的值, 或者是直接改这里也行~        site.tags.keys.each do |tag|          write_tag_index(site, File.join(dir, tag), tag)        end      end    end    def write_tag_index(site, dir, tag)      index = TagIndex.new(site, site.source, dir, tag)      index.render(site.layouts, site.site_payload)      index.write(site.dest)      site.pages &amp;lt;&amp;lt; index    end  endend
上述的插件就可以帮助你自行给每一个tag都创建一个目录和对应的index.html文件, 你就可以通过对应的路径访问了.
总结ruby的插件体系真的很赞啊! 哈哈 上述就是如何折腾出tag专属页的方法啦, 你可以通过点击我blog首页每条博文下方的标签就能查看效果了~
参考资料
Separate pages per tag/category with Jekyll (without plugins)
charliepark tag_gen.rb

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>优化 Jekyll 的相关文章列表</title><link>http://taoalpha.me/blog/2015/06/06/tech-jekyll-related-posts-optimization/</link><category>tech</category><tag>jekyll,related post,ruby</tag><pubDate>2015-06-06T07:00:00.000Z</pubDate><description>缘起相关文章这个模块一直算是博客的一个标配组件之一, jekyll默认也是有着site.related_posts这个函数的, 可以调用jekyll帮助你生成的相关博文列表. 不过其准确性和相关性都很让人不放心… 从其源码来看, 在默认关闭lsi的情况下, related_post产出的其实就是简单的最近文章列表… 
这样当然不可以! 于是, 本文就是我在针对related_post这部分做了一些优化后的产物~ 请君品鉴 ^_^
无插件方法首先当然是希望能在不使用插件的情况下实现, 于是就看到了Jekyll Related Posts without Plugin - 羡辙杂俎 这个大神级妹子的博文~ 很有启发性嘛 基本上我要做的她都做过啦…哈哈
不过我稍微简化了以下代码以及结构, 所以可能会更易懂一些喽~哈
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#21033;&amp;#29992;split &amp;#26469;&amp;#24418;&amp;#25104;&amp;#19968;&amp;#20010;&amp;#31354;&amp;#25968;&amp;#32452;, &amp;#36825;&amp;#37324;&amp;#20027;&amp;#35201;&amp;#26159;&amp;#25105;&amp;#19981;&amp;#30693;&amp;#36947;liquid&amp;#22914;&amp;#20309;&amp;#30452;&amp;#25509;&amp;#20889;array... &amp;#123;% endcomment %&amp;#125; &amp;#10;&amp;#123;% assign postsAfterFilter = &amp;#39;-&amp;#39; | split: &amp;#34;-&amp;#34; %&amp;#125;&amp;#10;&amp;#123;% for post in site.related_posts %&amp;#125;&amp;#10;  &amp;#123;% assign commonTagCount = 0 %&amp;#125;&amp;#10;  &amp;#123;% if post.title != page.title and post.series != page.series %&amp;#125;&amp;#10;    &amp;#123;% for tag in post.tags %&amp;#125; &amp;#10;      &amp;#123;% if page.tags contains tag %&amp;#125;&amp;#10;&amp;#10;        &amp;#123;% comment %&amp;#125; &amp;#32479;&amp;#35745;&amp;#20849;&amp;#21516;&amp;#30340;tag&amp;#30340;&amp;#25968;&amp;#30446;, &amp;#29992;&amp;#26469;&amp;#21518;&amp;#38754;&amp;#30340;&amp;#31579;&amp;#36873;&amp;#20197;&amp;#21450;&amp;#25490;&amp;#24207;&amp;#29992; &amp;#123;% endcomment %&amp;#125; &amp;#10;        &amp;#123;% assign commonTagCount = commonTagCount | plus: 1 %&amp;#125;&amp;#10;      &amp;#123;% endif %&amp;#125;&amp;#10;    &amp;#123;% endfor %&amp;#125;&amp;#10;    &amp;#123;% if commonTagCount &amp;#62; 0 %&amp;#125;&amp;#10;&amp;#10;      &amp;#123;% comment %&amp;#125; &amp;#23558;&amp;#31526;&amp;#21512;&amp;#26465;&amp;#20214;&amp;#30340;post&amp;#25918;&amp;#20837;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#25968;&amp;#32452;&amp;#20043;&amp;#20013; &amp;#123;% endcomment %&amp;#125; &amp;#10;      &amp;#123;% assign postsAfterFilter = postsAfterFilter | push: post %&amp;#125;&amp;#10;    &amp;#123;% endif %&amp;#125;&amp;#10;  &amp;#123;% endif %&amp;#125;&amp;#10;&amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#23481;&amp;#38169;&amp;#21028;&amp;#26029;, &amp;#30830;&amp;#20445;&amp;#26377;&amp;#30456;&amp;#20851;&amp;#25991;&amp;#31456;&amp;#30340;&amp;#26102;&amp;#20505;&amp;#20877;&amp;#23637;&amp;#31034;&amp;#30456;&amp;#20851;&amp;#25991;&amp;#31456; &amp;#123;% endcomment %&amp;#125; &amp;#10;&amp;#123;% if postsAfterFilter.size &amp;#62; 0 %&amp;#125;&amp;#10;&amp;#60;div class=&amp;#34;relatedposts&amp;#34;&amp;#62;&amp;#10;  &amp;#60;h2&amp;#62;Related Posts:&amp;#60;/h2&amp;#62;&amp;#10;  &amp;#60;ul class=&amp;#34;article-list&amp;#34;&amp;#62;&amp;#10;  &amp;#123;% for post in postsAfterFilter limit: 5 %&amp;#125;&amp;#10;    &amp;#60;li&amp;#62;&amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; site.baseurl &amp;#125;&amp;#125;&amp;#123;&amp;#123; post.url &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#123;&amp;#123; post.title &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#60;/li&amp;#62;&amp;#10;  &amp;#123;% endfor %&amp;#125;&amp;#10;  &amp;#60;/ul&amp;#62;&amp;#10;&amp;#60;/div&amp;#62;&amp;#10;&amp;#123;% endif %&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
思路很简单, 确保其具有共同tag, 在无相关文章的情况下就不展示此模块了. 因为本身liquid的语法非常有限, 不借助插件的情况下, 想要实现更多功能的话, 就比较麻烦了. 如果有哪位XDJM有不借助插件的排序, 求务必告知我哦~
### Update哈哈, 和朋友@小田讨论了下, 终于想到一个不用插件实现排序的方法了~ 代码如下:1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#19968;&amp;#33268;&amp;#21040;&amp;#33719;&amp;#21462;postsAfterFilter&amp;#20197;&amp;#21450;tagCountEachPost&amp;#30340;&amp;#37096;&amp;#20998;&amp;#37117;&amp;#27809;&amp;#26377;&amp;#21464;&amp;#21270;&amp;#123;% endcomment %&amp;#125;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#19979;&amp;#38754;&amp;#21017;&amp;#20351;&amp;#29992;&amp;#20102;&amp;#19968;&amp;#20010;&amp;#21472;&amp;#21152;for&amp;#24490;&amp;#29615;&amp;#26469;&amp;#36880;&amp;#27425;&amp;#23547;&amp;#25214;&amp;#26368;&amp;#22823;&amp;#30340;tagcount, &amp;#28982;&amp;#21518;&amp;#21516;&amp;#27493;&amp;#36755;&amp;#20986;&amp;#23545;&amp;#24212;postsAfterFilter&amp;#30340;&amp;#20540;&amp;#123;% endcomment %&amp;#125;&amp;#10;&amp;#123;% if postsAfterFilter.size &amp;#62; 0 %&amp;#125;&amp;#10;&amp;#60;div class=&amp;#34;relatedposts&amp;#34;&amp;#62;&amp;#10;  &amp;#60;h2&amp;#62;Related Posts:&amp;#60;/h2&amp;#62;&amp;#10;  &amp;#60;ul class=&amp;#34;article-list&amp;#34;&amp;#62;&amp;#10;&amp;#123;% assign j = tagCountEachPost | size | minus: 1 %&amp;#125;&amp;#10;&amp;#123;% assign maxIndex = 0 %&amp;#125;&amp;#10;&amp;#123;% assign getFirstNumber = true %&amp;#125;&amp;#10;&amp;#123;% assign selectedIndex = &amp;#34;-&amp;#34;|split: &amp;#34;-&amp;#34; %&amp;#125;&amp;#10;&amp;#123;% for p in (0..j) %&amp;#125;&amp;#10;  &amp;#123;% for i in (0..j) %&amp;#125;&amp;#10;    &amp;#123;% unless selectedIndex contains i %&amp;#125;&amp;#10;      &amp;#123;% if getFirstNumber %&amp;#125;&amp;#10;        &amp;#123;% assign firstNumber = tagCountEachPost[i] %&amp;#125;&amp;#10;        &amp;#123;% assign getFirstNumber = false %&amp;#125;&amp;#10;      &amp;#123;% endif %&amp;#125;&amp;#10;      &amp;#123;% if tagCountEachPost[i] &amp;#62;= firstNumber %&amp;#125;&amp;#10;        &amp;#123;% assign firstNumber = tagCountEachPost[i] %&amp;#125;&amp;#10;        &amp;#123;% assign maxIndex = i %&amp;#125;&amp;#10;      &amp;#123;% endif %&amp;#125;&amp;#10;    &amp;#123;% endunless %&amp;#125;&amp;#10;  &amp;#123;% endfor %&amp;#125;&amp;#10;  &amp;#123;% assign getFirstNumber = true %&amp;#125;&amp;#10;  &amp;#123;% assign selectedIndex = selectedIndex | push: maxIndex %&amp;#125;&amp;#10;  &amp;#123;% if selectedIndex.size &amp;#60; 6 %&amp;#125;&amp;#10;    &amp;#60;li&amp;#62;&amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; site.baseurl &amp;#125;&amp;#125;&amp;#123;&amp;#123; postsAfterFilter[maxIndex][&amp;#39;url&amp;#39;] &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#123;&amp;#123; postsAfterFilter[maxIndex][&amp;#39;title&amp;#39;] &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#60;/li&amp;#62;&amp;#10;  &amp;#123;% endif %&amp;#125;&amp;#10;&amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#60;/ul&amp;#62;&amp;#10;&amp;#60;/div&amp;#62;&amp;#10;&amp;#123;% endif %&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;思路也很简单, 就是利用for循环写出一个找最大元素的方法, 然后每次记录下最大元素的index, 就能同步输出对应的post了~ 需要注意的就是为了保证index的一一对应, 需要单独保存每次找到的最大值的index, 然后在下一次遍历中跳过赞!

有插件下增加排序功能liquid 部分在上面的基础上(在update之前的基础上), 首先我们需要在liquid中添加几行代码:
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#39318;&amp;#20808;&amp;#38656;&amp;#35201;&amp;#23450;&amp;#20041;&amp;#19968;&amp;#20010;&amp;#26032;&amp;#30340;&amp;#21464;&amp;#37327;, &amp;#29992;&amp;#26469;&amp;#35760;&amp;#24405;&amp;#20849;&amp;#21516;&amp;#30340;tag&amp;#25968;&amp;#30446; &amp;#123;% endcomment %&amp;#125; &amp;#10;&amp;#123;% assign tagCountEachPost = &amp;#39;-&amp;#39; | split: &amp;#34;-&amp;#34; %&amp;#125;&amp;#10;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#22312;&amp;#36825;&amp;#19968;&amp;#27493;&amp;#31867;&amp;#20284;&amp;#28155;&amp;#21152;&amp;#30340;post&amp;#30340;&amp;#26041;&amp;#24335;, &amp;#25226;&amp;#23545;&amp;#24212;&amp;#30340;&amp;#20849;&amp;#21516;tag&amp;#25968;&amp;#30446;&amp;#20063;&amp;#32452;&amp;#25104;&amp;#19968;&amp;#20010;&amp;#32467;&amp;#26500;&amp;#19968;&amp;#26679;&amp;#30340;&amp;#23545;&amp;#24212;&amp;#25968;&amp;#32452;&amp;#123;% endcomment %&amp;#125; &amp;#10;&amp;#123;% if commonTagCount &amp;#62; 0 %&amp;#125;&amp;#10;  &amp;#123;% assign postsAfterFilter = postsAfterFilter | push: post %&amp;#125;&amp;#10;  &amp;#123;% assign tagCountEachPost = tagCountEachPost | push: commonTagCount %&amp;#125;&amp;#10;&amp;#123;% endif %&amp;#125;&amp;#10;&amp;#10;&amp;#123;% comment %&amp;#125; &amp;#36825;&amp;#37324;&amp;#23545;&amp;#25991;&amp;#31456;&amp;#36827;&amp;#34892;&amp;#23545;&amp;#24212;&amp;#30340;&amp;#31579;&amp;#36873;, &amp;#38656;&amp;#35201;&amp;#20511;&amp;#21161;&amp;#25105;&amp;#20204;&amp;#33258;&amp;#23450;&amp;#20041;&amp;#30340;filter&amp;#23454;&amp;#29616; &amp;#123;% endcomment %&amp;#125; &amp;#10;&amp;#123;% assign postsAfterFilter = postsAfterFilter | sort_by_array: &amp;#123;&amp;#123;tagCountEachPost&amp;#125;&amp;#125; %&amp;#125;&amp;#10;      &amp;#10;&amp;#123;% endraw %&amp;#125;
下面就是插件环节~
插件部分Jekyll 的插件都是.rb结尾的文件, 放在_plugins路径下即可. 这里filters.rb是我用来专门放置我自己定制的filter的:
12345678910111213141516171819# filters.rbmodule Jekyll  module CustomizeFilter    def sort_by_array(fArray,sArray)      newObj = &amp;#123;&amp;#125;      newArray = []      sArray.each_index do |x|        newObj[x] = sArray[x]      end      newObj.sort_by&amp;#123;|_key, value| value &amp;#125;.each do |x,y|        newArray.push(fArray[x])      end      newArray.reverse!    end  endendLiquid::Template.register_filter(Jekyll::CustomizeFilter)
如此基本就算搞定啦~
参考资料
Jekyll Related Posts without Plugin - 羡辙杂俎 
Custom Jekyll filter for tags
How to sort a Ruby Hash by number value?

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Jekyll 添加翻页部分(包含分类页,标签页)</title><link>http://taoalpha.me/blog/2015/06/02/tech-jekyll-paginator-for-all-page/</link><category>tech</category><tag>jekyll,paginator,ruby</tag><pubDate>2015-06-02T13:00:00.000Z</pubDate><description>缘起随着博文数量正式达到15篇以上, 我寻思着也是时候给blog增加一个翻页的部分了.  首先当然是研究jekyll的官方文档, 然后再结合我们自己的需求进行修改. 因为考虑到blog的通常结构都会有category和tag, 而且昨天刚刚增加了 tag专属页, 所以就希望能够在category和tag页下都增加一个翻页的模块. 而目前jekyll的默认paginator尚无法支持这样的需求, 我们只能自己动手喽~
jekyll paginator开启翻页模块jekyll有默认的paginator, 可以非常简单的开启. 只需要在_config.yml中加入下面这行行即可:1&amp;#123;% raw %&amp;#125;&amp;#10;paginate: 2&amp;#10;&amp;#123;% endraw %&amp;#125;
这里的paginate表示是单页显示的博文条数. 这里设置2也是为了方便测试, 具体数值大家根据需要自行调整即可.
通过设定paginate后, 就可以重新build一下jekyll, 你就会发现在_site/blog路径下多出了一些pageX的文件夹了~ 这些就是生成的分页了.
添加翻页导航模块开启翻页后, 就需要我们自行在页面上添加上翻页导航组件了. 这里需要借助paginator这个对象, 其包含了当前页面下分页的一些基本属性. 具体参照下面的代码即可.
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% if paginator.total_pages &amp;#62; 1 %&amp;#125;&amp;#10;&amp;#60;div class=&amp;#34;pagination&amp;#34;&amp;#62;&amp;#10;  &amp;#123;% if paginator.previous_page %&amp;#125;&amp;#10;    &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; paginator.previous_page_path | prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#38;laquo; Prev&amp;#60;/a&amp;#62;&amp;#10;  &amp;#123;% else %&amp;#125;&amp;#10;    &amp;#60;span&amp;#62;&amp;#38;laquo; Prev&amp;#60;/span&amp;#62;&amp;#10;  &amp;#123;% endif %&amp;#125;&amp;#10;&amp;#10;  &amp;#123;% for page in (1..paginator.total_pages) %&amp;#125;&amp;#10;    &amp;#123;% if page == paginator.page %&amp;#125;&amp;#10;      &amp;#60;em&amp;#62;&amp;#123;&amp;#123; page &amp;#125;&amp;#125;&amp;#60;/em&amp;#62;&amp;#10;    &amp;#123;% elsif page == 1 %&amp;#125;&amp;#10;      &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; &amp;#39;/&amp;#39; | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#123;&amp;#123; page &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#10;    &amp;#123;% else %&amp;#125;&amp;#10;      &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; site.paginate_path | prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; | replace: &amp;#39;:num&amp;#39;, page &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#123;&amp;#123; page &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#10;    &amp;#123;% endif %&amp;#125;&amp;#10;  &amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#10;  &amp;#123;% if paginator.next_page %&amp;#125;&amp;#10;    &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; paginator.next_page_path | prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;Next &amp;#38;raquo;&amp;#60;/a&amp;#62;&amp;#10;  &amp;#123;% else %&amp;#125;&amp;#10;    &amp;#60;span&amp;#62;Next &amp;#38;raquo;&amp;#60;/span&amp;#62;&amp;#10;  &amp;#123;% endif %&amp;#125;&amp;#10;&amp;#60;/div&amp;#62;&amp;#10;&amp;#123;% endif %&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
当然, 对应的页码显示样式就要看大家自己设定喽~
定制翻页插件插件部分如果只需要在首页开启翻页的话, 如此倒也是足够了. 但是如果想要在category以及tag分页上都加上翻页导航的话, 就需要在上述基础上自行定制了.
首先我们可以学习以下默认的pagination是如何做的, 这一点我们可以在github上jekyll-paginate的主页查看其源码.
可以看到基本方法是完全可以通用的, 只是默认情况下的pager这个包含了翻页信息的对象只包含在了首页的创建上. 我们完全可以在生成tag页和category页的时候也同时生成一个对应的pager对象. 接下来我们就可以在原来的 jekyll生成tag页中的示例代码基础上加上pager.
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module Jekyll  class TagIndex &amp;lt; Page    def initialize(site, base, dir, tag)      @site = site      @base = base      @dir = dir      @name = 'index.html'      self.process(@name)      self.read_yaml(File.join(base, '_layouts'), 'tagpage.html')      self.data['tag'] = tag      tag_title_prefix = site.config['tag_title_prefix'] || 'Posts Tagged &amp;amp;ldquo;'      tag_title_suffix = site.config['tag_title_suffix'] || '&amp;amp;rdquo;'      self.data['title'] = &quot;#&amp;#123;tag_title_prefix&amp;#125;#&amp;#123;tag&amp;#125;#&amp;#123;tag_title_suffix&amp;#125;&quot;      self.data['pname'] = &quot;tag/#&amp;#123;tag&amp;#125;&quot;      // 自定义的一个页面标识, 同时也为了后面修改tag单页增加一个url前缀用的    end  end  class TagGenerator &amp;lt; Generator    safe true    def generate(site)      if site.layouts.key? 'tagpage'        dir = site.config['tag_dir'] || 'tag'        site.tags.keys.each do |tag|          write_tag_index(site, File.join(dir, tag), tag)          #write_tag_index(site, File.join(dir, tag.split.map(&amp;amp;:capitalize).join(&quot;-&quot;)), tag.split.map(&amp;amp;:capitalize).join(&quot;-&quot;))        end      end    end    def write_tag_index(site, dir, tag)      // 下述代码有所修改, 注意!      tag_posts = site.posts.find_all &amp;#123;|post| post.tags.include?(tag)&amp;#125;.sort_by &amp;#123;|post| -post.date.to_f&amp;#125;      // 当前tag的所有post      num_pages = TagPager.calculate_pages(tag_posts, site.config['paginate'].to_i)      // 所有post分出的页数      (1..num_pages).each do |page|        pager = TagPager.new(site, page, tag_posts, tag, num_pages)        index = TagIndex.new(site, site.source, dir, tag)        index.pager = pager        index.dir = dir        if page != 1          index.dir = File.join(dir, &quot;page#&amp;#123;page&amp;#125;&quot;)          // 生成page路径        end        index.render(site.layouts, site.site_payload)        index.write(site.dest)        site.pages &amp;lt;&amp;lt; index      end    end  end  class TagPager &amp;lt; Jekyll::Paginate::Pager    // 继承paginate::pager的类, 直接使用了    attr_reader :tag    def initialize(site, page, all_posts, tag, num_pages = nil)      @tag = tag      super site, page, all_posts, num_pages    end    alias_method :original_to_liquid, :to_liquid    def to_liquid      liquid = original_to_liquid      liquid['tag'] = @tag      liquid    end  endend
如上, 基本插件部分就没啥事了~ 当然, category的部分几乎可以说是完全一样的, 只需要把对应tag的部分全部替换为category的相应属性就行啦. 这里就不占位的贴代码了.
页面导航组件显示部分页面级的改动也不多, 因为我的category, 首页, tag页用的是同一个模板, 所以修改起来相对容易~ 只是针对不同的页码调整了以下翻页导航的url构成~ 如下:
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% if paginator.total_pages &amp;#62; 1 %&amp;#125;&amp;#10;&amp;#123;% assign pname = page.pname %&amp;#125;&amp;#10;&amp;#123;% if page.pname == &amp;#34;blog&amp;#34; %&amp;#125;&amp;#10;  &amp;#123;% assign pname = &amp;#34;&amp;#34; %&amp;#125;&amp;#10;&amp;#123;% endif %&amp;#125;&amp;#10;&amp;#60;!-- pname&amp;#23601;&amp;#26159;&amp;#25105;&amp;#20043;&amp;#21069;&amp;#25554;&amp;#20214;&amp;#20013;&amp;#21152;&amp;#20837;&amp;#30340;&amp;#37027;&amp;#20010;&amp;#29992;&amp;#26469;&amp;#34920;&amp;#26126;&amp;#25152;&amp;#23646;&amp;#39029;&amp;#38754;&amp;#23646;&amp;#24615;&amp;#30340;, &amp;#39034;&amp;#24102;&amp;#20063;&amp;#25925;&amp;#24847;&amp;#20889;&amp;#25104;&amp;#20102;&amp;#26041;&amp;#20415;&amp;#28155;&amp;#21152;url&amp;#30340;&amp;#36335;&amp;#24452;&amp;#26684;&amp;#24335;, &amp;#19988;&amp;#19979;&amp;#38754;&amp;#36825;&amp;#20123;&amp;#36335;&amp;#24452;&amp;#36824;&amp;#38656;&amp;#35201;&amp;#26681;&amp;#25454;&amp;#20855;&amp;#20307;&amp;#24773;&amp;#20917;&amp;#33258;&amp;#34892;&amp;#35843;&amp;#25972;~ --&amp;#62;&amp;#10;&amp;#60;div class=&amp;#34;pagination&amp;#34;&amp;#62;&amp;#10;  &amp;#123;% if paginator.previous_page %&amp;#125;&amp;#10;    &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; paginator.previous_page_path | prepend: &amp;#34;/&amp;#34; | prepend: pname | prepend: &amp;#34;/&amp;#34; | prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#38;laquo; Prev&amp;#60;/a&amp;#62;&amp;#10;  &amp;#123;% else %&amp;#125;&amp;#10;    &amp;#60;span&amp;#62;&amp;#38;laquo; Prev&amp;#60;/span&amp;#62;&amp;#10;  &amp;#123;% endif %&amp;#125;&amp;#10;&amp;#10;  &amp;#123;% for page in (1..paginator.total_pages) %&amp;#125;&amp;#10;    &amp;#123;% if page == paginator.page %&amp;#125;&amp;#10;      &amp;#60;em&amp;#62;&amp;#123;&amp;#123; page &amp;#125;&amp;#125;&amp;#60;/em&amp;#62;&amp;#10;    &amp;#123;% elsif page == 1 %&amp;#125;&amp;#10;      &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; &amp;#39;/&amp;#39; | prepend: pname |prepend: &amp;#34;/&amp;#34;| prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#123;&amp;#123; page &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#10;    &amp;#123;% else %&amp;#125;&amp;#10;      &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; site.paginate_path | prepend: &amp;#34;/&amp;#34; | prepend: pname | prepend: &amp;#34;/&amp;#34; | prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; | replace: &amp;#39;:num&amp;#39;, page &amp;#125;&amp;#125;&amp;#34;&amp;#62;&amp;#123;&amp;#123; page &amp;#125;&amp;#125;&amp;#60;/a&amp;#62;&amp;#10;    &amp;#123;% endif %&amp;#125;&amp;#10;  &amp;#123;% endfor %&amp;#125;&amp;#10;&amp;#10;  &amp;#123;% if paginator.next_page %&amp;#125;&amp;#10;    &amp;#60;a href=&amp;#34;&amp;#123;&amp;#123; paginator.next_page_path | prepend: &amp;#34;/&amp;#34; | prepend: pname | prepend: &amp;#34;/&amp;#34; | prepend: site.baseurl | replace: &amp;#39;//&amp;#39;, &amp;#39;/&amp;#39; &amp;#125;&amp;#125;&amp;#34;&amp;#62;Next &amp;#38;raquo;&amp;#60;/a&amp;#62;&amp;#10;  &amp;#123;% else %&amp;#125;&amp;#10;    &amp;#60;span&amp;#62;Next &amp;#38;raquo;&amp;#60;/span&amp;#62;&amp;#10;  &amp;#123;% endif %&amp;#125;&amp;#10;&amp;#60;/div&amp;#62;&amp;#10;&amp;#123;% endif %&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
恩, 完事! 剩下的就是大家根据自己的需要来赋予翻页组件合适的样式喽~
结论本人的ruby属于初学, 所以代码基本是我参照源码和前人的经验修改而来的~ 也算是学习的过程, 基本参照对象都会列在下面的参考资料中~ 尽请翻看~
参考资料
jekyll-paginate github
nicoespeon category_pagination
jekyll pagination 官方说明

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Jekyll 中如何做中文字数统计</title><link>http://taoalpha.me/blog/2015/05/21/tech-jekyll-count-of-chinese-characters/</link><category>tech</category><tag>jekyll</tag><pubDate>2015-05-21T07:00:00.000Z</pubDate><description>这两天又优化了以下blog, 首先是给天气部分加上了cookie和定位控制, 这样一方面能减少对openweather的请求次数, 同时优化加载的速度, 另一方面也能更加智能化的显示天气. 当然, 为了防止定位错误的问题, 我也同时增加了自定义位置的功能, 同样给予了cookie记录. 具体的实现方法, 这里就不多说了, 也很简单.
本文主要是介绍下jekyll中如何实现中文的字数统计. 为什么要做字数统计呢? 还是来源于简书-文章页, 里面详细的记录了作者的信息以及当前文章的字数. 再加上一个实时统计的阅读次数, 当然对我而言, 这个实时阅读次数意义不大, 我就顺着字数统计改成了阅读时间估计. 恩, 没错, 又是模仿medium的~ ಥ_ಥ
字数统计方法如何统计一段文本的字数是有很多种方法的, 但是因为语言文字的不同, 很多时候, 不同的方法对不同的语言文字适用性是不一样的. 目前来说, 通常有以下几种字数统计方案:

根据常规的一个中文字符等于两个英文字母的概念, 通过获取整个文本的长度(比如js中的length), 除以2就可以获得一个粗略的值了, 如果要精确些, 可以在上述方法的基础上加入charCodeAt()来判断字符属性是中文还是英文字母, 然后区分计算;
如果是纯英文, 通常统计的都是词数而非字数, 而英文天然的空格分词, 也让统计其词数非常容易, 只需要按照空格切分获取长度即可;
如果是纯中文, 我们统计的则多数是字数, 这种情况下, 因为中文缺少类似英文空格这种天然的切分符号, 就不能单纯的使用切分法来获取字数了, 可以借鉴第一种方法所述, 通过去除换行以及标签符号, 然后获取最后的数组大小来实现;
如果是中英文混杂, 那么同样可以使用上述方法获得粗略数值, 当然, 如果你需要精确的话, 也需要对文本字符属性做判断来区分处理;

jekyll中的词数统计number_of_words是jekyll中已有的一个词数统计过滤器, 可以很方便的统计出文本的英文词数, 但对中文就不适用了… 因为它本身是根据空格, 标点符号等来切分统计的, 有的时候甚至连英文都可能不准确… 
取巧的统计方式jekyll支持的众多filter中, 有这么一个size, 是可以返回一个数组的大小的, 而且能够正确的理解类似中文GBK的编码的. 于是我们可以使用类似:
1&amp;#123;% raw %&amp;#125;&amp;#10;Approximate number of English words: &amp;#123;&amp;#123; text | split: &amp;#34; &amp;#34; | size &amp;#125;&amp;#125;&amp;#10;Approximate number of Chinese words: &amp;#123;&amp;#123; text | split: &amp;#34;&amp;#34; | size &amp;#125;&amp;#125;&amp;#10;// &amp;#21487;&amp;#20197;&amp;#30475;&amp;#21040;&amp;#37117;&amp;#26159;&amp;#36817;&amp;#20284;&amp;#20540;~ &amp;#22914;&amp;#26524;&amp;#20320;&amp;#23545;&amp;#31934;&amp;#24230;&amp;#35201;&amp;#27714;&amp;#27809;&amp;#37027;&amp;#20040;&amp;#39640;, &amp;#37027;&amp;#20040;&amp;#22522;&amp;#26412;&amp;#26159;&amp;#22815;&amp;#29992;&amp;#20102;~&amp;#10;// &amp;#23454;&amp;#38469;&amp;#19978;, &amp;#22240;&amp;#20026;&amp;#26412;&amp;#36523;size&amp;#25903;&amp;#25345;&amp;#25991;&amp;#26412;, &amp;#25152;&amp;#20197;&amp;#23545;&amp;#20013;&amp;#25991;&amp;#36825;&amp;#37324;&amp;#21487;&amp;#20197;&amp;#19981;&amp;#29992;split: &amp;#34;&amp;#34;&amp;#30340;&amp;#10;&amp;#123;% endraw %&amp;#125;
那么回过头, 我们如果要统计content里面的中文字数就可以利用size这个方法了. 不过考虑到content里面有很多html的tag, 我们为了更加接近真实数值, 可以借用strip_html以及strip_newlines两个过滤器来去除所有的html tag和空行. 那么最终的代码就是:
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123; &amp;#123; content | strip_html | strip_newlines | size &amp;#125; &amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
其实在jekyll的github issue中有人已经问过类似的问题jekyll的中文切分问题. 
阅读速度问题既然获得了字数, 那么想要获得阅读时间就很容易了, 通常英文单词的阅读速度在350wpm(词每分钟), 而中文也是基本接近的350字每分钟左右. 那么这次利用divided_by以及round两个函数就可以获得一个大致的分钟数了:(有兴趣的可以前往参考来源的第二条中看关于中文, 英文阅读速度的一篇文章)
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123; content | strip_html | strip_newlines | size | divided_by:350 | round&amp;#125;&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
参考来源
jekyll的中文切分问题
Which reads faster, Chinese or English?

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Bubble Sort and Merge Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-2/</link><category>tech</category><tag>Algorithm,JS,Sorting</tag><pubDate>2015-10-29T08:00:00.000Z</pubDate><description>IntroductionBubble sort is really cool but not so useful, it seems that you will never use it… But merge sort is really cool since it is really fast.
Bubble SortSo what is bubble sort, according to wikipedia:

Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. 

The whole process of sorting is like the bigger element “bubble” to the end of the list.

Input: A list of numbers with random order
Procedures:
Start from the head of the list, and compare every two adjacent numbers and swap them if they are in wrong order;
Record whether you did any swaps or not, if no, your list has been sorted, otherwise, you need to step 1 again;


Output: A sorted list

If you like, you can do a small optimization to the procedures above: since every iteration we will make sure the bigger element will “bubble” to the end of the list, so everytime we don’t need to check the last elements(they are already in ordered), and we will reduce the length for each iteration.
Here is a nice gif from wikipedia: 
The time complexity for bubble sort would be : O(n^2) for worst case, O(n) for best case, and O(n^2) on average.
The space complexity for bubble sort would be O(1) since we only need one space used to do the swap.
Now lets do the code:
1234567891011121314151617181920// bubbleSortfunction bubbleSort(list)&amp;#123;  var swapped  var len = list.length  do&amp;#123;    swapped = false    for(var j = 0;j&amp;lt; len-1;j++)&amp;#123;      reads += 2      if(list[j]&amp;gt;list[j+1])&amp;#123;        this.swap(list,j,j+1)        swapped = true        writes += 2      &amp;#125;    &amp;#125;    len = len - 1    // since everytime we will move the largest element to the end of the list, we can reduce the number of iteration without considering the last element every iteration  &amp;#125;while(swapped)  return list&amp;#125;
Merge SortNow we met all three different kinds of sorting, all of them have a O(n^2) of time complexity on average.
Lets do something faster: Merge Sort.
Imagine you separate your list into several really small lists with only one element or zero element in each of them. Then you merge every two small lists into one sorted list, and keep doing it repeatly.(it’s easy because you are merging two sorted lists)
The whole procedures will be:

Split the list recursively;
Merge the small lists until you merge them all;

Since we always split by half, the number of small lists we will have would be log(n), and the total cost would be close to (n / 2 * log(n)) on average(since we have at least 1 element list to merge with zero one, at most n/2 elements list to merge with n/2 elements). So the time complexity would be O(nlog(n)) all the time, and the space complexity would be O(n) since we will save origin input list with n small lists.
1234567891011121314151617181920// mergeSortfunction mergeSort(list)&amp;#123;  if(list.length &amp;lt;= 1) return list  var mid = Math.floor(list.length / 2)  return merge(mergeSort(list.slice(0,mid)),mergeSort(list.slice(mid)))&amp;#125;function merge(left,right)&amp;#123;  var nl = []  var il = 0, ir = 0  while(il&amp;lt;left.length &amp;amp;&amp;amp; ir&amp;lt;right.length)&amp;#123;    if(left[il] &amp;lt; right[ir])&amp;#123;      nl.push(left[il++])    &amp;#125;else&amp;#123;      nl.push(right[ir++])    &amp;#125;    // don't use shift because shift will actually cause a lot I/Os   &amp;#125;  nl = nl.concat(left.slice(il)).concat(right.slice(ir))  return nl&amp;#125;
SummaryMerge sort is kind useful, and if we don’t have quick sort which I will talk about next post, it would be a really good choice to do sorting. And even we have quick sort, merge sort still exists in many languages as part of their default sorting algorithm.
And also there are several optimizations for merge sort, if you are interested in, you can search it on google.
That’s all for today. Good night!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Sorting Algorithm in JavaScript - Insertion Sort and Selection Sort</title><link>http://taoalpha.me/blog/2015/10/29/tech-javascript-sorting-algorithm-1/</link><category>tech</category><tag>Algorithm,JS,Sorting</tag><pubDate>2015-10-29T08:00:00.000Z</pubDate><description>Sorting AlgorithmAs the most important and fundamental algorithm, sorting algorithm is always the best start to learn algorithm.
Among all the different sorting algorithms, we have 10 algorithms which are used a lot in practice, and I will introduce all these ten algorithms one by one. 
Today we will talk about: Selection Sort and Insertion Sort.
Selection SortSelection Sort is one of the most fundamental sort algorithms you would learn from any book about algorithm. The method and theory based on is really easy and clear:

input: a list of numbers need to be sorted
procedures:
create a new list to save the sorted elements
select the minimum element from the input list and push it into the new list, and remove it from the input list
repeat the second step until we don’t have any more elements in input list


output: the list you created to save the sorted elements

Easy, huh ? Let’s calculate the cost: the average time complexity would be n^2/2 which would be O(n^2), since we need check the input list n times with n/2 elements to check every time; and since we are using a new list to save the output, it would be O(n) space.
Can we optimize it ? Yes and no. For time complexity, we can not do any optimization since it is the theory that selection sort is using, we have nothing to do with that. But for space complexity, we can do something.
We can actually do the sort in-place which means we can sort the list within the list and return the same list as the input except it is sorted.
In order to do that, we can change the procedures to:

input: a list of numbers need to be sorted
procedures:
start from the first element, we loop over the list from it to the end of the list and select the minimum element from the input list and swap it with it(start element);
repeat it until we reach the last element of the input list(now the start element and the end element would all be the last element)


output: the input list 

By doing this way, we just need two spaces, one is used to save the index of the minimum element, another is used during the swap to save the one of the value that need to be swapped later. The space complexity would be O(1).
1234567891011121314function selectionSort(list)&amp;#123;    for(var i = 0; i &amp;lt; list.length; i++)&amp;#123;      var min = i      for(var j = i+1;j&amp;lt;list.length; j++)&amp;#123;        if(list[min]&amp;gt;list[j])&amp;#123;          min = j        &amp;#125;      &amp;#125;      var temp = list[i]      list[i] = list[min]      list[min] = temp    &amp;#125;    return list  &amp;#125;
Selection Sort is easy but not efficient, since it always costs O(n^2) even your input list is sorted when you pass it in.
Insertion SortNow we come to insertion sort which would a little more efficient than selection sort.
The theory is: consider the left part of the input list as sorted, and insert the new element into the proper position, since if one element always means it is sorted, so we always can do that by starting from the second element.
The procedures:

start from the second element(if you don’t have second element, you are done);
compare every element in the left(sorted part), if it is greater than your start element, shift it to the right by 1, if it is less than your start element, insert your start element before it;
repeat until the end of the list;

Time Complexity: O(n) in the best case(the list is sorted already), O(n^2) in the worst case, on average, it would be similiar to selection sort with O(n^2).
Space Complexity: O(1)
Lets implement it into real code:
1234567891011121314function insertionSort(list)&amp;#123;  for(var i = 1; i &amp;lt; list.length;i++)&amp;#123;    var temp = list[i]    var j = i    while(j&amp;gt;0 &amp;amp;&amp;amp; list[j-1]&amp;gt;temp)&amp;#123;      list[j] = list[j-1]      j--    &amp;#125;    list[j] = temp    // use shift instead of swap can reduce the cost of writing -- nearly 50%    // if you use swap, it will slower than selectionSort  &amp;#125;  return list&amp;#125;
Some people may be used to achieve insertion sort by using the swap too. You can, you just need compare and swap it with previous one until it reaches the right position. But the cost would be high since you will double your writes with swap.

I actually calculate the time cost in javascript, most of time, if you use swap, your insertion sort would be slower than selection sort.

Special NoteIn general, insertion sort would be faster than selection sort if you implement it in right way. But in some special cases, you may find selection sort is faster.
The different between selection sort and insertion sort:

selection sort reads the list a lot(n  (n+1) / 2, n is the length of the list) but only writes into the list a few times(= 2  (the length of your list));
insertion sort reads the list a lot too, but fewer than the selection sort(the worst case would be same with selection, best case would be equal to the length of the list), and meantime, it will write into the list much more times than selection sort(nearly the same with reading times);

So if it costs much more on reading instead of writing, you may consider choosing selection sort instead of insertion sort.
SummaryThat’s all I think you should know about selection sort and insertion sort. Next post I will discuss about bubble sort and merge sort with you. See ya!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript 重载函数实现探究</title><link>http://taoalpha.me/blog/2015/07/11/tech-javascript-overload/</link><category>tech</category><tag>javascript,overload</tag><pubDate>2015-07-11T04:00:00.000Z</pubDate><description>缘起今天看Secrets of the JavaScript Ninja看到js中如何实现重载函数的部分, 然后对着一个只有7,8行代码的函数范例研究了2个多小时… 掩面羞愧难当ing… 为了让记忆更加深刻些, 特意记录下心得以防止以后再次跌在同一个坑里…
JS的重载重载函数重载函数的概念在很多OOP(面向对象的编程), 尤其是C系的语言中是很基本的, 其允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，从而实现同一个函数可以执行不同的逻辑.
但是, javascript中是不存在重载函数这个概念的, 不过其松散的函数(比如参数传递的数量和类型等限制), 变量尤其是其变量类型的自动判断的特点都让我们通常选择在函数的主体逻辑上实现根据参数的不同而执行不同的逻辑. 但是js中能模拟出真正的重载函数吗?
答案是肯定的, 而且很简单, 真的很简答…
JS中的实现方法首先我们来看源码:
123456789101112131415161718192021222324252627282930313233addMethod = (object, name, fn) -&amp;gt;  old = object[name]  object[name] = -&amp;gt;    # console.log fn  # 通过调用fn来了解其每一步的逻辑    if fn.length == arguments.length      fn.apply(@, arguments)    else if typeof old == 'function'      old.apply(@, arguments)example =  values : [&quot;Dean Edwards&quot;, &quot;Sam Stephenson&quot;, &quot;Alex Russell&quot;]addMethod example, &quot;find&quot;, -&amp;gt;    @valuesaddMethod example, &quot;find&quot;, (name) -&amp;gt;    ret = []    for i in [0..@values.length-1]      ret.push(@values[i]) if @values[i].indexOf(name) == 0    retaddMethod example, &quot;find&quot;,(first, last) -&amp;gt;    ret = []    for i in [0..@values.length-1]      ret.push(@values[i]) if @values[i] == first + &quot; &quot; + last    retconsole.log example.find()# [&quot;Dean Edwards&quot;, &quot;Sam Stephenson&quot;, &quot;Alex Russell&quot;]console.log example.find(&quot;Sam&quot;)# [&quot;Sam Stephenson&quot;]console.log example.find(&quot;Alex&quot;,&quot;Russell&quot;)# [&quot;Alex Russell&quot;]
可以看到我们通过addMethod给example连续三次添加了一个find函数, 三个函数之间首要区别就是接受参数的个数不同. 而通过后面的调用发现, 我们成功的实现了不同个数传参对不同find的调用.
下面具体来探讨下, 这是如何实现的:

首先是添加部分: 

三次添加的find所指向的函数逻辑是相同的, 区别在于其old的指向是不同的, 第一次添加时没有old, old是undefined, 而第二次添加的时候old是指向第一次添加时的find的, 而第三次添加的时候old是指向第二次的find的;
需要注意的是, 因为old的存在, fn这个变量在addMethod域内和old域内都是一直存在的(这里包含了一个闭包的实现 Closure):
在addMethod域内因为每次其都会被调用更新, 所以三次添加后, 其指向的就是最后添加的那个函数, 本例中即两个参数的find;
在old域内, 则会指向前一次的find, 本例中第三次添加的old的fn指向的就是第二次添加时addMethod传入的find函数, 即一个参数的;


此外, 要记得arguments.length是我们传入的参数个数, fn.length则代表函数接受的参数个数;


下面我们看下三次执行:

example.find():  毫无悬念, 因为此时fn.length为2(first,last), 但是我们调用传入的arguments长度为0, 所以需要调用old, 即第二次添加的find函数, 此时fn也顺势切换到一个参数的函数, 但还是和arguments.length不同, 所以需要再次调用当前的old, 此时old指向的是第一次执行的addMethod, fn变为0参数,和arguments.length相同了, 我们就可以执行此时的fn了, 即返回example中的全部values的函数;
example.find(&amp;quot;Sam&amp;quot;):  同上, 我们还是需要从fn.length为2的情况开始, 上溯到前一次, fn.length为1时, 符合条件, 执行此时的fn, 即根据name查询;
example.find(&amp;quot;Alex&amp;quot;,&amp;quot;Russell&amp;quot;):  同理, 不过这一次就不用上溯了, 直接可以执行fn了;



通过在addMethod的赋值函数中加入console.log输出fn, 你会把这一过程理解的更为清晰.
总结随着对JS的逐步深入, 越发觉得JS是一个很了不起的语言, 其兼容了Function Programming和OOP. 对开发者有一种极强的普适性, 可以很简单的写函数调用, 也可以实现很复杂的功能. 了不起!
为了缩短文章的长度, 我选择coffeescript来展示源码(可以省掉很多空间), 其实coffeescript真的很简单, 记住几个基本的规则, 理解起来很容易, 逻辑都还是js的逻辑. 有兴趣的可以查看我之前写的 CoffeeScript Programming with jQuery, Rails and Nodejs读书笔记
参考文献
Secrets of the JavaScript Ninja
CoffeeScript - 在线调试

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Implement LRU Cache in JavaScript</title><link>http://taoalpha.me/blog/2015/11/03/tech-javascript-lru-cache/</link><category>tech</category><tag>JS,LRU</tag><pubDate>2015-11-03T05:00:00.000Z</pubDate><description>IntroductionLRU which is short for least recently used is a popular algorithm in cache. The basic idea is always put your items in order of used time, and when you insert new item into the fullfilled chache,remove the least recently used item in your memory.
ImplementationO(n)At first, I plan to use a hashtable and a list with all keys to achieve it, and I did, but the time cost apparently too large: O(n) since I have to search the list to get the key and then get the value from the hashtable.
Here is the code:
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// constructorvar LRUCache = function(capacity)&amp;#123;  // save all key-value pairs in this hashtable  this.bucket = &amp;#123;&amp;#125;  // save all keys in the stack with the order of last used time  this.keys = []  this.capacity = capacity  this.length = 0&amp;#125;LRUCache.prototype.updateKey = function(key)&amp;#123;  // update the position of this key in keys   var keyIndex = this.keys.indexOf(key)  this.keys[keyIndex] = undefined  // update the key to the head of the stack  this.keys.push(key)&amp;#125;LRUCache.prototype.get = function(key)&amp;#123;  if(this.bucket.hasOwnProperty(key))&amp;#123;    this.updateKey(key)    return this.bucket[key]  &amp;#125;else&amp;#123;    return -1  &amp;#125;&amp;#125;LRUCache.prototype.set = function(key,value)&amp;#123;  if(this.capacity &amp;lt;= 0)&amp;#123;console.log(&quot;no memory to save 1 item&quot;);return&amp;#125;  // update exist item   if(this.bucket.hasOwnProperty(key))&amp;#123;    this.bucket[key] = value    this.updateKey(key)    return  &amp;#125;    // if the bucket is fullfilled, remove the least recently used item  if(this.length &amp;gt;= this.capacity)&amp;#123;    var dKey = this.keys.shift()    while(!dKey)&amp;#123;      // if the dKey is undefined, shift() again      dKey = this.keys.shift()    &amp;#125;    delete this.bucket[dKey]  &amp;#125;  // add new item and update the length  this.bucket[key] = value  this.keys.push(key)  this.length ++&amp;#125;
Can we do better ? Definitely. We can optimize it to O(1) if we use double linked list to achieve the same function.
O(1)If we reconstruct the LRUCache with a map and a bunch of nodes, we can implement the LRUCache with O(1).(Since we need to get the value by key, so it has to be a hashtable)
Why? Since we can save the key and value in the node, and save all key-node pairs in the hashtable, and now we can get the value by key using hashtable, and we also have a list of nodes with order of last used time and the update on a linked list can be O(1).
Here is the code:
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* * Illustration of the design: * *       entry             entry             entry             entry *       ______            ______            ______            ______ *      | tail |.newer =&amp;gt; |      |.newer =&amp;gt; |      |.newer =&amp;gt; | head | *      |  A   |          |  B   |          |  C   |          |  D   | *      |______| &amp;lt;= older.|______| &amp;lt;= older.|______| &amp;lt;= older.|______| * */var LRUCache = function(capacity)&amp;#123;  this.capacity = capacity  this.length = 0  this.map = &amp;#123;&amp;#125;  // save the head and tail so we can update it easily  this.head = null  this.tail = null&amp;#125;LRUCache.prototype.node = function(key,value)&amp;#123;  this.key = key  this.val = value  this.newer = null  this.older = null&amp;#125;LRUCache.prototype.get = function(key)&amp;#123;  if(this.map.hasOwnProperty(key))&amp;#123;    this.updateKey(key)    return this.map[key].val  &amp;#125;else&amp;#123;    return -1  &amp;#125;&amp;#125;LRUCache.prototype.updateKey = function(key)&amp;#123;  var node = this.map[key]  // break the chain and reconnect with newer and older  if(node.newer)&amp;#123;    node.newer.older= node.older  &amp;#125;else&amp;#123;    this.head = node.older  &amp;#125;  if(node.older)&amp;#123;    node.older.newer = node.newer  &amp;#125;else&amp;#123;    this.tail = node.newer  &amp;#125;  // replace the node into head - newest  node.older = this.head  node.newer = null  if(this.head)&amp;#123;    this.head.newer = node  &amp;#125;  this.head = node  // if no items in the bucket, set the tail to node too.  if(!this.tail)&amp;#123;    this.tail = node  &amp;#125;&amp;#125;LRUCache.prototype.set = function(key,value)&amp;#123;  var node = new this.node(key,value)  // update the value for exist entries  if(this.map.hasOwnProperty(key))&amp;#123;    this.map[key].val = value    this.updateKey(key)    return  &amp;#125;  if(this.length &amp;gt;= this.capacity)&amp;#123;    // remove the least recently used item    var dKey = this.tail.key    this.tail = this.tail.newer    if(this.tail)&amp;#123;      this.tail.older = null    &amp;#125;    delete this.map[dKey]    this.length --  &amp;#125;  // insert node into the head  node.older = this.head  // if have head, we need re-connect node with other nodes older than head  if(this.head)&amp;#123;    this.head.newer = node  &amp;#125;  this.head = node  // if no tail which means first insert, set the tail to node too  if(!this.tail)&amp;#123;    this.tail = node  &amp;#125;  this.map[key] = node  this.length ++&amp;#125;
Now we can achieve set, get both with O(1).
SummaryHere is some other implementations from others, if you are interested in it, check it yourself.

LRU by Chrisr NG
LRU by rsms

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript 闭包(Closure)初探</title><link>http://taoalpha.me/blog/2015/07/12/tech-javascript-closure/</link><category>tech</category><tag></tag><pubDate>2015-07-12T07:00:00.000Z</pubDate><description>缘起 在上篇重载的介绍中提到了Closure的概念, 正好今天看到Ninja中介绍Closure的这部分, 所以今天梳理记录下. Closure作为JS的高级用法之一, 对于JS开发而言有着极为重要的作用.
ClosureClosure的结构什么是Closure? 更精确的说: 什么是JavaScript里面的Closure? 

a closure is the scope created when a function is declared that allows the function to access and manipulate variables that are external to that function. 

上面是Ninja一书中对Closure的定义. 难懂吗? 应该不算难懂, 核心关键词就是: scope, function, access, manipulate, variables, external
即一个Closure代指的是一个scope, 一个js的小型工作环境, 这一环境是随着一个函数的声明而出现的. 但是所有函数都会伴随着closure吗? 当然不是, 对于这种函数有特定的要求, 就是这个函数本身可以访问并且修改该函数外部的变量. 只有具备此性质的函数才伴随着Closure的出现.
还是很难懂? 举几个例子:

在浏览其中, 我们定义的一个单纯的全局函数, 会伴随closure的出现吗?
 答案是肯定的, 根据上述定义, 我们的全局函数是可以获取并操作其之外的变量的, 通常我们称为全局变量(定义在window对象中的变量);

那有啥函数不伴随Closure出现吗?
 有, 我们可以认为window顶层是一个函数, 这个函数本身就没有外部的函数了, 自然也就没有Closure了.

如此一来, Closure岂不是随处可见? 那还有什么意义?
 Closure确实随处可见. 但也正因为随处可见, 我们就会在clsore发现closure的嵌套, 我们可以在全局closure下, 定义我们自己的closure, 而利用closure的性质形成一个个小型的scope, 如此就可以构建并指定甚至操作我们的函数执行环境, 从而实现很多非常了不起的功能了.


如何理解Closure
Closure 相当于一个保护罩, 其会在closure声明的那一刻为当前的scope(即此刻scope下所有的变量, 函数等, 即便他们是在closure之后声明或者是closure接受的参数)创建一个特殊的环境而不会收到垃圾回收的回收, 其存活周期完全依赖于closure自身的寿命;
在浏览器环境下, 即便是全局定义的函数其实也是在一个大的closure之中的, window则是这个closure中的核心对象;

Closure的用法
Closure 通常的用法:
封装私有变量: 一个函数内部定义的变量, 只有内部才能访问, 所以一个函数内部的函数(closure)就可以访问这个函数定义的局部变量;
callback和timer函数中的应用: 对于嵌套在函数中的callback以及timers函数, 都可以访问函数内部定义的变量的, 虽然他们的context(this)通常都指向的是window全局对象或者某个特殊对象(比如jQuery.ajax的callback的this就是ajax构成的对象); 同时利用这一特点将变量定义在函数内来避免污染全局变量;
改变函数工作环境(context), 在一定程度上它和apply,call的逻辑一致, 典型应用即Prototypt库中的bind函数(JS1.8.5以后就默认添加了bind函数), 详见下文;
部分传参: 和上述中介绍的bind同理, 区别在于对参数的处理上, 部分传参的时候, 第一次传参可以传递部分参数, 希望之后补充的参数可以预置为undefined, 而在返回函数中, 也不是单纯的合并两次参数, 而是递归之前的传参, 将undefined的参数补上;
重写函数: 利用closure可以对一些函数进行新的重写, 比如下例中的memoize函数;
结合匿名自触发函数: Closure和(function(){})()的结合自然可以带来更多的想象力;



1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768do -&amp;gt; c = 1 $.ajax     url: &quot;http://taoalpha.me/blog/api/latest.json&quot;    dataType:'json' .done (data)-&amp;gt;    console.log(this)    console.log(c)    console.log(data)do -&amp;gt;  cc = 1  timer = setInterval -&amp;gt;    if cc &amp;lt; 3 then console.log(&quot;cc#&amp;#123;cc&amp;#125;&quot;);console.log(&quot;this#&amp;#123;@&amp;#125;&quot;);cc++ else clearInterval timer  ,1000Function::bind -&amp;gt;  # console.log arguments  fn = @; args = Array::slice.call(arguments);object = args.shift()  # 此处将传入参数拆解, 默认第一个为要绑定的对象  -&amp;gt;    # console.log arguments    fn.apply object,args.concat Array.prototype.slice.call(arguments)    # 这里返回一个新的函数, 新函数唯一的功能调用绑定函数(fn), 并传入绑定中除了object以外的参数(args)和调用传入的参数(这次的arguments)    # 部分传参中这里需要做参数处理:    # arg = 0    # for i in [0..args.length] when arg &amp;lt; arguments.length    #   if args[i] == undefined    #     args[i] = arguments[arg++]    # fn.apply @, args# 利用Closure包装缓存函数 memoized Function::memoized = (key) -&amp;gt;  @_values = @_values || &amp;#123;&amp;#125;  if @_values[key]? then @_values[key] else @_values[key] = @.apply(@,arguments)Function::memoize = -&amp;gt;  fn = @  -&amp;gt;    fn.memoized.apply fn,argumentsisPrime = ((key)-&amp;gt;  prime = num != 1  for i in [2...num] when num % i ==0    prime = false   ).memoize()# 利用自触发函数和closure来处理closure中的递归指数divs = document.getElementsByTagName('div')for i in [0...divs.length]  divs[i].addEventListener 'click',-&amp;gt;    alert &quot;divs ##&amp;#123;i&amp;#125; was clicked&quot;  ,fasle## 如此执行的结果就是无路你点击哪个div, 都会显示的是 &quot;divs #&amp;#123;divs.length&amp;#125; was clicked&quot;,因为这里的i被保存了, 始终指向最后一个循环值for i in [0...divs.length]  ((n)-&amp;gt;    divs[i].addEventListener 'click',-&amp;gt;      alert &quot;divs ##&amp;#123;i&amp;#125; was clicked&quot;    ,fasle  )(i)通过closure, 我们把每次传入的i都单独用另一个私有变量n存储起来, 这样每个div对应的指数就是唯一的了
谜题
Q: 那么bind和call,apply的区别又是什么呢? 与其使用fn.bind(object), 为什么我不是用fn.apply(object)或者fn.call(object)呢?

A: 


bind returns a function which will act like the original function but with this predefined. It is usually used when you want to pass a function to an event handler or other async callback.
call and apply will call a function immediately letting you specify both the value of this and any arguments the function will receive.
bind和apply,call最大的区别就在于bind返回一个函数, 而apply, call则是执行一个函数. 所以bind通常用在一些异步事件处理中;


参考资料
Secrets of the JavaScript Ninja
CoffeeScript - 在线调试
what’s the difference between ‘call/apply’ and ‘bind’

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript callback学习笔记</title><link>http://taoalpha.me/blog/2015/06/11/tech-javascript-callback-notes/</link><category>tech</category><tag>callback,javascript</tag><pubDate>2015-06-11T11:00:00.000Z</pubDate><description>缘起今天帮朋友做一个网站, 涉及到js请求并且渲染数据. 因为js语言的特点使得其代码是由上至下依次执行的, 有一个比较恶心的问题在于这一执行顺序并不等同于其先后顺序, 如果中间有一步或者几步的后续执行比较耗费时间, js本身是不会等待其执行完再去执行下面的语句的. 如此就会出现一些因为执行时间而导致的问题, 尤其是请求和渲染数据的时候. 如果你分开来写, 顺次执行的时候, 请求这一步花费的时间比较多, 那么很可能渲染环节都不会得到执行…
比如下述代码:
12345678910111213141516171819202122232425tmpVar = 1;changeItOne();tmpVar = 2;changeItTwo();console.log(&quot;Second output: &quot;+tmpVar);function changeItOne()&amp;#123;  tmpVar = 3;  console.log(&quot;Output: &quot;+tmpVar);&amp;#125;function changeItTwo()&amp;#123;  // setTimeout(changeItOne,100);  tmpVar = 3;  console.log(&quot;Output of changeItTwo: &quot;+tmpVar);&amp;#125;// 输出:// Output: 3// Output of changeItTwo: 3// second output: 3// 加上延时后输出// Output: 3// Second output: 2// Output: 3
callback那么, 我们如何确保这种情况下的执行顺序呢? callback.
回调说白了就是在某个函数执行过程中在指定的情况下调用另一个函数的过程.
基本调用方法:
12345678910111213141516171819202122function doSomething(params,callback) &amp;#123;  // 主函数部分    // 调用函数, 可以加上一些对应的限制条件来做调用判断  callback(anything_you_want_to_send_with);&amp;#125; function funOne(c) &amp;#123;&amp;#125; para = &quot;&quot;// 传参调用doSomething(para,funOne); // 隐式调用 - 利用匿名函数调用doSomething(para,function(data)&amp;#123;// data就是doSomething里面的callback()传参// 调用函数内容&amp;#125;)
当然, 回调函数可以应用到很多地方, 甚至可以结合class, prototype以及apply,call从而模拟出私有函数, 私有变量等等~ 一切等你去挖掘! 哈哈
参考资料
WeiRSS - 我在其search.js中就用到了多层回调函数的调用
javascript 回调函数笔记

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Array Operation Cost in JavaScript</title><link>http://taoalpha.me/blog/2015/10/30/tech-javascript-array-operation-cost/</link><category>tech</category><tag>Array,Data Structure,JS</tag><pubDate>2015-10-30T11:00:00.000Z</pubDate><description>Introductionconcat(),splice(),slice(),push(),pop(),shift(),unshift()… all these handy functions belong to Array. We are using them everyday, but do you really know about them ? Time cost of a function in language like JavaScript is not easy to measurement, since different browsers use different javascript engine which will cause different implementation on same functions. But, normally, the basic operations will be the same.
So today, I will test some basic array operations on NodeJS and compare the time cost between these operations.
TEST ENVIRONMENT: Mac Air, iTerm, NodeJS v4.1.1
ConstructorWe all know that we have several different ways to construct an array, the most frequently used are two methods I list below:

Literal notation : [ele1,ele2,...]
new function : new Array(ele1,ele2,...) or new Array(length_of_array)

Normally there are no difference between these two methods. But if you are dealing with some real big datasets and you know exactly how long your array is and want to save a few time for some basic operations, you may should continue reading.
The fundamental difference between these two methods is : literal notation declare an array with elements in it, new Array(ele1,ele2,...) will do exactly the same, but new Array(length_of_array) will only declare a length of a array(and create or allocate a memory for this array with its length).
Here is a gif about the memory allocation will give you a clear understanding about it.

The advantage of declaring with allocating is that it can improve the speed of constructing an array.
As test I did, to construct a 100000 array with 0-99999 (average time cost):

Use literal notation with push(): 8ms
Use literal notation with unshift(): 2230ms
Use literal notation with assigning directly by index: 5ms 
Use new Array(100000) with assigning directly by index: 2ms
Use literal notation with assigning length first then assigning directly by index : 2ms

Apparently, it would save you some time if you declare the length before you assign the values.And if you don’t like to use the new, you can still use literal notation and set the length manually.
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// time cost for array constructingvar i = 0var ar = []var arr = new Array(100000)i = 0console.time(&quot;Literal notation with assigning directly&quot;)while(i&amp;lt;=99999)&amp;#123;  ar[i] = i  i++&amp;#125;console.timeEnd(&quot;Literal notation with assigning directly&quot;)i = 0ar = []console.time(&quot;Literal notation with push()&quot;)while(i&amp;lt;=99999)&amp;#123;  ar.push(i)  i++&amp;#125;console.timeEnd(&quot;Literal notation with push()&quot;)ar = []console.time(&quot;Literal notation with unshift()&quot;)while(i&amp;gt;=0)&amp;#123;  ar.unshift(i)  i --&amp;#125;console.timeEnd(&quot;Literal notation with unshift()&quot;)i = 0ar = []ar.length = 100000console.time(&quot;Literal notation with declaring length first&quot;)while(i&amp;lt;=99999)&amp;#123;  ar[i] = i  i++&amp;#125;console.timeEnd(&quot;Literal notation with declaring length first&quot;)i = 0console.time(&quot;Using new with length defined&quot;)while(i&amp;lt;=99999)&amp;#123;  arr[i] = i  i++&amp;#125;console.timeEnd(&quot;Using new with length defined&quot;)
delete and removeJavaScript does have a keyword for deleting: delete. For array, when you use delete ar[i], you actually assign ar[i] = undefined. I recommend you to use the second method since it is a little faster.
Test on 100000-length list (delete all elements):

Delete with “delete” keyword: 11ms
Delete with assigning “undefined” to the value: 2ms

Both of the two methods would not change the length of the array, but we can also use “pop()”, “shift()” to empty an array.
Test on 100000-length list (remove all elements):

remove with “pop()”: 5ms 
remove with “shift()”: 18ms
remove with splice() : 25ms

So, the shift() will cost near 3 times of pop() and splice() even slower. 
Of course, under different conditions, you will choose different methods to achieve what you want.
other native functionsI did some tests on other basic native functions too. Here are the results:

splice() to insert 1000 elements into a 100000-length list : 60ms 
concat() two 100000-length lists : 1ms
Use while loop and push to concat two 100000-length lists : 8ms
slice() to hard copy one 100000-length list : 1ms
Use while loop and push to hard copy one 100000-length list : 8ms
Use while loop and assign value with predefined length to copy one 100000-length list : 2 (same as constructing part)
indexOf() to search every element in a 100000-length list (the smaller the index is, the sooner it will be): 4600ms 
Use while loop to achieve the search : 7300ms
Reverse (ordered list like 0 - 99999) : 1ms
Reverse (ordered list like 99999 - 0) : 100ms (this is weird…)

Most of time, the native functions are the best methods to do the operation since the engine already done a lot to optimize them.
SummarySometimes you will think these small difference between different methods is not important, since the technology is growing so fast, the difference will become so small that we can just ignore them. That’s 100% correct!
I did these just because I am curious and sometimes, if you are dealing with a really large dataset, then maybe the nanoseconds count and you may want to use some small changes to optimize your code. Why don’t you always keep your code optimized all the time?
That’s all!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>修复rake aborted以及lsi warning问题</title><link>http://taoalpha.me/blog/2015/06/10/tech-fix-rake-aborted-and-lsi-warning-problem/</link><category>tech</category><tag>lsi,rake,ruby</tag><pubDate>2015-06-10T05:00:00.000Z</pubDate><description>缘起昨天升级了下ruby, 从2.0.0到2.2.2, 升级完jekyll, bundle等均完好无损, 当打包完一些更改push到github后, 想要用rake自动发布的时候发现rake不工作了…
修复Rake错误信息在jekyll跟目录运行rake后出现:

rake aborted!require: cannot load such file – jekyll

错误代码指示在Rakefile的require “Jekyll” 一行.
错误原因猜测回忆了以下之前所有设计到jekyll和rake的操作就是ruby的升级了. 所以猜测应该是ruby升级所致. Google后没有找到合适的解答. 于是就自己折腾分析了一下, 猜测主要可能在与:

ruby版本号已经从2.0.0提升到2.2.2, 但是bundle show jekyll的时候还是提示的是2.0.0的目录;

修复方式我首先尝试了利用gem重新安装jekyll, 然后利用其路径验证问题是否是版本号的原因, 但是发现gem install jekyll命令一直处于卡死状态. 无论我切换淘宝ruby源还是自有源都无效. 猜测gem也出了一些问题.
接下来我尝试重新安装ruby 2.0.0, 试图恢复升级前的环境, 结果依然失败…
于是我又彻底卸载了ruby, 重新用homebrew安装了ruby最新的2.2.2版本, 并且清楚了bundle的gems目录(里面那个2.0.0的目录), 然后重新安装了bundler, 再用bundler去恢复了所有的gems.
成功!! 具体原因真心不知, Google没有找到解答, 只能自己瞎分析了, 如果有哪位知道原因, 记得告诉我哦
jekyll lsi warning问题问题描述成功修复了rake后, 心情大好, 再次开启jekyll准备记录以下这一过程~ 结果就发现build的时候出现大量的warning信息… 发现是lsi建立索引的那一步出的问题, 问题如下:

warning: Comparable#== will no more rescue exceptions of #&amp;lt;=&amp;gt; in the next release.warning: Return nil in #&amp;lt;=&amp;gt; if the comparison is inappropriate or avoid such comparison.

当前环境:
jekyll (2.5.3)classifier-reborn (2.0.3)rb-gsl (1.16.0.4)
修复问题这次Google了下找到了一个遭遇相同的兄弟! 哈哈
Fix lsi.rb Comparable#== warning #33
根据解答, 大意就是需要替换出错行(237行)的pair[0] == doc判断为 pair[0].eql? doc.
why? 于是我查了下ruby中eql?和==的区别:

== — generic “equality”最常用的相等判断, 属于值判断;
eql? — Hash equalityThe eql? method returns true if obj and other refer to the same hash key. 一般Hash对象都会使用eql?来判断其成员之间的相等与否. 当然此外, 在数字判断上, ==与eql?的区别也有点像严格判断(1 和 1.0, 后者就会判断为false);

虽然稀里糊涂, 但感觉很有道理的样子.. 传说中的不明觉厉吗…
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>ES6 General Summary</title><link>http://taoalpha.me/blog/2015/11/06/tech-es6-general-summary/</link><category>tech</category><tag>ES6,JS</tag><pubDate>2015-11-06T05:00:00.000Z</pubDate><description>
This post is a copy of Luke Hoban - ES6Features repo

IntroductionECMAScript 6, also known as ECMAScript 2015, is the latest version of the ECMAScript standard.  ES6 is a significant update to the language, and the first update to the language since ES5 was standardized in 2009. Implementation of these features in major JavaScript engines is underway now.
See the ES6 standard for full specification of the ECMAScript 6 language.
ECMAScript 6 FeaturesArrowsArrows are a function shorthand using the =&amp;gt; syntax.  They are syntactically similar to the related feature in C#, Java 8 and CoffeeScript.  They support both statement block bodies as well as expression bodies which return the value of the expression.  Unlike functions, arrows share the same lexical this as their surrounding code.
1234567891011121314151617181920// Expression bodiesvar odds = evens.map(v =&amp;gt; v + 1);var nums = evens.map((v, i) =&amp;gt; v + i);var pairs = evens.map(v =&amp;gt; (&amp;#123;even: v, odd: v + 1&amp;#125;));// Statement bodiesnums.forEach(v =&amp;gt; &amp;#123;  if (v % 5 === 0)    fives.push(v);&amp;#125;);// Lexical thisvar bob = &amp;#123;  _name: &quot;Bob&quot;,  _friends: [],  printFriends() &amp;#123;    this._friends.forEach(f =&amp;gt;      console.log(this._name + &quot; knows &quot; + f));  &amp;#125;&amp;#125;
ClassesES6 classes are a simple sugar over the prototype-based OO pattern.  Having a single convenient declarative form makes class patterns easier to use, and encourages interoperability.  Classes support prototype-based inheritance, super calls, instance and static methods and constructors.
1234567891011121314151617181920212223class SkinnedMesh extends THREE.Mesh &amp;#123;  constructor(geometry, materials) &amp;#123;    super(geometry, materials);    this.idMatrix = SkinnedMesh.defaultMatrix();    this.bones = [];    this.boneMatrices = [];    //...  &amp;#125;  update(camera) &amp;#123;    //...    super.update();  &amp;#125;  get boneCount() &amp;#123;    return this.bones.length;  &amp;#125;  set matrixType(matrixType) &amp;#123;    this.idMatrix = SkinnedMesh[matrixType]();  &amp;#125;  static defaultMatrix() &amp;#123;    return new THREE.Matrix4();  &amp;#125;&amp;#125;
Enhanced Object LiteralsObject literals are extended to support setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions.  Together, these also bring object literals and class declarations closer together, and let object-based design benefit from some of the same conveniences.
12345678910111213var obj = &amp;#123;    // __proto__    __proto__: theProtoObj,    // Shorthand for ‘handler: handler’    handler,    // Methods    toString() &amp;#123;     // Super calls     return &quot;d &quot; + super.toString();    &amp;#125;,    // Computed (dynamic) property names    [ 'prop_' + (() =&amp;gt; 42)() ]: 42&amp;#125;;
Template StringsTemplate strings provide syntactic sugar for constructing strings.  This is similar to string interpolation features in Perl, Python and more.  Optionally, a tag can be added to allow the string construction to be customized, avoiding injection attacks or constructing higher level data structures from string contents.
1234567891011121314151617// Basic literal string creation`In JavaScript '\n' is a line-feed.`// Multiline strings`In JavaScript this is not legal.`// String interpolationvar name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&amp;#123;name&amp;#125;, how are you $&amp;#123;time&amp;#125;?`// Construct an HTTP request prefix is used to interpret the replacements and constructionPOST`http://foo.org/bar?a=$&amp;#123;a&amp;#125;&amp;amp;b=$&amp;#123;b&amp;#125;     Content-Type: application/json     X-Credentials: $&amp;#123;credentials&amp;#125;     &amp;#123; &quot;foo&quot;: $&amp;#123;foo&amp;#125;,       &quot;bar&quot;: $&amp;#123;bar&amp;#125;&amp;#125;`(myOnReadyStateChangeHandler);
DestructuringDestructuring allows binding using pattern matching, with support for matching arrays and objects.  Destructuring is fail-soft, similar to standard object lookup foo[&amp;quot;bar&amp;quot;], producing undefined values when not found.
123456789101112131415161718192021222324// list matchingvar [a, , b] = [1,2,3];// object matchingvar &amp;#123; op: a, lhs: &amp;#123; op: b &amp;#125;, rhs: c &amp;#125;       = getASTNode()// object matching shorthand// binds `op`, `lhs` and `rhs` in scopevar &amp;#123;op, lhs, rhs&amp;#125; = getASTNode()// Can be used in parameter positionfunction g(&amp;#123;name: x&amp;#125;) &amp;#123;  console.log(x);&amp;#125;g(&amp;#123;name: 5&amp;#125;)// Fail-soft destructuringvar [a] = [];a === undefined;// Fail-soft destructuring with defaultsvar [a = 1] = [];a === 1;
Default + Rest + SpreadCallee-evaluated default parameter values.  Turn an array into consecutive arguments in a function call.  Bind trailing parameters to an array.  Rest replaces the need for arguments and addresses common cases more directly.
1234567891011121314151617function f(x, y=12) &amp;#123;  // y is 12 if not passed (or passed as undefined)  return x + y;&amp;#125;f(3) == 15function f(x, ...y) &amp;#123;  // y is an Array  return x * y.length;&amp;#125;f(3, &quot;hello&quot;, true) == 6function f(x, y, z) &amp;#123;  return x + y + z;&amp;#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6
Let + ConstBlock-scoped binding constructs.  let is the new var.  const is single-assignment.  Static restrictions prevent use before assignment.
12345678910111213function f() &amp;#123;  &amp;#123;    let x;    &amp;#123;      // okay, block scoped name      const x = &quot;sneaky&quot;;      // error, const      x = &quot;foo&quot;;    &amp;#125;    // error, already declared in block    let x = &quot;inner&quot;;  &amp;#125;&amp;#125;
Iterators + For..OfIterator objects enable custom iteration like CLR IEnumerable or Java Iterable.  Generalize for..in to custom iterator-based iteration with for..of.  Don’t require realizing an array, enabling lazy design patterns like LINQ.
123456789101112131415161718let fibonacci = &amp;#123;  [Symbol.iterator]() &amp;#123;    let pre = 0, cur = 1;    return &amp;#123;      next() &amp;#123;        [pre, cur] = [cur, pre + cur];        return &amp;#123; done: false, value: cur &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;for (var n of fibonacci) &amp;#123;  // truncate the sequence at 1000  if (n &amp;gt; 1000)    break;  console.log(n);&amp;#125;
Iteration is based on these duck-typed interfaces (using TypeScript type syntax for exposition only):12345678910interface IteratorResult &amp;#123;  done: boolean;  value: any;&amp;#125;interface Iterator &amp;#123;  next(): IteratorResult;&amp;#125;interface Iterable &amp;#123;  [Symbol.iterator](): Iterator&amp;#125;
GeneratorsGenerators simplify iterator-authoring using function* and yield.  A function declared as function* returns a Generator instance.  Generators are subtypes of iterators which include additional  next and throw.  These enable values to flow back into the generator, so yield is an expression form which returns a value (or throws).
Note: Can also be used to enable ‘await’-like async programming, see also ES7 await proposal.
123456789101112131415161718var fibonacci = &amp;#123;  [Symbol.iterator]: function*() &amp;#123;    var pre = 0, cur = 1;    for (;;) &amp;#123;      var temp = pre;      pre = cur;      cur += temp;      yield cur;    &amp;#125;  &amp;#125;&amp;#125;for (var n of fibonacci) &amp;#123;  // truncate the sequence at 1000  if (n &amp;gt; 1000)    break;  console.log(n);&amp;#125;
The generator interface is (using TypeScript type syntax for exposition only):
1234interface Generator extends Iterator &amp;#123;    next(value?: any): IteratorResult;    throw(exception: any);&amp;#125;
UnicodeNon-breaking additions to support full Unicode, including new Unicode literal form in strings and new RegExp u mode to handle code points, as well as new APIs to process strings at the 21bit code points level.  These additions support building global apps in JavaScript.
12345678910111213141516// same as ES5.1&quot;𠮷&quot;.length == 2// new RegExp behaviour, opt-in ‘u’&quot;𠮷&quot;.match(/./u)[0].length == 2// new form&quot;\u&amp;#123;20BB7&amp;#125;&quot;==&quot;𠮷&quot;==&quot;\uD842\uDFB7&quot;// new String ops&quot;𠮷&quot;.codePointAt(0) == 0x20BB7// for-of iterates code pointsfor(var c of &quot;𠮷&quot;) &amp;#123;  console.log(c);&amp;#125;
ModulesLanguage-level support for modules for component definition.  Codifies patterns from popular JavaScript module loaders (AMD, CommonJS). Runtime behaviour defined by a host-defined default loader.  Implicitly async model – no code executes until requested modules are available and processed.
12345678910111213// lib/math.jsexport function sum(x, y) &amp;#123;  return x + y;&amp;#125;export var pi = 3.141593;// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));// otherApp.jsimport &amp;#123;sum, pi&amp;#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi));
Some additional features include export default and export *:
12345678910// lib/mathplusplus.jsexport * from &quot;lib/math&quot;;export var e = 2.71828182846;export default function(x) &amp;#123;    return Math.log(x);&amp;#125;// app.jsimport ln, &amp;#123;pi, e&amp;#125; from &quot;lib/mathplusplus&quot;;alert(&quot;2π = &quot; + ln(e)*pi*2);
Module LoadersModule loaders support:

Dynamic loading
State isolation
Global namespace isolation
Compilation hooks
Nested virtualization

The default module loader can be configured, and new loaders can be constructed to evaluate and load code in isolated or constrained contexts.
1234567891011121314// Dynamic loading – ‘System’ is default loaderSystem.import('lib/math').then(function(m) &amp;#123;  alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&amp;#125;);// Create execution sandboxes – new Loadersvar loader = new Loader(&amp;#123;  global: fixup(window) // replace ‘console.log’&amp;#125;);loader.eval(&quot;console.log('hello world!');&quot;);// Directly manipulate module cacheSystem.get('jquery');System.set('jquery', Module(&amp;#123;$: $&amp;#125;)); // WARNING: not yet finalized
Map + Set + WeakMap + WeakSetEfficient data structures for common algorithms.  WeakMaps provides leak-free object-key’d side tables.
123456789101112131415161718192021// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;// Weak Mapsvar wm = new WeakMap();wm.set(s, &amp;#123; extra: 42 &amp;#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&amp;#123; data: 42 &amp;#125;);// Because the added object has no other references, it will not be held in the set
ProxiesProxies enable creation of objects with the full range of behaviors available to host objects.  Can be used for interception, object virtualization, logging/profiling, etc.
12345678910111213141516171819202122// Proxying a normal objectvar target = &amp;#123;&amp;#125;;var handler = &amp;#123;  get: function (receiver, name) &amp;#123;    return `Hello, $&amp;#123;name&amp;#125;!`;  &amp;#125;&amp;#125;;var p = new Proxy(target, handler);p.world === 'Hello, world!';// Proxying a function objectvar target = function () &amp;#123; return 'I am the target'; &amp;#125;;var handler = &amp;#123;  apply: function (receiver, ...args) &amp;#123;    return 'I am the proxy';  &amp;#125;&amp;#125;;var p = new Proxy(target, handler);p() === 'I am the proxy';
There are traps available for all of the runtime-level meta-operations:
1234567891011121314151617var handler =&amp;#123;  get:...,  set:...,  has:...,  deleteProperty:...,  apply:...,  construct:...,  getOwnPropertyDescriptor:...,  defineProperty:...,  getPrototypeOf:...,  setPrototypeOf:...,  enumerate:...,  ownKeys:...,  preventExtensions:...,  isExtensible:...&amp;#125;
SymbolsSymbols enable access control for object state.  Symbols allow properties to be keyed by either string (as in ES5) or symbol.  Symbols are a new primitive type. Optional description parameter used in debugging - but is not part of identity.  Symbols are unique (like gensym), but not private since they are exposed via reflection features like Object.getOwnPropertySymbols.
1234567891011121314151617181920var MyClass = (function() &amp;#123;  // module scoped symbol  var key = Symbol(&quot;key&quot;);  function MyClass(privateData) &amp;#123;    this[key] = privateData;  &amp;#125;  MyClass.prototype = &amp;#123;    doStuff: function() &amp;#123;      ... this[key] ...    &amp;#125;  &amp;#125;;  return MyClass;&amp;#125;)();var c = new MyClass(&quot;hello&quot;)c[&quot;key&quot;] === undefined
Subclassable Built-insIn ES6, built-ins like Array, Date and DOM Elements can be subclassed.
Object construction for a function named Ctor now uses two-phases (both virtually dispatched):

Call Ctor[@@create] to allocate the object, installing any special behavior
Invoke constructor on new instance to initialize

The known @@create symbol is available via Symbol.create.  Built-ins now expose their @@create explicitly.
1234567891011121314151617181920// Pseudo-code of Arrayclass Array &amp;#123;    constructor(...args) &amp;#123; /* ... */ &amp;#125;    static [Symbol.create]() &amp;#123;        // Install special [[DefineOwnProperty]]        // to magically update 'length'    &amp;#125;&amp;#125;// User code of Array subclassclass MyArray extends Array &amp;#123;    constructor(...args) &amp;#123; super(...args); &amp;#125;&amp;#125;// Two-phase 'new':// 1) Call @@create to allocate object// 2) Invoke constructor on new instancevar arr = new MyArray();arr[1] = 12;arr.length == 2
Math + Number + String + Array + Object APIsMany new library additions, including core Math libraries, Array conversion helpers, String helpers, and Object.assign for copying.
12345678910111213141516171819202122Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll('*')) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&amp;gt; x == 3) // 3[1, 2, 3].findIndex(x =&amp;gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &amp;#123; origin: new Point(0,0) &amp;#125;)
Binary and Octal LiteralsTwo new numeric literal forms are added for binary (b) and octal (o).
120b111110111 === 503 // true0o767 === 503 // true
PromisesPromises are a library for asynchronous programming.  Promises are a first class representation of a value that may be made available in the future.  Promises are used in many existing JavaScript libraries.
12345678910111213function timeout(duration = 0) &amp;#123;    return new Promise((resolve, reject) =&amp;gt; &amp;#123;        setTimeout(resolve, duration);    &amp;#125;)&amp;#125;var p = timeout(1000).then(() =&amp;gt; &amp;#123;    return timeout(2000);&amp;#125;).then(() =&amp;gt; &amp;#123;    throw new Error(&quot;hmm&quot;);&amp;#125;).catch(err =&amp;gt; &amp;#123;    return Promise.all([timeout(100), timeout(200)]);&amp;#125;)
Reflect APIFull reflection API exposing the runtime-level meta-operations on objects.  This is effectively the inverse of the Proxy API, and allows making calls corresponding to the same meta-operations as the proxy traps.  Especially useful for implementing proxies.
Tail CallsCalls in tail-position are guaranteed to not grow the stack unboundedly.  Makes recursive algorithms safe in the face of unbounded inputs.
123456789function factorial(n, acc = 1) &amp;#123;    'use strict';    if (n &amp;lt;= 1) return acc;    return factorial(n - 1, n * acc);&amp;#125;// Stack overflow in most implementations today,// but safe on arbitrary inputs in ES6factorial(100000)
Referrence
ES6 Features

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Use Django with Bower and Pipeline</title><link>http://taoalpha.me/blog/2015/09/07/tech-django-with-bower-and-pipeline/</link><category>tech</category><tag>django,python</tag><pubDate>2015-09-07T08:00:00.000Z</pubDate><description>IntroSince I decided to focus on python and JS, I started to dig into these two babies.
I use django as my web framework in python, so how to build a website easier is what I most concerned. I used yeoman for a while, pretty amazing and convenient, especially the bower and compressor, compiler.
So I did some search and study, trying to integrate the bower and compressor, compiler into django since I am getting used to the yeoman workflow.
How to do thatPython is great for extensions. It has so many modules you can find and build for it. So in order to integrate the bower and compressor, compiler into django, we need two modules:
django-bowerJust like other modules, you can install django-bower easily through pip:
1pip install django-bower
After you installed , you need add it into your INSTALLED_APPS in your project settings with the name is ‘djangobower’. And If you don’t want to add the component file path by youself, you can use djangobower.finders.BowerFinder to do that for you. Just add it into your INSTALLED_FINDERS.
You can also set the BOWER_COMPONENTS_ROOT to put all your packages into one place. And if you want, you can set the path to bower manually: BOWER_PATH=path_to_bower
So after these, how to use it?
Easy, you can manage your packages in your project settings with BOWER_INSTALLED_APPS=(&amp;#39;jquery&amp;#39;,&amp;#39;bootstrap#4.0.0-alpha&amp;#39;,), and put all your packages names into it. Just similar to what you did in bower.json.
And for installing all the packages, you just need to run python manage.py bower_install -- --allow-root(you can get rid of the -- --allow-root if you don’t receive the sudo error)
And it will install all the packages you have listed in your settings.
The last step and most important step, you need to collect all your static files into your static folder. Just run:python manage.py collectstatic.
Now you can just put1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% load static %&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
in the top of your template files and use
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% static &amp;#39;static_path_to_you_modlue_file&amp;#39; %&amp;#125; &amp;#10;&amp;#123;% endraw %&amp;#125;
anywhere you want.
That’s it. Pretty much all about django-bower.
django-pipelineNow we got bower, so next step we need to get the compressor and compiler.
I use coffee-script as my pre-processor for JS. It’s easy and super cool!!! Strongly recommended!
Bower is a pretty cool package manager, but it has nothing to do with your own scripts or stylesheets or html files. So in order to compress the files to minimize the size of files and to use coffee-script, sass in django. You can install django-pipeline.
Just like django-bower, you can also install django-pipeline with pip:
1pip install django-pipeline
Same as django-bower, you need put some essentials into your project setting file.
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253INSTALLED_APPS = (  ...  'pipeline',)STATICFILES_STORAGE = 'pipeline.storage.PipelineCachedStorage'# if you don't want the version files, you can just use `PipelineStorage` instead of `PipelineCachedStorage`STATICFILES_FINDERS = (  ...  'django.contrib.staticfiles.finders.FileSystemFinder',  'django.contrib.staticfiles.finders.AppDirectoriesFinder',  'pipeline.finders.PipelineFinder',)STATICFILES_DIRS = (  'absolute_path_to_your_static_folder',)# this will tell finders to find static files in these foldersSTATICFILES_STORAGE = 'pipeline.storage.PipelineStorage'PIPELINE_ENABLED = True# This will enable the compressPIPELINE_CSS = &amp;#123;    'group_name': &amp;#123;        'source_filenames': (          'relative_path_to_your_files',        ),        'output_filename': 'relative_path_to_your_output_file',        'extra_context': &amp;#123;            'media': 'screen,projection',        &amp;#125;,    &amp;#125;,&amp;#125;# in source_filenames, the path of your files is relative to your static file dirs, the Finders will look for each folder you set in the STATICFILES_DIRS.# in output_filename, the path is relative to the STATIC_ROOT you set in your settings.PIPELINE_JS = &amp;#123;    'group_name': &amp;#123;        'source_filenames': (          'relative_path_to_your_files',        ),        'output_filename': 'relative_path_to_your_output_file',    &amp;#125;&amp;#125;# same with cssPIPELINE_COMPILERS = (    'pipeline.compilers.coffee.CoffeeScriptCompiler',    'pipeline.compilers.sass.SASSCompiler',)# in order to use these compilers, you need install them first !
After finish the configuration, we can use it. In my case, I create a customize folder to store all the customized styles and scripts. So i put this folder into my STATICFILES_DIRS and create a simple group in PIPELINE_CSS.
After that, just run the python manage.py collectstatic. All your file will be copying and moving to your STATIC_ROOT.
Same with django-bower, you can set the path to sass or coffee-script manually if you want (like PIPEPLINE_SASS_BINARY=&amp;#39;&amp;#39;).
In your template, you can either load the file like what you did in django-bower(or default way, precisely), or you can load it using pipeline:
put1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% load pipeline %&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
into the top of your template files, and use 
1&amp;#123;% raw %&amp;#125;&amp;#10;&amp;#123;% stylesheet &amp;#39;group_name&amp;#39;&amp;#125;&amp;#10;&amp;#123;% endraw %&amp;#125;
 to import the stylesheet, same for javascript with javascript keyword.
All done.
Enjoy itNow you have bower, coffee-script, sass in your django. Enjoy the modern web coding style!!
Thanks &amp;amp; Best!
</description><source>TaoAlpha</source><author>TaoALpha</author></item></channel></rss>