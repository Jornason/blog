<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TaoAlpha's Blog</title><link>http://taoalpha.me/blog</link><pubDate>2016-01-10T23:10:54.703Z</pubDate><description></description><language>en</language><generator>hexo</generator><item> <title>Scalable and Modular Architecture for CSS</title><link>http://taoalpha.me/blog/2016/01/10/read-smacss-scalable-and-modular-architecture-for-css/</link><category>read</category><tag>CSS,Modularity,SMACSS</tag><pubDate>2016-01-11T00:13:50.000Z</pubDate><description>Modularity of Web DevAs your project becomes more complex, its more difficult to maintain the code, no matter what kind of language you are using. That’s why we use OOP for most of the projects, by doing that, it saves you a lot of time and energy. Since web development becomes more popular, more and more people start focusing on this area and come up with some fantastic ideas about how to apply modularity or OOP on web development.
We all know that a basic website would contains three basic parts: HTML/CSS/JS. HTML is in charge of the struture, the CSS will focus on the appearance, and JS will give your website more animation(now css can do that too) and interaction. Among all these three parts, HTML is the easiest one, there is not so many things to talk about except the semantic tag, H5..etc, if you want to improve the modularity, most times HTML is not what you care most. Instead, CSS and JS are your primary concern.
Scalable and Modular Architecture for CSS is a nice book focus on applying modularity to CSS, and here is the notes I wrote down after I read it. About JS, we will talk about it later :) You can start with a nice and good coding style.
Reading NotesCategories of RulesJonathan Snook groups CSS rules into five types of categories:

Base: Base rules are the defaults. They are almost exclusively single ele- ment selectors but it could include attribute selectors, pseudo-class selectors, child selectors or sibling selectors. Essentially, a base style says that wherever this element is on the page, it should look like this;
You can use some reset frameworks out there, just be sure you know everything it does before you actually put it in your project;


Layout: Layout rules divide the page into sections. Layouts hold one or more modules together;
Generally, a Layout style only has a single selector: a single ID or class name;
Sometimes, you may have different layouts base on different settings like user preference, then you can use more than one selectors;


Modules: Modules are the reusable, modular parts of our design. They are the callouts, the sidebar sections, the product lists and so on;
Each Module should be designed to exist as a standalone component;
Avoid using IDs and ele- ment selectors, sticking only to class names;
Only include a selector that includes semantics. A span or div holds none. A heading has some. A class defined on an element has plenty;
If you do wish to use an element selector, it should be within one level of a class selector;


State rules: State rules are ways to describe how our modules or layouts will look when in a particular state. Is it hidden or expanded? Is it ac- tive or inactive? They are about describing how a module or layout looks on screens that are smaller or bigger. They are also about de- scribing how a module might look in different views like the home page or the inside page;
A state is something that augments and overrides all other styles;
States should be made to stand alone and are usually built of a single class selector, sometimes you can use !important to address the state;
In a case where a state rule is made for a specific module, the state class name should include the module name in it;


Theme rules: Theme rules are similar to state rules in that they describe how modules or layouts might look. Most sites don’t require a layer of theming but it is good to be aware of it;
Focus on general appearance of your website like colors, borders etc;



And also using proper name for different categories can be beneficial for immediately understanding which category a particular style belongs to and its role within the overall scope of the page. Here is a simple example:
123456789101112/* Example Module */.example &amp;#123; &amp;#125;/* Callout Module */.callout &amp;#123; &amp;#125;/* Callout Module with State */.callout.is-collapsed &amp;#123; &amp;#125;/* Form field module */.field &amp;#123; &amp;#125;/* jsExample is a subclass or variation of example */.example-jsExample &amp;#123; &amp;#125;/* Inline layout  */.l-inline &amp;#123; &amp;#125;
Tips
Minimizing the Depth: The depth of applicability is the number of generations that are affected by a given rule;
Two Goals of SMACSS: Increase semantics and decrease reliance on specific HTML;
How to separate the files in your project:
Place all Base rules into their own file;
Depending on the type of layouts you have, either place all of them into a single file or major layouts into separate files;
Put each module into its own file;
Depending on size of project, place sub-modules into their own file;
Place global states into their own file;
Place layout and module states, including media queries that affect those layouts and modules, into the module files;


Organize styles in the following order:
Box: display, float, position, left, top, height, width…
Border: border;
Background: background;
Text: font-family, font-size, text-transform, letter-spacing…
Others: others;


Be Consistent;

SummaryThis book is pretty short with all valueable content. Strongly recommend after you get familiar with all basic css concepts.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (5)</title><link>http://taoalpha.me/blog/2015/06/24/read-javascript-the-definitive-guide-5/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-24T08:00:00.000Z</pubDate><description>概述在十到十二章中, 第十章的正则表达式内容最为丰富, 也是目前应用即为广泛的内容之一. 不过这里也主要是结合js的应用, 实际上正则表达式本身就是一个很值得研究的话题, 有不少书都在谈这个话题, 我后面要读的书目中恰巧就有这么一本, 后面会更加详细的学习以下正则表达式的方方面面.
十一章算是非常前沿, 高端或者说冷门的点了, 随着浏览器的盛行以及技术的进步, 安全问题始终都是一个很重视的点, 而在这种攻防演练中也促进了js本身的进步, 而主流浏览器本身更是走在了js的最前沿. 各种新的属性都是由他们引入而逐渐成为标准的;
十二章主要是对走出浏览器的JS做了一个简单的介绍, 而NodeJS的大名在近几年在前后端, 全端领域都可谓是人尽皆知. 我也会在之后阅读相关书籍的时候做更详细的笔记记录.
阅读笔记Chapter 10 - Pattern Matching Regular Expressions
normal repetition characters:
{m,n} 匹配m-n次;
{m,} 匹配至少m次;
{m} 匹配恰好m次;
? 匹配0或1次;
+ 匹配1或多次;
* 匹配0或多次;


Nongreedy repetition:
??, +?, *? 在常规的匹配后加上?就能让匹配尽可能发生的短, 它会在允许范围内, 找到尽可能短的匹配;


Alternation, Grouping, Reference:
| 表示匹配前者或者后者;
(...) 成组, 以组的形式来使用*,+,?等, 同时会记录组的匹配以用于Reference;
(?:...) 只是成组, 不记录匹配, 不能用于reference, 也不算做reference的序号中去;
\n 引用, n表示序号, 从1开始, 代表之前第几个group的匹配, 用于匹配开头结尾相同且多样的有奇效:/([&amp;#39;&amp;quot;])[^&amp;#39;&amp;quot;]*\1/ 匹配单引号或者双引号内的内容;
需要注意的就是, reference不能用于[]的character class之中!


anchor characters:
^: 匹配开头;
$: 匹配结尾;
\b: 匹配词边界, /\bJava\b/ =&amp;gt; Java
\B: 匹配非词边界, /\B[Ss]cript\B/ =&amp;gt; JavaScript, postscript...
?=p: 表示内容需要匹配p规则,但是返回的命中中不包含这部分;
?!p: 表示内容不匹配p规则;


flags:
i: 大小写敏感, 即区分大小写;
g: 全局匹配, 默认是匹配首个;
m: 多行匹配;


String Methods for Pattern Matching:
search(): 返回匹配词的位置或者-1代表无返回;
replace(): 支持正则匹配替换, 同时支持替换时使用$n代表是正则匹配的引用, 比如text.replace(/&amp;quot;([^&amp;quot;]*)&amp;quot;/g, &amp;#39;“$1”&amp;#39;);即替换&amp;quot;&amp;quot;为“”;
match(): 返回包含了匹配的结果, 返回结构为数组格式;
split(): 接受正则匹配作为其分隔符, 比如: &amp;quot;1, 2, 3&amp;quot;.split(/\s*,\s*/); =&amp;gt; [&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;], 就去掉了本来直接split()多余的空格;


RegExp prototype method:
exec(): 基本等同match(), 不过接受的是string类型去匹配, 而由正则去调用, 当表达式加了全局flag后, exec()每次执行会记录其上次匹配的位置并从此开始新的匹配, 比如:var pattern = /Java/g;pattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).indexpattern.exec(&amp;quot;JavaScript is more fun than Java!&amp;quot;).index就会相继输出0,28两个位置;
test(): 用以检测表达式是否匹配了传入的string, 其执行逻辑(g模式下记录上次匹配位置)和exec()一样;



Chapter 11 - JavaScript Subsets and Extensions本章主要介绍一些目前主流浏览器支持但是还没有写入JavaScript官方版本中的一些js语言的子集(非官方版本)和扩展属性:

subsets: 通常是为了确保不确定安全性的代码能够安全的运行而出现的(除了Crockford’s JavaScript: The Good Parts);
ADsafe, 最早一个因为安全因素设计的子集语言, 会禁止对绝大多数全局变量的访问;
dojox.secure: 算是Dojo toolkit的一个扩展;
Caja: 其包含了两个子集, 一个是Cajita, 比较严格, 类似ADsafe 和 dojox.secure; 还有个是Valija, 则比较接近如今ECMAScript 5的strict mode了;
Microsoft Web Sandbox;
FBJS: facebook使用的一个自己;通常子集都需要对应一个verifier, 来确保代码符合其要求;


extensions:
const: 声明常量, 比如: const pi = 3.14;;
let: 块变量声明, 相当于缩小版的var, 作用域仅存活在最近的一个块结构里, 你可以用{}来自行创建一个block;
destructing: 允许多变量结构化赋值: let [x,y] = [1,2];let [r,theta] = polar(1.0, 1.0); function polar(x,y){...};甚至这种all = [first,second] = [1,2,3,4]; 或者这种let transparent = {r:0.0, g:0.0, b:0.0, a:1.0}; let {r:red, g:green, b:blue} = transparent;;
for/each: 和for/in循环不同, for/each遍历对象的属性值而不是属性名, 且可操作类array对象;
for/in: 从js 1.7(mozilla的js引擎版本号)开始, for/in也不局限在array和常规object了, 只要是可循环的元素都可以使用了;
yield: 从python中引入的;
Array Comprehensions:  还是从Python中借用的, let evensquares = [x*x for (x in range(0,10)) if (x % 2 === 0)];
try/catch: 支持多catch;



Chapter 12 - Server-Side JavaScript随着js的发展, 慢慢的超出了其本身的作用域: 浏览器. 随着Google V8引擎为js包入了unix的常用API: files,processes,streams,sockets等, js开始走出浏览器进入server端了. 正式命名为Node.JS. 想来很多人可能都听过, 因为后面我的数目中也包含了相关的书, 且本章内容也没见过太多, 所以就一起留到以后吧~
参考文献:
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (1)</title><link>http://taoalpha.me/blog/2015/06/28/read-coffeescript-programming-with-jquery-rails-and-nodejs/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-28T04:00:00.000Z</pubDate><description>SummaryThe notes I took while I was learning the ‘CoffeeScript’. If you are a real beginner with ‘CoffeeScript’, I suggest you start with another book called “The Little Book on CoffeeScript”, it’s better for beginners. And after that, this one is definitely your best choice.
CoffeeScript is a language which complies to JavaScript. Like the sass or scss to css except that CoffeeScript is not compatible with javascript. So you can not mix the javascript syntax with the CoffeeScript.
This note is mainly about the fist chapter of the book, a nice introduction for CoffeeScript including the basic syntax.

And to improve my english, I think i will start writing english notes for the english books. ^_^

NotesCoffeeScript is pretty popular in the community of JavaScript for its simplicity, elegant and readable. Now let us dive into it.
Instead of  listing the keywords and statements used in CoffeeScript one by one, it would better we learn CoffeeScript from comparing the difference between the CoffeeScript and JavaScript.
CoffeeScript fix some ugly stuffs in JavaScript
CoffeeScript removes most of the semicolons and the curly braces which used a lot in JavaScript, gives us a clearly view of the code, but you can still use the semicolons if you want, and you still have to use the semicolons if you want to put multiple statements in single one;
CoffeeScript learns a lot from ruby and python. Like this one: it uses whitespace or indentation, more accurately, to delimit the code blocks instead of braces.
CoffeeScript removes a lot of parenthesis for many statements and functions, like if..else, while loops and functions with single string parameter. But this is optional, you can still use them if you want. Notice: you will need parenthesis if you want to call a function without any parameters)
Function: as the first class object in JavaScript, CoffeeScript also does a lot improvements for it.
If you write js, you will know that the syntax is really ugly when you want to write a anonymous function. Now you can make it pretty beautiful with CoffeeScript;
CoffeeScript also saves you a lot keystrokes for defining the functions;
so what are the rules?
Replace the function keyword with -&amp;gt;;
Drop the parenthesis if there is no argument for the function;
Put the arguments enclosed with parenthesis in front of the -&amp;gt;, and if the argument has a default value, you can set it in the parenthesis;
Drop the curly braces and use indentation for the function body;
Automatically return the last expression of the function, but if you need return something before, you still need to use the return;





1234567891011121314151617 -&amp;gt; alert 'hi there!'# the code above won't self-initiating, if you want to do that, you need use parenthesis or the `do` keyword like below:# (-&amp;gt; alert 'hi there!')()# do -&amp;gt; alert 'hi there!'square = (n=1) -&amp;gt; n * n# function using splats# this is an alternative way for using Array.prototype.slice()gpaScoreAverage = (scores...) -&amp;gt;  total = scores.reduce (a, b) -&amp;gt; a + b  total / scores.lengthalert gpaScoreAverage(65,78,81)scores = [78, 75, 79]alert gpaScoreAverage(scores...)
1234567891011121314151617181920212223242526272829303132333435var square;(function()&amp;#123;  return alert(&quot;hi there!&quot;);&amp;#125;);/* the code in comments above will compile to:(function()&amp;#123;  if (n == null) &amp;#123;    n = 1;  &amp;#125;  return alert(&quot;hi there!&quot;);&amp;#125;)();*/square = function(n) &amp;#123;  return n * n;&amp;#125;;// [].slice.call(arguments,0) ==&amp;gt;  Array.prototype.slice.call(arguments,0)var gpaScoreAverage, scores,  slice = [].slice;gpaScoreAverage = function() &amp;#123;  var scores, total;  scores = 1 &amp;lt;= arguments.length ? slice.call(arguments, 0) : [];  // get the single score value or a list of the scores  total = scores.reduce(function(a, b) &amp;#123;    return a + b;  &amp;#125;);  return total / scores.length;&amp;#125;;alert(gpaScoreAverage(65, 78, 81));scores = [78, 75, 79];alert(gpaScoreAverage.apply(null, scores));
CoffeeScript saves you a lot of keystrokes
CoffeeScript will declare the variables you need at the top of the function for you automatically. So that means you can’t create the global variables in a function like you can do in JavaScript, actually you can’t use the var keyword in CoffeeScript. &amp;lt;= many people agree that omitting the var keyword makes the variables become global is a really bad desgin…
Object:
CoffeeScript supports the class keyword, and it will create a closure to build the class;
Use the constructor to initialize some private properties, or just omit it;
Every function you define in a class will be added to the object as a prototype method;
Use @ as a shortcut for this;
fat arrow: When you want to use this in previous scope instead of the new scope, you need the fat arrow : =&amp;gt;;
Use super to call the parent’s method (same name, so just pass the parameter);
Use :: as a shortcut for .prototype, so you can extend your prototype as this:Vehicle::stop =-&amp;gt; alert &amp;#39;stop&amp;#39;;



123456789101112131415161718192021222324252627282930313233class Vehicle  # Use the constructor to initialize some private properties  # Use @ as this  constructor: -&amp;gt;    @c = 1  drive: (km) -&amp;gt;    alert &quot;Drove #&amp;#123;km&amp;#125; kilometres&quot;class Car extends Vehicle constructor: -&amp;gt;   @odometer = 0 drive: (km) -&amp;gt;   @odometer += km   super km name:&quot;John Doe&quot; driver: (msg) -&amp;gt;   @msg = msg whoisdriver: -&amp;gt;   @msg()car = new Carcar.drive 5alert &quot;Odometer is at #&amp;#123;car.odometer&amp;#125;&quot;class Person  constructor: (name)-&amp;gt;    @name = name    @mycar = new Car()    @mycar.driver =&amp;gt; alert &quot;#&amp;#123;@name&amp;#125;&quot;mike = new Person &quot;Mike&quot;# use `=&amp;gt;` to show mike's name instead of the default `john doe` set in Carmike.mycar.whoisdriver()
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var Car, Person, Vehicle, car, mike,  extend = function(child, parent) &amp;#123; for (var key in parent) &amp;#123; if (hasProp.call(parent, key)) child[key] = parent[key]; &amp;#125; function ctor() &amp;#123; this.constructor = child; &amp;#125; ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; &amp;#125;,  hasProp = &amp;#123;&amp;#125;.hasOwnProperty;Vehicle = (function() &amp;#123;  function Vehicle() &amp;#123;    this.c = 1;  &amp;#125;  Vehicle.prototype.drive = function(km) &amp;#123;    return alert(&quot;Drove &quot; + km + &quot; kilometres&quot;);  &amp;#125;;  return Vehicle;&amp;#125;)();Car = (function(superClass) &amp;#123;  extend(Car, superClass);  function Car() &amp;#123;    this.odometer = 0;  &amp;#125;  Car.prototype.drive = function(km) &amp;#123;    this.odometer += km;    return Car.__super__.drive.call(this, km);  &amp;#125;;  Car.prototype.name = &quot;John Doe&quot;;  Car.prototype.driver = function(msg) &amp;#123;    return this.msg = msg;  &amp;#125;;  Car.prototype.whoisdriver = function() &amp;#123;    return this.msg();  &amp;#125;;  return Car;&amp;#125;)(Vehicle);car = new Car;car.drive(5);alert(&quot;Odometer is at &quot; + car.odometer);Person = (function() &amp;#123;  function Person(name) &amp;#123;    this.name = name;    this.mycar = new Car();    this.mycar.driver((function(_this) &amp;#123;      return function() &amp;#123;        return alert(&quot;&quot; + _this.name);      &amp;#125;;    &amp;#125;)(this));  &amp;#125;  return Person;&amp;#125;)();mike = new Person(&quot;Mike&quot;);mike.mycar.whoisdriver();
Other Good Things
CoffeeScript will quote reserved words automatically if you use them in your literal object;
You can also drop the comma when you define your literal array or literal object only if you put one property per line, you can drop the braces for object, but you need them for array;
Use #{variable_name} to concatenate the string and variables instead of +, but only use them enclosing with double-quote, the single-quote strings are literal, borrowed from ruby;
CoffeeScript will always convert the == and != to === and !==;
Use the existential operator: ? to check whether a variable exists and has a value or not(means not null or undefined);
Also use the soak: ?. as a shortcut for ternary statement;
Support some new keywords like unless, the opposite to if;
Use plain english aliases for some of the logical operators: is for ===,isnt for !==,not for !,and for &amp;amp;&amp;amp;,or for ||,true can also be yes, or on,false can be no or off;
Support assign multiple values at once;
CoffeeScript replaces the case in switch with when ... then, so you can forget about the break, and it also replaces the default with else;
CoffeeScript supports the chained comparisions: 61 &amp;gt; a &amp;gt; 39;
You can use ### to comment multiple lines. The biggest difference between ### and # is former one will be part of generated javascript;

1234567891011121314151617b=1if a? &amp;amp;&amp;amp; b?  alert &quot;a.c equals to #&amp;#123;a?.c&amp;#125;&quot;[city, state, country] = [&quot;!2&quot;,&quot;24&quot;,&quot;2&quot;]# or function which returns an object with the same structure as you described before the `=`&amp;#123;address: &amp;#123;street: myStreet,room: myRoom&amp;#125;&amp;#125; = getAddress()### =&amp;gt;var b;b = 1;// since we declared the b before, we only need to check if b is null.if ((typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null) &amp;amp;&amp;amp; (b != null)) &amp;#123;  alert(&quot;a.c equals to &quot; + (typeof a !== &quot;undefined&quot; &amp;amp;&amp;amp; a !== null ? a.c : void 0));&amp;#125;var city, country, myRoom, myStreet, ref, ref1, state;ref = [&quot;!2&quot;, &quot;24&quot;, &quot;2&quot;], city = ref[0], state = ref[1], country = ref[2];ref1 = getAddress().address, myStreet = ref1.street, myRoom = ref1.room;###
Special for List
List: CoffeeScript borrowed a lot list comprehensions from python[ x*2 for x in object_name ] and ruby.
while: it works nearly the same as in javascript except that it has an opposite keyword in CoffeeScript: until and both of them can be used as expression and will return a array;
for: the standard statement is [action or mapping] for [selector] in [collection] when [condition] by [step]. Last by following with a number would affect the loop step(`i++``);
[f_number..l_number]: it will create a array with numbers between the fist number and the last number, you can use ...(3 dots) to make the array only contains the numbers in between;
of: for key-value pairs of an object, you can use of to loop them through;



1234567891011121314151617181920212223242526272829303132333435363738394041times = [0..2](n*times while times -= 1).pop()### =&amp;gt; var times; times = [0, 1, 2];((function() &amp;#123;  var results;  results = [];  while (times -= 1) &amp;#123;    results.push(n * times);  &amp;#125;  return results;&amp;#125;)()).pop();###alert x for x in flavors when x != 'h' by 2###=&amp;gt;var x, i, len;for (i = 0, len = flavors.length; i &amp;lt; len; i+=2) &amp;#123;  x = flavors[i];  if (x !== 'h') &amp;#123;    alert(x);  &amp;#125;&amp;#125;###ages = john: 25 peter: 26 joan: 23alert &quot;#&amp;#123;name&amp;#125; is #&amp;#123;age&amp;#125; years old&quot; for name, age of ages###=&amp;gt;var age, ages, name;ages = &amp;#123;  john: 25,  peter: 26,  joan: 23&amp;#125;;for (name in ages) &amp;#123;  age = ages[name];  alert(name + &quot; is &quot; + age + &quot; years old&quot;);&amp;#125;###
Digest
For JavaScript:
Every class in JS is a function object;
Only function object has the default prototype, so the normal objects like literal string, number or even string created from String(),any objects created by functions, they all don’t have the default prototype;
But every object has a default constructor which is exactly the function object who create it;


For CoffeeScript:
If there is only one line in the body, you can move it in front of the condition &amp;lt;= while/until/for/if...



Puzzle
Q1: In the second code example above, CoffeeScript create a default extend function for us:

123456789101112131415161718192021var extend = function(child, parent) &amp;#123;  for (var key in parent) &amp;#123;      if (hasProp.call(parent, key)) child[key] = parent[key];  &amp;#125;  // Start from here  function ctor() &amp;#123;      this.constructor = child;  &amp;#125;  ctor.prototype = parent.prototype;  child.prototype = new ctor();  // End  // Just cannot understand the codes above...  // Why we need another function as the child's prototype? We have already copied all the properties from parent, or we just need a beautiful prototype chain? `Car &amp;lt;= ctor() &amp;lt;= Vehicle() &amp;lt;= Object` compared to `Car &amp;lt;= Car &amp;lt;= Object()`.  // Then why not we just use the child.prototype = new parent() ??? we can still get a good prototype chain. `Car &amp;lt;= Vehicle &amp;lt;= Vehicle &amp;lt;= Object`.  child.__super__ = parent.prototype;  return child;&amp;#125;,hasProp = &amp;#123;&amp;#125;.hasOwnProperty;
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>像TED一样演讲</title><link>http://taoalpha.me/blog/2015/06/25/read-speaking-like-people-on-ted/</link><category>read</category><tag>reading notes,speaking</tag><pubDate>2015-06-25T09:00:00.000Z</pubDate><description>概要今天顺带读完了这本”像TED一样演讲”, 作者上一部和演讲相关的书是”乔布斯的魔力演讲”. 归纳了下书中的核心点, 记录分享给大家. 这一类的书干货其实能占到全书1/10就已经算不错了~ 所以一般看起来也比较快.
阅读笔记情感共鸣
释放你内心的热情 =&amp;gt; 热情可以传染;
掌握讲故事的艺术 =&amp;gt; 故事可以刺激并吸引人脑的注意力, 拉近你与听众的距离;
与演讲主题相关的个人故事;
与演讲主题相关的他人故事;
关于产品或者品牌的某个故事;


让演讲好像好友交谈一样自然;

制造新奇
给人们一个看世界的新视角;
设计让观众惊掉下巴的环节 =&amp;gt; 触发神经学家所说的讲情绪, 让记忆更加深刻;
用幽默给你的演讲加分;

令人难忘
严格遵守18分钟的时间规则 =&amp;gt; 有约束才有创造力;
抓住观众吸引力的魔法, 多感官体验 =&amp;gt; 让内容视觉化;
表现最真实的自己;

书中涉及到的TED(部分)
Bryan Stevenson: We need to talk about an injustice
Dan Ariely: Our buggy moral code
Truly sustainable economic development
Jennifer Granholm: A clean energy proposal – race to the top!
Amy Cuddy: Your body language shapes who you are
Robert Ballard: The astonishing hidden world of the deep ocean
Hans Rosling: The best stats you’ve ever seen
Mary Roach: 10 things you didn’t know about orgasm
Bill Gates: Mosquitos, malaria and education
Jill Bolte Taylor: My stroke of insight
Stephen Hawking: Questioning the universe
David Christian: The history of our world in 18 minutes

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (2)</title><link>http://taoalpha.me/blog/2015/06/18/read-javascript-the-definitive-guide-2/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-18T10:00:00.000Z</pubDate><description>概述作为JS中的一等公民, function(函数)始终是JS的核心中的核心. 所以这里单独用一篇笔记来记录JavaScript: the definitive Guide一书第八章的内容. 主要介绍了函数的定义, 作用域, 参数, 声明以及执行等基础知识, 另外也着重介绍了其高级用法中的closure. 我将自己觉得重要的, 值得记录的部分都作为心得摘抄如下:
心得arguments对象对每一个function而言, 都自动会有一个内置的arguments对象, 用它就可以访问传入的参数了. 通常来说arguments对象我们只会用在不定长传参的函数上, 但arguments本身带有的一个函数却是可以在某些时刻发挥重要作用的~ 这个函数就是callee函数:
12345678// 递归自我调用函数在解决一些问题的时候是很常用的, 而通常情况下我们都会在函数内调用本函数名即可, 但是如果我们需要实现自我调用的函数正好是一个无名函数呢?// arguments.callee 即调用当前执行的函数function(x)&amp;#123;return x*arguments.callee(x-1)&amp;#125;// 如上, 就实现了一个很简单的&amp;gt;2阶乘计算了
需要特别注意的就是callee作为arguments对象的一个方法, 是可以跟随arguments作为参数传递的, 而且其作为参数的时候保持其所指代函数不变.
既然说到arguments, 就多说两句喽. 首先arguments算是一个类array的object. 它本身具有array的一些特性, 比如可以直接调用length函数(通常的object是不能通过.length直接调用获取长度的, 需要使用Object.keys(object_name).length才能获得). 但是它本身和array.length有很大的差别, 其中最大的一个差别就是: 无法通过.length直接更改数组长度.
123456var a = [1,3,4]a.length = 5console.log(a)// output: [1,3,4,undefined x 2](function(x)&amp;#123;arguments.length = 5;console.log(arguments)&amp;#125;)(10,1,2)// output: [10,1,2]
可以看到通过对arguments.length直接赋值, 并不会影响其本身的长度, 这一点和array本身有很大的差别.
PS. 上述示例是增加长度, 其实缩减长度也是一样的, 多余的元素会被自动删除. 所以, 通过直接向array.length赋值也算是一个修改array长度的方法喽~
PSS. 通常如果一个函数接受参数比较多的时候, 为了预防因为参数顺序而产生的问题, 可以采取传json格式的object作为参数, 这样就能够通过key而不根据顺序获取参数了.
Function的property请先看下述代码:
1234567891011f.temp = &quot;test&quot;function f(x)&amp;#123;  console.log(arguments.length);  console.log(arguments.callee.length);  console.log(f.temp);&amp;#125;f(1,2)// output: 2 1 &quot;test&quot;
首先, 我们看一下我们前两个输出值:
  如上所述,arguments.length即代表传入参数的数量, 我们传入了两个参数, 所以这里输出2, 没有任何问题. 那么后面的arguments.callee.length又是什么呢? 为什么它输出的是1呢? 
  根据之前的介绍, 我们当知道arguments.callee是代指当前的函数f(), 那么对应的arguments.callee.length即我们的函数f的length了. 对于Function这个对象而言, 它所拥有的length这一属性特指其声明的参数数量, 我们应该知道JavaScript作为一个很宽松的语言, 其函数定义后接受的参数是不定长的, 即便传入参数与函数声明的参数不相等也是不会抛出异常的, 那么有时候我们需要获取确保函数接受的参数和其声明的参数数量一致, 就可以使用函数自身的length属性来实现;
其次, 我们自定义了一个f的属性temp, 但是我们实在函数定义之前赋予这个属性的, 为什么依然能够在函数运行中输出呢? 
  这主要是因为js的执行顺序所致. js在载入执行过程中, 首先会将内部声明的函数都定义之后才会正式由上至下的逐次执行. 所以这里虽然我们把f.temp写在了函数定义之前, 但是js执行过程中, 还是首先定义了函数f, 接着才开始运行我们的f.temp赋值语句. 自然就不会报错说f没有定义了~
PS. 其实不止是Function, 即便是普通的变量声明, 也是编译和执行分开进行的, 比如var a = 2;也是拆解为var a; a = 2两步执行的, 而声明都是发生在编译过程, 待编译过程全部结束后, 才会由上到下一次执行, 这也是为什么, 单纯的声明可以出现在代码的任意部位都不会影响其所在作用域的生效, 不会爆出not defined的错误;
reserved word, identifier, keyword这三个作为基础知识, 可以说是每门语言都共通的概念,  但很多时候我们都不会用到或者不会特意去区分这三个名词, 而最近因为看原版书, 经常会出现三个词的交叉, 所以这里特别google了以下, 试图总结下三者的区别:

identifier: 通常我们把我们定义的变量名, 函数名, 类名, 标签名,宏定义名, 类型名等称为identifier, 取其标识之意, 用以作为其名称以便代用;
reserved word: 与identifier相对, reserved word则是指由语言规定而保留的一些词, 这些词有着特定的用途而不能被用作identifier;
keyword: 作为语言语法的组成部分之一, keyword通常都会有着特定的含义, 绝大多数的keyword都是reserved word, 但也有少量语法中存在keyword不是reserved word的情况, 比如fortran就没有reserved word的概念, 它的所有keyword都可以用作identifier;

reserved word和keyword确实在很大程度上是共同的, 除了上述说的类似fortran语言这种情况外, 也存在reserved word不是keyword的情况, 比如java中的goto就是一个reserved word, 但本身又不是一个keyword, 所以可以说goto这个词基本在java中是完全废弃的~ 那他们为啥要定义这个goto呢?? 有一种说法是这样情况通常是为未来版本预留的~ 还有一种说法是JVM作者James Gosling最初加了goto的支持, 但后来发现完全没必要, 就又去掉了, 但是为了兼容性问题,也一直没有把goto从reserved word此表中删去.
PS. 很多时候也有人完全不区分reserved word和keyword的区别, 完全等同二者为”不能用来做identifier的词”.
closure - 闭包在javascript中, 一个function由两部分组成: 函数执行的代码以及代码执行的环境. 而这两个组合到一起后也有个专属的名称, 即closure. 不过单独一个独立函数的closure并没有什么值得说的意义, 因为其执行的环境, 即我们称之为scope的东西, 随着函数的执行开始与结束会自动的被创建并清理掉, 所以通常情况下closure都单指在嵌套函数中. 当存在嵌套的函数时, 并且函数之外存在一个reference指向函数的话, 事情就变得好玩多了:
12345678910111213141516171819202122232425262728function f()&amp;#123;  var id = 1;  return function()&amp;#123;console.log(id++)&amp;#125;&amp;#125;f()();f()();f()()// output: 1,1,1// 每次我们调用`f()`,都会自动创建一个包含了其局部变量`id`的对象, 而嵌套的函数`f()()`会自动继承母函数的作用域;// 但每次随着调用结束, 因为没有任何外部引用, 所以创建的对象都会自动的被回收, 如此就导致每次调用`f()()`都会输出1了;var k = f();k();k();k()// output: 1,2,3// 同样是调用`f()`, 但是我们首先引入了一个新的变量`k`引用`f()`函数; // 这样随着`f()`的调用和结束, 其创建的`call`对象(即包含了局部变量id的那个对象)就因为还存在外部引用而得以保留// 所以后面连续调用`k()`的过程中, 本身的嵌套函数就始终共享着`call`对象的作用域, 如此每次输出的时候都是先获取了局部变量id, 然后在执行`id++`,所以输出为1,2,3// 不喜欢`f()()`这种调用方式, 也不想单独创建新变量来增加引用? 当然可以, 只需要借助下`anonymous function`即可:var f = (function()&amp;#123;    var id = 1;    return function()&amp;#123;console.log(id++)&amp;#125;  &amp;#125;)();f();f();f()// output: 1,2,3// `anonymous function`是自执行的函数, 这里相当于把之前的`var k = f()`以及`f()`的声明定义合二为一了.
可以说上述基本就是closure最基本的内容了, 而closure作为js的高级用法之一, 掌握了它, 你就能做很多有意思的操作了. 一个简单的例子就是: 你可以参照closure的原理来模拟实现浏览器探查元素(inspector)的breakpoint功能.
因为原作trimpath上的文章已经无法访问, 所以转载了一个类似的如下, 略作了简单的修改(加了几句更友好的提示和显示每一步的运算结果):
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// This function implements a breakpoint. It repeatedly prompts the user// for an expression, evaluates it with the supplied self-inspecting closure,// and displays the result.  It is the closure that provides access to the// scope to be inspected, so each function must supply its own closure.// // Inspired by Steve Yen's breakpoint() function at// http://trimpath.com/project/wiki/TrimBreakpoint//function inspect(inspector, title) &amp;#123;    var expression, result;    // You can use a breakpoint to turn off subsequent breakpoints by    // creating a property named &quot;ignore&quot; on this function.    if (&quot;ignore&quot; in arguments.callee) return;    while(true) &amp;#123;        // Figure out how to prompt the user        var message = &quot;&quot;;        // If we were given a title, display that first        if (title) message = title + &quot;\n&quot;;        // If we've already evaluated an expression, display it and its value        if (expression) message += &quot;\n&quot; + expression + &quot; ==&amp;gt; &quot; + result + &quot;\n&quot;;        else expression = &quot;&quot;;        // We always display at least a basic prompt:        message += &quot;Enter an expression to evaluate, or just click cancel to see the next step of current calculation.&quot;;        // Get the user's input, displaying our prompt and using the        // last expression as the default value this time.        expression = prompt(message, expression);        // If the user didn't enter anything (or clicked Cancel),        // they're done and so we return, ending the breakpoint.        if (!expression) return;        // Otherwise, use the supplied closure to evaluate the expression        // in the scope that is being inspected.         // The result will be displayed on the next iteration.        result = inspector(expression);    &amp;#125;&amp;#125;function factorial(n) &amp;#123;        var inspector = function(x) &amp;#123;                return eval(x);        &amp;#125;        inspect (inspector, &quot;Entering factorial()&quot;);        var result = 1;        while (n &amp;gt; 1)&amp;#123;                result = result * n;                n--;                inspect(inspector, &quot;factorial() loop with current result:&quot;+result);        &amp;#125;        inspect(inspector, &quot;Exiting factorial()&quot;);        return result;&amp;#125;inspect(function (x) &amp;#123;return eval(x);&amp;#125;, 'Hello')factorial(5)// 通过closure, 它就可以检测factorial执行的各个环节, 从而更容易的找到你在不同环节的问题.
虽然closure让你可以写出更加复杂的js代码, 但是本身closure的使用还是要慎重的, 因为closure需要存储函数对象在内存中而不销毁, 所以如果函数主体庞大, 那么对于内存的压力和运行性能都是会有影响的~
Function constructor类似Array, String等都有着一个对应的类, 可以允许你通过new来创建对象. Function也有自己对应的Function()类, 可以通过:new Function()来创建函数, 其接收不定长参数, 最后一个参数始终作为函数运行主体. 不过通常来说这种方法定义函数远没有我们常用的function关键词来的方便, 所以使用上倒是少了很多~ 不过有几点还是值得注意的:

new ClassFunction() 是把function作为constructor的一种用法, 你可以简单的理解为: var cc = new ClassFunction(params) ==&amp;gt; var cc = new Object();ClassFunction.call(cc,params)
new Function()不接收函数名参数, 即其创建的都是anonymous function;
new Function()不继承作用域, 几遍其是在嵌套函数中定义, 也只继承global域, 不会继承上层函数的作用域;

谜题12345678910111213var name = &quot;The Window&quot;;var object = &amp;#123;  name : &quot;My Object&quot;,  getNameFunc : function()&amp;#123;    console.log(this);    return function()&amp;#123;      return this.name;    &amp;#125;;  &amp;#125;&amp;#125;;console.log(object.getNameFunc()());// output: Object&amp;#123;name:&quot;My Object&quot;&amp;#125;; &quot;The Window&quot;
上述定义中, 为什么嵌套函数没有继承上层函数的this呢? 反而继承了全局的this?
猜测解答: this这个关键字是个比较特殊的关键字, 它具有一个很有趣的特点就是: 当一个函数作为函数而不是方法来调用的时候, this指向的是全局对象, 只有当它是方法的时候, 其指向的才是所属对象; 题目来源阮一峰博客. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (3)</title><link>http://taoalpha.me/blog/2015/06/22/read-javascript-the-definitive-guide-3/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-22T04:00:00.000Z</pubDate><description>概述先说点不相关的… 为了更好的阅读, 所以以后读书笔记相关的博文都会分拆成4个部分:

概述: 算是阅读总结摘要以及类似这段话之类的声明介绍等等;
阅读笔记: 这部分主要以阅读过程中的记录为主, 会比较杂, 基本算是逐点记录, 评判相对主观;
心得: 这部分则主要为笔记的延伸, 算是对笔记的一种补充或者说自己的阅读理解消化所得, 有时候也会覆盖到一些使用架桥等等;
谜题: 这里主要记录一些没有完全理解的部分, 会加上自己的猜测解答, 当弄懂后会更新正解;

DONE.
本篇是博主重新翻阅了”JavaScript the Definitive Guide(第六版)”的前4章内容(之前 阅读笔记-2均是第五版的)后的读书笔记以及心得体会. 内容主要覆盖js的基本用法, 考虑到重复, 这里主要是在上两篇的基础上查漏补缺.
阅读笔记Chapter 2 - 基础知识JS能识别的whitespaces:
常规空格: \u0020 # 即url中常见的%20
Tab(制表符): \u0009 # js中常见的\t
Vertical Tab: \u000B # \v
Form Feed(翻页/页码分隔符): \u000C # \f
Nonbreaking Space(不间断空格): \u00A0  # 通常在html中用来阻止默认连续多空格自动归一的性质(auto collapsing)而使用&amp;amp;nbsp;, 同时因为软件处理的需要, 使用&amp;amp;nbsp;能够防止相应的处理器将普通空格转为行分隔;
Byte order mark: \uFEFF
any character in Unicode category Zs

JS能识别的line terminators:
line feed: \u000A # \n
carriage return: \u000D # \r
line separator: \u2028
paragraph separator: \u2029

值得一说的是, js是支持unicode作为indentifier的合法字符的, 但是上述这些则不在其中.
JS的”Unicode Escape Sequences”类似”\u00E9”这种结构的字符在js都代表一种特殊的字符:”unicode”. 如果你在js中使用这些字符, js会自动将其编译为对应的字符(如果是在js的注释中, 则不会编译, 而是以ascii对待), 比如: 示例就会编译为”é”. 而在js中, 这种对等关系是支持的, 即 &amp;quot;\u00E9&amp;quot; === &amp;quot;é&amp;quot;是为真的.
但是一定要慎用… 因为unicode变化过多, 有时候输出看起来一样的字符, 其本质不一定一样: &amp;quot;e\u0301&amp;quot;的输出也是”é”, 但是它相当于是&amp;quot;e&amp;quot;+&amp;quot;\u0301&amp;quot;组成的.
JS中的&amp;quot;;&amp;quot;在JS中, &amp;quot;;&amp;quot;作为语句结尾并不是必须的, 只有当多语句同行的时候, &amp;quot;;&amp;quot;才是必须的. 当你没有&amp;quot;;&amp;quot;的时候, js会自动为你添加合适的&amp;quot;;&amp;quot;. 通常它会自动将它没有&amp;quot;;&amp;quot;无法解析代码时候遇到的换行处加以&amp;quot;;&amp;quot;(除了类似return,break, ++, –等, 它会自动将其后的行分隔符作为&amp;quot;;&amp;quot;对待.):
1234567var aa=3console.log(a)// output: 3// js在第一个换行处识别了其语句分割的意义, 但是在 a = 3 的两个分割处都因为它可以识别合并后的语句所以没有作为`&quot;;&quot;`处理.
但是上述的成功不意味着js的智能, 更多时候如果我们不合适的使用&amp;quot;;&amp;quot;, 会造成很多奇怪的问题的, 比如以(, [, /, +, -为起始的语句很可能会被误认为是前一语句的延续. 所以通常来说, js的编码还是比较鼓励使用&amp;quot;;&amp;quot;作为语句结尾的.
Chapter 3 - 数据类型Number:
Global viriables: Infinity,NaN
Global Objects: Math,Number

Tips:

NaN 具有唯一性, 其不等于任意值, 包括它自己, 0/0会产生’NaN’, 但是0/0 != NaN, 如果需要判断一个变量是不是NaN, 需要使用isNaN()这个内置的函数;
Infinity &amp;lt;==&amp;gt; Number.POSITIVE_INFINITY &amp;lt;==&amp;gt; 1/0
-Infinity &amp;lt;==&amp;gt; Number.NEGATIVE_INFINITY &amp;lt;==&amp;gt; -1/0
Binary Floating-Point会导致小数级错误, 比如0.3-0.2 != 0.2-0.1, 这个属于计算机本身因为二进制编码的原因所致, 所以在比较数字大小的时候要格外小心;

String:
immutable ordered sequence of 16-bit values

Tips:

string的长度都是按照16-bit来计算的, 所以当如果一个字符超过了16-bit, 则会按照多的计算. 比如: e - \ud835\udc52, 就需要按照两个16bit计算, 即其长度应为:”2”
从ECMAScript 5之后就允许string跨行定义了, 只需要在换行的地方加上一个反斜杠\, 即可.
转义字符\如果加在普通字符前, 不会产生任何效果;
typeof null =&amp;gt; Object , typeof undefined =&amp;gt; undefined;
null == undefined, null!==undefined =&amp;gt; True

类型转换javascript是一个很宽松的语言, 我们不需要预先定义变量类型, 而在运算以及执行过程中, js也会自动的帮助我们进行类型转换, 当然为了更好的借助这一特点, 了解下图中的js转换类型的规则还是非常有必要的.

其中object转换 primitive datatype 的话, 一般会按照如下步骤进行:

首先会默认调用toString()函数, 你可以自行定义这一函数, 如果toString()返回结果正常, 则转换结束;
如果toString()未定义, 或者返回结果非primitive datatype的话, 会自动调用valueOf()函数, 同上一步;
而如果两个都没找到, 那么js将会抛出TypeError;

而根据要转换的是string还是number而交换1,2两步( string 的话先调用toString(), 且返回值必然会转为string; 如果是number的话, 则先找valueOf(), 返回结果为number). 当然至于boolean的话, 所有的object转换到boolean都是true.
Array转换string的时候默认的toString()就是一个join()调用~ Function的话, 则也可以自己定义toString()函数.
Tips:

x + “” // Same as String(x)
+x // Same as Number(x). You may also see x-0
!!x // Same as Boolean(x). Note double !
在ECMAScript 5的strict模式下, 所有变量君需要声明才能赋值, 否则会报错;

Chapter 4: Expressions and Operators
上图为按照优先级顺序排列下来的操作符(横线分隔的同一组块之间的级别相同).
Tips:

运算顺序不影响赋值顺序, 赋值顺序始终都是严格从左到右的, 比如:h = x+y+z, 那么赋值顺序始终都是h-&amp;gt;x-&amp;gt;y-&amp;gt;z; 通常情况下, 这一赋值顺序不会影响之后的计算顺序, 对结果基本没什么影响, 除了一种情况:
如果前变量的赋值会影响到后面变量的值的话, 比如共用同一个变量, 那么这种情况下, 赋值顺序就可能会对结果产生一定的影响了. 最简单的例子就是z = 2;y = function(){z = 3;return 1};, 因为y是一个函数, 而它的执行会改变z的值, 所以y()+z和z+y()的结果就是不相同的.

“+”运算符中的类型转换:

string优先, 只要有两个操作数中有一个是string或者是有toString()的object, 那么其都会按照string来进行链接运算;
除非两个都是非string, 才会进行加法运算;
当”+”作为单操作数时, 则意味着将操作数向number类型转换;


&amp;amp;&amp;amp;运算符如果第一个为false, 则不执行第二条判断, 所以可以用这个方法来代替if: (a==b) &amp;amp;&amp;amp; alert(&amp;quot;a equals b&amp;quot;)就相当于if(a==b) alert(&amp;quot;a equals b&amp;quot;).

!(p &amp;amp;&amp;amp; q) === !p || !q
!(p || q) === !p &amp;amp;&amp;amp; !q
a op= b 和 a = a op b通常是等价的, 除非a本身的重复赋值会有副作用, 比如 a[i++] += 1和a[i++] = a[i++] +1就不一样, 因为后者前后两个i不同了.
eval()函数会继承当前的scope, 除非eval()被赋予某个新的reference, 那样的话只会使用global的scope;
void操作数很少用到, 它是个单操作数的操作符, 其用法就是丢弃操作数的返回结果, 然后返回 undefined…

心得whitespaces 和 line terminators通常在js里面我们使用\s来统一代表所有其可以识别的whitespace, line terminators. 如下例:
1234567var k = 'asd \t asdasd \na asd \f asda dad\rasd\u2028asd\u2029\u00A0'k// output 里面有两个换行的符号, 我这里为了演示方便就不换行了k.replace(/\n/g,'-')// 同上,里面的&quot;\r&quot;我也不换行了k.replace(/\s/g,'-')// output: &quot;asd---asdasd--a-asd---asda-dad-asd-asd--&quot;
因为在console中输出的时候是不换行的, 所以有时候单单看console输出的话, 类似这种编码问题所致的错误就找不出来, 为了省事, 我们可以统一使用\s来代表所有此类符号.
谜题Q: 按照正常来说Number.MAX_VALUE加上一个数应该就会自动转为Infinity, 但实际上, 测试过程中发现, 只有当Number.MAX_VALUE加上一个足够大的数后才会等与Infinity, 这是为什么?
1234567Number.MAX_VALUE// output: 1.7976931348623157e+308Number.MAX_VALUE +1// output: 1.7976931348623157e+308...Number.MAX_VALUE + Math.pow(10,1000)// output: Infinity
正解: the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign.

IEEE 754
In the following two rounding-direction attributes, an infinitely precise result with magnitude at least bemax ( b − ½ b^(1-p) ) shall round to ∞ with no change in sign; here emax and p are determined by the destination format (see 3.3). With:

roundTiesToEven: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with an even least significant digit shall be delivered

roundTiesToAway: the floating-point number nearest to the infinitely precise result shall be delivered; if the two nearest floating-point numbers bracketing an unrepresentable infinitely precise result are equally near, the one with larger magnitude shall be delivered.



ECMAScript does not specify which of the round-to-nearest, but it doesn’t matter here because both gives the same result. The number in ECMAScript is “double”, in which

b = 2
emax = 1023
p = 53,

_so the result must be at least 2^1024 - 2^970 ~ 1.7976931348623158 × 10^308 in order to round to infinity. Otherwise it will just round to MAX_VALUE, because that is the closer than Infinity.Notice that MAX_VALUE = 21024 - 2971, so you need to add at least 2^971 - 2^970 = 2^970 ~ 9.979202 × 10^291 in order to get infinity._
Q: &amp;#39;0&amp;#39; == false 是 true, 为什么 null == false 就是 false呢?
猜测解释: ==这样的是比较value的, 而 null转换为boolean类型为false, 并不意味着两者的value是相同的. ==只会比较value, 而不会进行转换. 也即true, false两个boolean类型的其value也是1,0. 而null和undefined的value则不同, 前者为空, 后者为无.
参考资料:
JavaScript the Definitive Guide 6th edition
Unicode Property
List of Unicode Characters
编码历史介绍

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (4)</title><link>http://taoalpha.me/blog/2015/06/23/read-javascript-the-definitive-guide-4/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-23T07:00:00.000Z</pubDate><description>概述第六版和第五版的最大区别在于ECMAScript 5的引入, 这是目前发布的最新的js版本, 有着最新的属性和函数, 目前主流浏览器基本都已经完全支持. 本文为阅读5-9章内容的笔记总结, 主要是覆盖了JS中的语句和典型对象.
阅读笔记Chapter 5 - Statements
switch/case中使用的是===进行比较判断的, 而不是==;
with带入scope chain的对象只有读取权限, 没有写入功能, 即with后, 可以获取其代入的对象, 但其内声明的变量都依然归于gloabl或者local之中;
debugger是ECMAScript 5引入的一个新的statement, 起主要作用是和浏览器结合使用, 用于创建断点以便查错使用;
use strict也是ECMAScript 5引入的, 严格来说不算statement而是directive, 不过两者很是相近; 其使用必须位于js整体的起始位置或者是一个function主体的起始位置;
use strict的使用会开启代码的strict mode, 为了提升效率, 错误追踪以及更好的安全性, 其语法要求会更加严格, 简单列举如下:
停用with语句;
所有变量必须声明才能调用;
所有独立声明的函数而非对象的方法定义的, 其this域都默认为undefined, 而函数如果通过apply,call调用, 其this域为传入对象;
对未声明变量的赋值或者不能写入的对象进行写入, 都会抛出异常;
eval调用会自动创建临时局部scope, 不再能直接对母域新建声明了;
arguments成为传入参数的硬拷贝, 和传入参数名之间不在绝对相等, 即改变一方不会引起另一方的改变, 同时停用其caller,callee方法;
delete用于变量, 函数或者函数参数的时候会抛出异常, 操作对象的某个未声明属性也会抛出异常;
对象(包括函数)创建中不能出现同名属性(参数);
直接声明的八进制数是不允许的(即0开头的数字);
eval,arguments作为keywords对待, 不能赋值, 或赋予其他变量, 也不能用于identifier;




Chapter 6 - Objects
Property Attributes (ECMAScript 5之后引入可自定义配置, 之前默认三者皆有.)
writable: 可赋值;
enumerable: 可递归;
configurable: 可配置 - 可删除也可修改;


Object Attributes
portotype: 指向当前对象的属性继承对象;
class: 指代对象所属类别;
extensible: 指示当前对象是否能够新增属性 (ECMAScript 5引入);


Object Categories and Property Types:
native object: js中内置的对象, 包含Arrays, functions, dates, regular expressions等;
host object: 由js运行环境所定义的对象, 比如常见的浏览器, 就包含了HTMLElement对象;
user-defined: 执行js代码的时候创建的对象;
own property: 直接由对象中定义的属性;
inherited property: 由对象的prototype object继承来的属性;


Prototype:
任何一个对象(除了Object.protytpe)的出现都必然包含了第二个对象的存在: new Array() =&amp;gt; Array.prototype;
Object.prototype是唯一一个没有母继承的对象了, 它是最顶部的类;
类似new Array() =&amp;gt; Array.prototype =&amp;gt; Object.prototype这样的两个prototype就组成了Array的prototype chain;
Object.create() 是ECMAScript 5引入的新的创建对象的方法, 其接受两个参数, 第一个参数会作为新建对象的prototype传入, 第二个则是用来描述新对象的属性的. 如果你传入null, 则新建对象是完全没有prototype的, 只有Object.create(Object.prototype)才是等价于我们常用的{} or new Object();
获取某个object的未定义属性将返回undefined, 但是获取undefined或者null的某个属性则会抛出异常;


getter &amp;amp;&amp;amp; setter
ECMAScript 5新引入的两个accessor properties, 分别对应某个属性的调用和赋值;
只有setter的属性只有写入权限, 只有getter的属性则是只读权限;


property attributes
value, writable, enumerable, and configurable
对应的accessor property: get, set, enumerable, and configurable
Object.getOwnPropertyDescriptor(object_name, property_name) 获取某个属性的特征描述;
Object.defineProperty(object_name, property_name,{property_attribute:attribute_value}) 对某个属性设定其特征描述;



下例即为利用Object.defineProperty自定义的一个extend()函数:
123456789101112131415161718192021222324252627282930// Example 6-3. Copying property attributes/** Add a nonenumerable extend() method to Object.prototype.* This method extends the object on which it is called by copying properties* from the object passed as its argument. All property attributes are* copied, not just the property value. All own properties (even non-* enumerable ones) of the argument object are copied unless a property* with the same name already exists in the target object. */Object.defineProperty(Object.prototype,  &quot;extend&quot;,  &amp;#123;    writable: true,    enumerable: false,    configurable: true,    value: function(o) &amp;#123;      // Define Object.prototype.extend      // Make it nonenumerable      // Its value is this function      // Get all own props, even nonenumerable ones      var names = Object.getOwnPropertyNames(o); // Loop through them      for(var i = 0; i &amp;lt; names.length; i++) &amp;#123;        // Skip props already in this object        if (names[i] in this) continue;        // Get property description from o        var desc = Object.getOwnPropertyDescriptor(o,names[i]);        // Use it to create property on this Object.defineProperty(this, names[i], desc);      &amp;#125;    &amp;#125;  &amp;#125;);

Object Attributes;
Object.getPrototypeOf() ECMAScript 5引入, 可用于获取某个对象的prototype;
p.isPrototypeOf() 同上, 用于判断某个对象是否为另一个对象的prototype;
Object.isExtensible(),Object.preventExtensions()则分别是用于判断一个object是否是可扩展的, 以及禁止其可扩展性的(此操作不可复原);
Object.seal()类似Object.preventExtensions(), 不过它同时禁掉了properties的configurable属性,Object.isSealed()则是对应用于判断是否sealed的函数;
Object.freeze()比Object.seal()还要严格,所有属性都变为可读了, 对应的查询函数为:Object.isFrozen();
Object.preventExtensions(),Object.seal(),Object.freeze()都是只针对当前object而言的;
class属性目前基本没啥用, 有点等价或者说更细化的typeOf or instanceOf了;



Chapter 7 - Arrays这里主要记录ECMAScript 5引入的一些新的方法, 3已有的可以查看 阅读笔记-2

forEach(value,index,array_itself): array自身的循环调用函数, 相当于for(i in array_name){}, 区别在于其不支持break等可以跳出循环的语句, 如果你想要提前结束循环, 就需要通过try/catch包裹并利用抛出异常来结束循环;
map(): 也算是循环的一种, 遍历每个元素并传递给传入的函数, 最终返回一个新数组;
filter(): 顾名思义, 这是对数组进行筛选的, 值得一提的是filter()会自动跳过空白,所以对于稀疏数组通过filter()可以去除所有空白, 在加上undefined判断, 就可以去除所有空值了;
every() 和 some(): every()是当数组每个元素都使传入函数为真的时候返回真, some()则是只要一个为真即返回为真, 需要注意的事, 对于空数组, every()会返回真, 而some()会返回为假;
reduce(function,initial_value) 和 reduceRight(): 通过执行传入函数而对数组元素进行整合,计算,判断, 最终返回一个结果: var max = a.reduce(function(x,y) { return (x&amp;gt;y)?x:y; });即返回数组的最大值; reduceRight()与reduce()一致, 只是循环顺序相反, 从右到左; 当没有声明初始值时, 采用第一个执行元素作为初始值;
indexOf() 和 lastIndexOf: 顾名思义, 获取数组中某个元素的index, 前者获取首个匹配元素的index, 后者获取最后一个匹配元素的index;

Chapter 8 - Functions
Functions的调用有四种:
直接调用;
作为对象的方法调用;
作为constructor调用;
通过call,apply方法调用(间接调用);


call() 和 apply:
call和apply都是间接调用的方法, 允许一个函数临时客串为某个object的方法;
一定程度上, 可以等价于o.m = f;o.m();delete o.m;
其接受的第一个参数会成为函数运行的this域, 如果是非strict mode下, 传入null/undefined则会自动将global作为this, 而如果传入的是primitive datatype, 则自动转为对应的wrapper object, 即string =&amp;gt; String;
call和apply的区别主要体现在后面的参数上, 前者以分散元素传入, 后者则以整体数组形式传入, 所以用apply可以把原本只支持不定长参数的函数转换为接受数组的函数:var biggest = Math.max.apply(Math, array_of_numbers);;
apply对类array元素处理方式同array元素;


bind(): 很是类似call和apply, 本质也是把某个函数作为某个对象的方法调用, 实现则是通过把object和function绑定, 形成一个新函数从而每次调用新函数都等价于调用了object.funtion, bind接受多个参数, 其首个以后的参数都会作为this域成员代入函数中, 并按序成为函数自身的参数function f(y,z) { return this.x + y + z };var g = f.bind({x:1}, 2);g(3) // 2被赋予了y, 新的3则给了z;
higher-order function: 作用于另一个函数之上的函数;

partial and memoization 这两个都是function programing中常用的方法:

partial: 类似bind()这种会把传入参数默认分配到函数自身的部分接受参数上的做法就是partial application;
memoization: 将函数运行过程的计算结果缓存起来的方式;



123456789101112131415161718192021222324function array(a, n) &amp;#123; return Array.prototype.slice.call(a, n || 0); &amp;#125;// 用以处理类array元素(转为真正的array)function partial(f /*, ... */) &amp;#123;  var args = arguments;  // 存储partial的参数  return function() &amp;#123;    var a = array(args, 1);    // 取出首位以后的参数    var i=0, j=0;    for(; i &amp;lt; a.length; i++)      if (a[i] === undefined) a[i] = arguments[j++];      // 这里的arguments是第二层参数      // 将空元素逐个替换成第二层参数里的值, j自动随着执行+1    a = a.concat(array(arguments, j))    // 组成新的参数数组    return f.apply(this, a);    // 调用f函数, 并传入参数a  &amp;#125;;&amp;#125;var f = function(x,y,z)&amp;#123;return x*y*z&amp;#125;partial(f,undefined,2)(1,3)// x:1,y:2,z:3
123456789101112131415// Return a memoized version of f.// It only works if arguments to f all have distinct string representations.function memoize(f) &amp;#123;  var cache = &amp;#123;&amp;#125;;  return function() &amp;#123;    var key = arguments.length + Array.prototype.join.call(arguments,&quot;,&quot;);    if (key in cache) return cache[key];    else return cache[key] = f.apply(this, arguments);  &amp;#125;;&amp;#125;// 应用方式类似;var factorial = memoize(function(n) &amp;#123;return (n &amp;lt;= 1) ? 1 : n * factorial(n-1); &amp;#125;);factorial(5) // 此时会自动缓存4,3,2的阶乘值. 对于一些复杂的运算, 如此可以很好的加快运算速度.
Chapter 9 - Classes and Modules除了 阅读笔记-2中包含的, 由于ECMAScript 5所引入的那些object property自然都可以应用到新的class中, 从而创建更为复杂有效的函数. 其实js中目前不存在class这个关键词, 所以其模仿的class, 说白了就是一个复杂一些的函数对象.
而因为其内容驳杂繁多, 我么会在后面的应用中有很多实践的机会, 这里就不一一描述了.
参考资料
JavaScript the Definitive Guide 6th edition
Functional Javascript

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>CoffeeScript Programming with jQuery, rails and Nodejs (2)</title><link>http://taoalpha.me/blog/2015/06/30/read-coffeescript-programming-with-jquery-rails-and-nodejs-2/</link><category>read</category><tag>CoffeeScript,jQuery,js,nodejs,rails,reading notes</tag><pubDate>2015-06-30T04:00:00.000Z</pubDate><description>SummaryAfter learned the basic syntax of CoffeeScript, I re-wrote all my blog’s js files with CoffeeScript. I have to say, practice is the best way to learn and understand one skill. Especially for coding, if you just read the book and never write a single line by yourself, you will never become a master of it or you may stick in the beginner for ever.
Today we will finish the book. Talking about how to combine the CoffeeScript with some other web tools we use a lot: jQuery, Rails and Nodejs.
NotesHere I just ignored the second chapter about how to install the coffeescript and nodejs in your computer, if you need some help, feel free to comment below the blog or just visit the nodejs and coffeescript to find a way yourself.
jQueryjQuery is the most popular js module people used in their websites or webapps. And using jQuery with CoffeeScript is just like javascript. jQuery is javascript, after all.
Want to use CoffeeScript with jQuery? Just do it and follow the rules we learn from the basic syntax part. Here I list several examples and if you look it closely, you will find everything you have already known if you read the first chapter carefully. The author of the book shows us another complex examples: TodoMVC in CoffeeScript.
BTW: TodoMVC is a great project which shows you how to write a todo app in all kinds of tools and frameworks.
1234567891011121314151617181920212223242526272829303132333435363738394041$ -&amp;gt;  do some  do another### =&amp;gt;$(function() &amp;#123;  some();  return another();&amp;#125;);That's just like the $(document).ready(function()&amp;#123;&amp;#125;)#### A function using ajax to send mail, which is a new feature I will add to my blog in a few days :)@sendMail = (msg)-&amp;gt;  $.ajax    type: 'POST'    url: 'https://mandrillapp.com/api/1.0/messages/send.json'    data:      'key': ''      'message':        'from_email': msg.sender_mail        'from_name' : msg.sender_name        'to': [            &amp;#123;              'email': ''              'name': 'TaoAlpha'              'type': 'to'            &amp;#125;          ]        'autotext': 'true'        'subject': msg.subject        'html': msg.content  .done (response)-&amp;gt;    showAlert(&quot;success&quot;,&quot;Thanks for your contribution!&quot;)  .fail (data)-&amp;gt;    showAlert(&quot;fail&quot;,&quot;Sorry! Failed to send the email. Please retry!&quot;)# another function to get unique result from an array of objectsArray::getObjectUnique = (id) -&amp;gt;  a=b=[];  add = (data) -&amp;gt; b.push data[id];data  (add i for i in @ when b.indexOf(i[id]) == -1 )
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// You can see that you have saved a lot of keystrokes and the codes look more clean and beautiful.// Because coffeescript doesn't support declare global variables directly, and if we want to use the function in other script, we need to declare it into the `this` scope.this.sendMail = function(msg) &amp;#123;  return $.ajax(&amp;#123;    type: 'POST',    url: 'https://mandrillapp.com/api/1.0/messages/send.json',    data: &amp;#123;      'key': '',      'message': &amp;#123;        'from_email': msg.sender_mail,        'from_name': msg.sender_name,        'to': [          &amp;#123;            'email': '',            'name': 'TaoAlpha',            'type': 'to'          &amp;#125;        ],        'autotext': 'true',        'subject': msg.subject,        'html': msg.content      &amp;#125;    &amp;#125;  &amp;#125;).done(function(response) &amp;#123;    return showAlert(&quot;success&quot;, &quot;Thanks for your contribution!&quot;);  &amp;#125;).fail(function(data) &amp;#123;    return showAlert(&quot;fail&quot;, &quot;Sorry! Failed to send the email. Please retry!&quot;);  &amp;#125;);&amp;#125;;# get unque result for array of objectsArray.prototype.getObjectUnique = function(id) &amp;#123;  var a, add, b, i, j, len, results;  a = b = [];  add = function(data) &amp;#123;    b.push(data[id]);    return data;  &amp;#125;;  results = [];  for (j = 0, len = this.length; j &amp;lt; len; j++) &amp;#123;    i = this[j];    if (b.indexOf(i[id]) === -1) &amp;#123;      results.push(add(i));    &amp;#125;  &amp;#125;  return results;&amp;#125;;
RailsRuby on Rails is a web framework that came around in 2004. And it soon became quite popular. Actually many people believe that Rails saved the ruby…
Check this:How to download and install Rails if you haven’t installed it.
Rails’s principles
Convention over configuration


Rails is designed to assume that the programmer will follow certain known conventions, which if used, provide great benefit and much less need to configure the framework.That means that the framework makes assumptions on how a typical application should be built and structured and it doesn’t try to be overly flexible and configurable. This helps you spend less time on mundane tasks like configuring and wiring up an application architecture and more time on actually building your app.


Don’t repeat yourself, or DRY


Every piece of knowledge must have a single, unambiguous, and authoritative representation within a system.Rails strives to remove duplication and boilerplate wherever it can.

How to use Rails with CoffeeScriptLuckily, after Rails 3.1, you don’t need do anything to let Rails support CoffeeScript. It has already become part of rails! And also, rails has changed its default js library to jQuery.
So what you need to do if you want to use coffeescript with rails? Nothing but learn rails!
Just like the author said in the book: “If you haven’t done so already, I encourage you to spend some more time learning Rails as well as Ruby, and immersing yourself in the wonderful communities they support.”
Node.jsNode is fantastic. It changes something. Before node, javascript was mostly run inside browsers. Now it just came out and gave web developers a chance to become a full-stack!
Features of Node
Event-driven


The Node.js framework only allows non-blocking, asynchronous I/O. This means that any I/O operation that is accessing an external resource, such as the operating system, a database, or a network resource must happen asynchronously.


Fast and scalable


The V8 JavaScript engine(created by google and used in chrome) used by Node.js is highly optimized for performance, thus making Node.js applications very fast. The fact that Node is non-blocking will ensure that your applications will be able to handle many concurrent client requests without using a lot of system resources.


Node is not Rails


Rails strives to be a full-stack solution to building web applications, whereas Node.js is more of a low-level system for writing any type of fast and scalable network application.

Node and CoffeeScriptWant to write coffeescript in node? It’s easy, all you need is a module named CoffeeScript. And like many other languages, node has several frameworks people built for web development, like: Express.
The core about how to use coffeescript with nodejs is to use the --watch for coffee command in node. It will automatically compile all file end with coffee into js when there is a change made into these files.
And just like jQuery, you just follow the rules and write your code.
DigestCoffeeScript is a tool that can help you write js more quickly and elegant. And any platform or language you want to use coffeescript, what you need to do is following the coffeescript’s rules. There is no difference caused by platform or language.
That’s all. Thanks!
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (6)</title><link>http://taoalpha.me/blog/2015/06/25/read-javascript-the-definitive-guide-6/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-25T10:00:00.000Z</pubDate><description>概述正式进入本书第二部分的内容, 核心主要围绕在浏览器内的js. 包含了最基本的使用方式, 方法, 因浏览器而增加的各种属性方法, 操作css, dom的方法, 以及常用的一些js框架, 库等, 同时还包含了目前浏览器大热的安全领域.
阅读笔记Chapter 13 - JavaScript in Web Browsers
异步:
defer: 使浏览器在解析并加载渲染完HTML的DOM后加载此js脚本;
async: 使浏览器在尽快执行js脚本, 但在下载js脚本时不停止DOM的解析, 优先级高于defer;
使用方式为在script中增加关键字即可: &amp;lt;script defer src=&amp;quot;deferred.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;;
注意在使用defer/async的时候, js中不能使用document.write();
document.readyState的变化过程: loading(async downloading, normal executing) =&amp;gt; interactive (defer/async executing) =&amp;gt; complete(defer/async done, event handlers invoked);


Compatibility Check:
按照目前的浏览器格局, 基本上一个浏览器就有着一种js的版本, 除了标准版本的基础功能之外, 所有的扩展功能, 各家与各家的实现方式都略有不同, 所以在使用过程中, 就需要我们考虑到兼容性的问题;
Can I Use…, 这是一个非常优秀的检测某个属性, 方法的浏览器支持度, 拿不准的都可以在这里进行查询确认, 其还支持css和html5的检测;
IE5的时候引入了一个Conditional Comments的技巧, 是通过特殊的html注释从而让浏览器识别其IE版本, 比如&amp;lt;!--[if lte IE 7]&amp;gt;&amp;lt;![endif]--&amp;gt;就代表IE7及以下, 而写在这个if里面的内容就会在IE7及以下的浏览器中被识别并作为页面html的一部分而提取出来(仅限IE浏览器), 其他的浏览器都会自动当做注释不理会此部分;
IE的JS也支持Conditional Comments, 比如/*@cc_on @if (@_jscript)...@end @*/, 这里面@cc_on...@*/是整个Conditional Comments, 而里面的@if (@_jscript)...@end则是判断部分, 其中@_jscript是IE自身js编译器的名称;


Accessibility:
对于身体原因而有不便的人, js的支持效果会大打折扣, 所以根据这部分人的情况而优化自身的网页结构, 目前也是网页设计的一大核心之一;


Security:
随着js的发展使用, 其危害性也日益提升;
目前的保障安全手段主要有:限制其功能,限制其使用范围和情景,敏感权限默认关闭虚人工开启;
The Same-Origin Policy: js只允许读取与当前执行环境域名相同域名下的windows属性, 那么怎么界定相同域名呢:
来自不同的网络服务器;
来自相同的网络服务器, 不同的端口;
同一网络服务器, 同一端口, 不同的http协议(http,https);
以上, 都认为是不同域名;


如何舒缓此规则:
document.domain: 考虑到同级子域名也会被禁止, 那么通过设定document.domain为同一母域名即可实现同级子域名的跨域;
Cross-Origin Resource Sharing: 通过http请求新增的Access-Control-Allow-Origin头部, 服务器就可以指定其允许跨域的程度了;
cross-document messaging: HTML5新增了一些很强大的API,cross-document messaging API就是其中之一, 它允许不同的document之间的js进行通讯;





Chapter 14 - The Window Object
Timers:
setTimeout(): 延时触发;
setInterval(): 定时循环执行;
clearTimeout(): 清除延时触发;
clearInterval(): 清除定时循环;


Location:
window.location === document.location 两者皆为当前页面url, 并随页面url变化而更新;
document.URL 也是指代加载后的当前页面, 但不随页面内动态变化引起的url变化而变化;
Location这个对象本身包含了多个属性分别指代url的不同部分:protocol表示网络协议, host, hostname通常都指示域名,前者包含端口, port表示端口, pathname表示以域名根目录为/的相对路径, search表示url中?以后的部分但不包含hash部分, hash则是表示url#以后的部分;
Location还包含了三个常用的函数:assign(),replace(),reload(), 其中前两者功能都一样, 都是用以加载新页面的, 不过replace()加载的同时将当前页面从history中去除了(就是不能后退后之前页面了), 而assign()还保留着; reload()就更不用说了, 只是单纯的重载页面;


History:
back(),forward(): 等价于浏览器的后退,前进按钮;
go(n): 接受数字作为参数, 表示向前或者后退n个页面;
如果页面中有iframe, 那么其history会自动合并到主界面的history中;


Navigator:
appName: 浏览器的名称;
appVersion: 浏览器版本号;
userAgent: 用户代理, 对应HTTP的USER-AGENT;
platform: 操作系统;
onLine: 是否连通网络, HTML5支持;
geolocation: 用户地理位置信息, HTML5支持;
javaEnabled(): 对Java扩展的支持, 非标准;
cookiesEnabled(): 能够设置cookie, 非标准;


Screen:
width,height: 当前屏幕的长宽尺寸;
availWidth,availHeight: 去除功能区等部分之后的实际展现内容的屏幕尺寸;
colorDepth: 显示屏幕的bits-per-pixel;


Dialog Boxes:
alert(): 弹出对话框, 展示传入的信息;
confirm(): 自带OK,Cancel按钮的对话框, 返回对应的boolean值;
prompt(): 附带输入框, 返回输入的值;
上述三个类型的对话框的样式结构都无法调整, 是浏览器默认设定的;
showModalDialog(): 则更加复杂, 它可以支持弹出一个页面, 其接受的第一个参数即为页面的url, 后面的参数则是弹出窗口的属性; 在chromium中已经被禁止了


onerror handler:
用于处理错误信息的, 你完全可以定制这个函数来更好的显示js中的错误信息;


Document Elements As Window Properties:
当一个html元素被赋予了id时, 其id对应名称的全局变量不存在时, 其自动转为全局变量, 属性名称即为id名, 但如果id名已经被使用, 则不生效;
对于&amp;lt;a&amp;gt; &amp;lt;applet&amp;gt; &amp;lt;area&amp;gt; &amp;lt;embed&amp;gt; &amp;lt;form&amp;gt; &amp;lt;frame&amp;gt; &amp;lt;frameset&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;img&amp;gt; &amp;lt;object&amp;gt;这样的元素, 其name值和id效果是一样的, 且name值支持多个元素相同, 会自动生成类array形式, 对于iframe, 对应的属性会指向其内嵌窗口的window对象;


Multiple Windows and Frames:
通过js打开的新窗口都可以被js获取到, 并进行操作, 但是需要符合same-origin的原则;
frame嵌入的窗口可以通过parent.frames属性来获取, 也可以通过其自带的contentWindow来获取;



谜题
Q: 在测试same-origin的时候, 发现有些网站可以设定子域名的document.domain为母域名, 有些不能? 比如在google的搜索结果页, 就可以, 但是在github pages中想要设置为github.io就不可以, 会出现&amp;#39;github.io&amp;#39; is a top-level domain.这样的错误?

参考资料
JavaScript the Definitive Guide 6th edition
Can I Use …
host and hostname

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (7)</title><link>http://taoalpha.me/blog/2015/06/26/read-javascript-the-definitive-guide-7/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-26T06:00:00.000Z</pubDate><description>概述阅读笔记Chapter 15 - Scripting Documents
Selecting:
document.getElementById(id): 通过id, 一个id对应一个元素;
document.getElementsByName(name): 通过name, 可多个;
document.getElementsByTagName(tagname): 通过标签名;
document.getElementsByClassName(class_name): 通过类名;
querySelectorAll(css_selector): 通过css的选择器, 返回所有匹配;
querySelector(css_selector): 返回首个匹配;


Trees of Nodes:
parentNode: 父节点;
childNodes: 子节点;
firstChild, lastChild: 首个或者最后一个子节点;
nextSibling, previousSibling: 下一或者上一兄弟姐妹节点;
nodeType: 节点类型, Document 节点返回9, 元素节点返回1, 文本节点返回3,注释节点返回8, DocumentFragment节点返回11;
nodeValue: 当前节点的文本内容;
nodeName: 标签名, 大写;


Trees of Elements: 忽略所有的文本节点和注释节点;
firstElementChild, lastElementChild: 返回首个或者最后一个元素节点;
nextElementSibling, previousElementSibling
childElementCount: 返回子元素节点的个数;


Attributes of Elements:
getAttribute()
setAttribute()
hasAttribute()
removeAttribute()


Dataset Attributes: 由HTML5引入, 所有带data-前缀的属性都算是合法的html元素属性.
Element Content:
innerHTML
outerHTML: 包含匹配元素自身标签;
insertAdjacentHTML(): 允许指定插入位置beforebegin, afterbegin, beforeend or afterend;
textContent: IE不支持
innerText: IE支持, 功能同上;


Creating,Inserting, and Deleting Nodes
document.createElement(tag_name)
document.createTextNode(text): 创建文本节点;
document.createComment(text): 创建注释节点;
document.createDocumentFragment(): 创建孤立节点;
node_name.cloneNode(): 复制当前节点;
element_node.appendChild(element_node_2): 由后插入;
element_node.insertBefore(element_node_2): 由前插入;
removeChild(): 移除当前节点n.parentNode.removeChild(n);;
replaceChild(): 替换


DocumentFragment: 孤立节点, 其没有母节点(null), 当appendChild()等操作针对其时, 操作执行对象自动变为其所有子节点, 且操作完成后, 其自身为空;
viewport: 表示实际展示内容的窗口, 在顶层网页中为去除浏览器菜单等等之外的部分, 而在iframe中则为iframe定义的frame大小;
document: 表示页面内容的窗口, 通常都大于viewport;
getBoundingClientRect(): 返回节点的长宽,上下左右边界属性width,height,top,left,bottom,right, 返回的结果是基于viewport的;
document.elementFromPoint(): 返回x,y处的元素节点 - 根据z-index, 从外到内的返回;
scroll(), scrollTo(), scrollBy(): 窗口滚动控制, 最后的scrollBy()传入的x,y表示在原有的基础上的增加值;
scrollIntoView(): 滚动到某个节点;
document.forms: 获取页面中所有form元素;
其他document属性:
cookie
domain
lastModified: 修改时间;
location: 等同于window.location
referrer
title
URL: 之前提到过, 其只保存打开时的当前链接, 不随页面内的动态变化而变化;



Chapter 16 - Scripting CSS
js可以通过node.style来访问元素样式属性, 可以获取, 赋予; 而通过更加复杂的函数变化, 就可以创造出一些很棒的动效来, 在css3之前, 所有的非gif或者flash动效基本都是通过js实现的.
window.getComputedStyle(element,&amp;quot;null or :first-line etc&amp;quot;)则可以获取某个元素(或者某个元素的伪类)的所有样式属性, 同时获取的值都会自动转为标准的绝对值(比如设定的百分比也会自动计算出来返回),但是其不能赋予;
disableStylesheet()可以禁止某个元素的所有样式, 如果传入的是数字, 那么会按照document.styleSheets的顺序查找, 如果是string, 则作为css selector查询对应的元素;
insertRule(rules,insert_index), deleteRule(rules) 即插入整条的结构化的css语句, IE下对应的函数为addRule(),removeRule();
document.createStyleSheet则可以创建一个新的样式表, 等价于在head里面创建一个style标签;

Chapter 17 - Handling Events
Events的类型
Device-dependent input events:mousedown, mousemove, mouseup, keydown, keypress, keyup, touchmove, gesturechange;
Device-independent input events: click
User interface events: focus, change
State-change events: loadstart, progress, loadend
API-specific events: dragstart, dragenter, dragover, drop, waiting, playing, seeking, volumechange etc
Timers and error handlers;


Handlers:
Event Handler Attributes: onclick=&amp;quot;&amp;quot;,window.onload = f();
addEventListener(event_name,function,[capturing event handler]): 添加事件, 最后的capturing通常为false;
removeEventListener(): 和上面的add相反;
stopPropagation(): js的事件触发是沿着DOM树向上传递的, 而通过stopPropagation()就能抑制这一环节;
preventDefault(): 很多元素有其自身的事件属性, 比如a标签的跳转, form元素的提交, 当我们想要取消其默认事件的发生时, 可以使用此函数来阻止其发生;



总的来说, 这一章内容其实很丰富, 但是其内容多数都是建立在之前的基本内容之上的. 着重需要知道的就是各种不同的事件, 其支持的元素, 类型以及触发的方式即可. 此类用法主要还是多用多练, 可以试试不同的event都包含那些属性~哈哈
Chapter 18 - Scripted HTTP
XMLHttpRequest:
Ajax: 由js端发起, 通过http请求和服务端交互;
Comet: 由服务端发起, js如果需要反应则使用Ajax回应, 通常由EventSource对象处理;
标准流程:new XMLHttpRequest()=&amp;gt;open(&amp;#39;type of request&amp;#39;, url,[],[username],[userpassword])=&amp;gt;setRequestHeader()=&amp;gt;send([content_body])&amp;lt;=onreadystatechange&amp;lt;=customized handler
通常GET类型的请求我们会通过encodeURIComponent来进行url拼接, 直接在url中体现, send()的时候就不用传值了;
POST类型的请求通常以json格式传递, 我们需要在send()中传入JSON.stringify()的数据, 当然如果是XML的POST, 那么直接传入对应的doc即可, 而像file这类的文件实体, 也是直接传入对应的实体即可;
起中Header部分我们只能自行设定部分, 而Content-Length,Date,Referer,User-Agent等等都由浏览器自动帮我们填上了;
readyState: UNSENT 0(open()还没执行); OPENED 1(open()已经执行);HEADERS_RECEIVED 2(headers已被接收),LOADING 3(正在接受返回),DONE 4(完毕).
XMLHttpRequest对象有一个onprogress的属性可以用来检测其执行进度, 它对应的属性值中包含了lengthComputable, loaded,total, 通过这三个就可以做一个简单的进度条跟踪请求的进度了;
如果是上传行为, 其onprogress属性存在于XMLHttpRequest_Object.upload.onprogress之中;
abort(): 用来取消请求;


EventSource:
标准流程: new EventSource(&amp;quot;url_to_server_file&amp;quot;) =&amp;gt; onmessage



Chapter 19 - The jQuery LibraryjQuery流行度的一大证据之一! 哈哈 我计划抽时间好好读一下jQuery的源码, 所以这里只是大概扫了一遍, 基本也都是应用层面的, 多数我差不多都使用过~哈哈
Chapter 20 - Client-Side Storage我在早先做chrome插件详见我的portfolio的时候, 写过一篇专门介绍web存储的文章. 恩, 当时写了不少patch系列, 哈哈, 改天写个脚本全部导出来转移过来.
恩
参考资料
JavaScript the Definitive Guide 6th edition 我现在就去写导入工具… 今天就到这里吧, 明天算是最后一篇就能完结本书啦~

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (8)</title><link>http://taoalpha.me/blog/2015/06/27/read-javascript-the-definitive-guide-8/</link><category>read</category><tag>js,reding notes</tag><pubDate>2015-06-27T12:00:00.000Z</pubDate><description>概述先说题外话: 昨天读到中途转去忙把以前的旧文章移植过来, 昨夜就已完成, 主要通过python解析了导出来的xml文本, 然后获取对应的时间信息和url信息组成符合jekyll规则的文件名, 再利用文本拼接出每个文件中固有的头和主体, 本来计划用html2text来把每个博文转为markdown, 不过后来源码有些问题, 对部分博文识别不好, 我也没时间细改, 所以就干脆拼接了html到主体中去.
主要导入了当初写的Patch系列和针对UX写的翻译系列. 分别归类到了Tech和DandP目录下. 有兴趣的可查看之~
今天来继续完结JavaScript: the Definitive Guide一书.
阅读笔记Chapter 20 - Client-side Storage
application cache:
为了丰富web app的功能, 或者说让web app更加的像native app, 就有了application cache这个机制, 从而让离线对于web app来说成为了可能;
application cache存储所有的静态格式, 包含html,css,javascript,images等等, 所有和web运行相关的资源文件;
application cache不作为常规cache而被轻易清理掉, 它会一直保持直到被要求删除或者用户手动删除;
Manifest: 为了能够让浏览器将网页存储到application cache里, 我们需要一个manifest文件, 并将之引入到html的head中&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;
此文件必须以CACHE MANIFEST为起始行;
列出所有需要加入application cache里的文件, 用相对路径, 相对与manifest文件而言;
#表示注释, 空行自动忽略;
此文件生效的前提是其MIME属性为text/cache-manifest, 即Content-Type这个header属性, 通常你需要自行在server中添加对应的规则;
如果网页由多个html组成, 则每个html都需要使用&amp;lt;html manifest=&amp;quot;myapp.appcache&amp;quot;&amp;gt;声明, 指向同一个appcache文件即可;
一旦缓存, 则所有资源文件都从缓存中获取, 未列出的资源不予加载;


Complex Manifest:
manifest支持复杂规则, 其支持多个section, 包含了NETWORK:,FALLBACK:这两类, 还要加上默认的CACHE:;
NETWORK:: 所有不予cache必须要从网络获取的资源, 可以设定路径, 支持通配符*;
FALLBACK:: 如其名, 优先从网络获取, 无法获取时从本地获取, 所以其每行指定两个url;


Update:
对于Application Cache而言, 其更新主要依照manifest, 浏览器会自动在情况允许时帮助你查看manifest是否更新, 如有, 则重新缓存所有文件;
注意: 浏览器不会自动帮你查看缓存的文件是否更新, 只查看manifest;
通常可以使用#加一行version的注释行来强制更新;
applicationCache.onupdateready: application cache提供了状态函数来指示其更新的进度, 你可以针对其加以操作, 还包含onchecking,onnoupdate,ondownloading,onprogress,oncached,onerror,onobsolete;
除了上述事件外, 还可以通过applicationCache.status来探测其状态: ApplicationCache.UNCACHED =&amp;gt; (0),ApplicationCache.IDLE =&amp;gt; (1),ApplicationCache.CHECKING =&amp;gt; (2),ApplicationCache.DOWNLOADING =&amp;gt; (3),ApplicationCache.UPDATEREADY =&amp;gt; (4),ApplicationCache.OBSOLETE =&amp;gt; (5);
swapCache(): 清楚旧或者废弃的缓存;


Delete:
很简单, 删除manifest, 去掉html中的引用即可;





12345678910111213CACHE MANIFEST# appVersion: 1CACHE:myapp.htmlmyapp.cssmyapp.jsFALLBACK:videos/ offline_help.htmlNETWORK:cgi/
这就算是一个最基本的manifest了.
Chapter 21 - Scripted Media and Graphics
Images:
onmouseover: 鼠标hover移入事件;
onmouseout: 鼠标hover移出事件;
new Image(): 通过创建一个Image对象, 可以赋予其src属性从而实现预加载的功能;


Audio
(new Audio()).canPlayType(type): 检测某种类型的文件是否能播放;
play(): 播放;
initialTime: 初始播放进度;
duration: 文件总时长;
currentTime: 当前播放进度;
muted: boolean, 是否静音;
volume: 音量值;
controls: boolean, 是否显示控件;
loop: boolean, 是否循环;
preload: 是否预加载以及预加载类型, metadata表示加载时长,帧速等, auto表示尽可能预加载更多的内容, none什么都不预加载;
autoplay: boolean, 是否自动播放;
playbackRate: 播放速度(1.0 == normal speed);
readyState: 加载情况(0,1,2,3,4)=&amp;gt;(尚未加载, 已加载但当前位置未加载, 当前位置已开始加载但是不足以开始播放(下一帧还没加载好),已加载且足够播放但是不足以播放到结尾,加载基本足够可以播放至结束)
networkState: 当前媒体文件使用网络的情况(0,1,2,3)=&amp;gt;(还没开始, 没开始但可能已经加载完或者预加载设置为none, 正在使用中, 无法找到资源);
error: 错误信息(1,2,3,4)=&amp;gt;(用户手动停止, 类型正确网络不通畅, encoding问题, 类型不支持)


Video



SVG: Scalable Vector Graphics

SVG算是一种xml格式的矢量图类型;
最新的主流浏览器基本都支持直接在img中嵌入svg, 部分老的浏览器依然只支持使用object标签: &amp;lt;object data=&amp;quot;sample.svg&amp;quot; type=&amp;quot;image/svg+xml&amp;quot; width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;/&amp;gt;
一定程度上SVG很像canvas, 不过它是通过XML的属性来实现的(比如通过&amp;lt;line x1=&amp;#39;50&amp;#39; y1=&amp;#39;5.000&amp;#39; x2=&amp;#39;50.00&amp;#39; y2=&amp;#39;10.00&amp;#39;/&amp;gt;来画线);


Canvas

作为HTML5引入的一个可谓是最重要的标签之一, canvas的存在极大的丰富了网络的表现形式;
canvas和js的关系紧密, 因为其绘画的实现方式就是通过js;
canvas.getContext(&amp;#39;2d&amp;#39;/&amp;#39;3d&amp;#39;): 通过它创建的对象就可以在画布上尽情挥洒了;
很多canvas的函数本质都是数学坐标的公式运算!



我会在后面阅读的HTML5 Canvas中更加详细的研究canvas的各种用法~ 敬请期待~
  
Chapter 22 - HTML5 APIs
Geolocation:
navigator.geolocation.getCurrentPosition()
navigator.geolocation.watchPosition(): 在用户位置变化时唤醒;
navigator.geolocation.clearWatch()
实例 codepen


History Management:
pushState()
replaceState()
实例 codepen


Cross-Origin Messaging:
postMessage()
onmessage()
实例 codepen


Web Workers:
通常来说, js的执行是单线程的, 不支持多线程, 利用Worker可以稍稍的模拟下多线程;
Worker开启的执行不能对window和Dom有任何的操作, 和主线程只能通过postMessage()来交互;
Worker对象的工作域是WorkerGlobalScope, 完全和主线程工作域不同;
Worker支持importScripts来引入其需要的js库;
实例 codepen - 因为跨域问题, 所以这里不能执行, 不过代码很简单, 很好理解, 有兴趣的可以download到本地测试


Typed Arrays and ArrayBuffers:
HTML5 的数组类型变的更加强大, 开始出现类似Int8Array(),Uint8Array()等多种新形式;
实例 codepen


Blobs:
算是存储的一种新形势, 浏览器通常可以存储Blobs到内存或者硬盘中, blobs本身更是可以代表任何数据, 以二进制的形式;
实例 codepen


The Filesystem API: 开启本地文件交互时代;
实例 codepen


Client-Side Databases: 主要为IndexedDB;
实例 codepen


Web Sockets: 一种相对http来说的新网络协议;
实例 codepen



上面针对HTML 5的各个API给出了一个对应的实例, 毕竟看着具体的代码和例子才有意思哈哈
参考资料
JavaScript the Definitive Guide 6th edition

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript 阅读阶梯清单</title><link>http://taoalpha.me/blog/2015/06/10/read-must-read-list-of-javascript/</link><category>read</category><tag>js</tag><pubDate>2015-06-10T09:00:00.000Z</pubDate><description>缘起今天翻完了Getting Good With JavaScript, 对于其精华浓缩的设计很欣赏, 很适合有一定无基础或者有一定基础但觉得野路子出身想要夯实一下的人读. 而在文末的Appendix A中作者提到的这个 Rey Bango’s Must-Read list of JavaScript 确实在是本书的又一大收获. 特转来分享~
基础入门所谓入门自然是以打牢基础为目的, 所以下列书都是以基础概念为主, 算是领路之书(考虑到国情需要, 我都尽可能替换为豆瓣链接了):

JavaScript: The Good Parts
Professional JavaScript for Web Developers (Wrox Programmer to Programmer)
ppk on JavaScript, 1/e
Beginning JavaScript with DOM Scripting and Ajax: From Novice to Professional (Beginning: from Novice to Professional) 
Eloquent JavaScript

初窥门径一旦你入了门, 就可以修炼中级秘术了~ 可以看到有两条中级秘术和入门级是一样的, 哈 这就和基础功打的够扎实, 基本拳脚也能当秘术使唤的~

Professional JavaScript for Web Developers (Wrox Programmer to Programmer) 
JavaScript: The Definitive Guide 
Eloquent JavaScript - Online 
DOM Scripting: Web Design with JavaScript and the Document Object Model

高手之路一旦确保自己有了一个牢靠的基础后, 我们就可以开启自己的高手之路了.

High Performance JavaScript (Build Faster Web Application Interfaces)
Object-Oriented JavaScript: Create scalable, reusable high-quality JavaScript applications and libraries
JavaScript Patterns
Pragmatic Guide to JavaScript
Pro JavaScript Techniques
JavaScript Rocks
Secrets of the JavaScript Ninja

造物主模式下面这些就是正儿八经的神级模式了… 当你已经把javascript里里外外摸得门清的时候, 就可以试试调整下面的了… 有一种去看汇编原理的感觉了… 开始研究底层源码了…

Standard ECMA-262 ECMAScript Language Specification 3rd edition (December 1999) – PDF File
Standard ECMA-262 ECMAScript Language Specification 5th edition (December 2009)

JS相关blog分享除了书籍之外, 作者还推荐了一些可以订阅查看的博客~ 我根据其目前存活情况, 主题变更情况简单筛选了下(多数都已经失效了)~

DailyJS - 强烈赞同, 很值得订阅!
JavaScript Weekly Newsletter
YUI Theatre
Rey Bango 作者本人哈哈

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript the Definitive Guide (1)</title><link>http://taoalpha.me/blog/2015/06/17/read-reading-javascript-the-definitive-guide-1/</link><category>read</category><tag>js,reading notes</tag><pubDate>2015-06-17T10:00:00.000Z</pubDate><description>概述“JavaScript: the definitive guide”可谓是JS入门必读数目之一了. 今天正好读到第7章, 做一简单总结. 前7章的内容都集中在JS中的基本知识上, 包含了:

数据类型: 最简单的primitive datatypes: string, number, boolean , 两个空值类型: null, undefined(通常认为空值类型属于promitive的一种),以及稍微复杂点的: object类型;
变量问题: 变量规则, 变量作用域问题;
基础表达式和操作符: 操作符的优先级问题, 多操作数和单操作数以及执行顺序等;
陈述语句: 包含了if/for/while/do/with/switch(case)/break/continue/return/var/identifiers/empty statement等等;
Object: json格式object以及常规的array类型对象的分别介绍以及自身结构属性, 异同点等;

心得break/continue 后接 label:  break/continue是通常用于for/white/do等循环语句中用以做状态判断的, 但本身其还有另一种用法, 就是通过后接标记语句的用法来是break或者continue能针对标记语句操作, 比如下面这个跳出多层嵌套的例子:
12345678910test:&amp;#123;  for(var i = 0; i&amp;lt; 10; i++)&amp;#123;    for(var j = 0; j&amp;lt; i*5; j++)&amp;#123;      console.log(j);      if(j==3) break test;    &amp;#125;  &amp;#125;&amp;#125;// continue test; 也是同样的用法
但需要注意的即使:

continue 语句(带有或不带标签引用)只能用在循环中;
break 语句(不带标签引用),只能用在循环或 switch 中;

with 语句在js中经常涉及到变量作用域的问题, 而with语句的存在就是可以将某个object放入到其子语句的作用域链中, 什么意思呢? 首先通常来说, 在函数内, 其作用域链由全局作用域(全局对象)和本地作用域(local对象)组成, 我们在引用变量的时候就是在作用域链上逐个查询. 而with的作用就是把某个object插入到作用域链中去, 从而能够直接访问其子元素:
1234567891011a = &amp;#123;&quot;nae&quot;:&quot;hhh&quot;,&quot;test&quot;:&quot;results&quot;&amp;#125;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;nae = &quot;sl&quot;with(a)&amp;#123;  console.log(nae)&amp;#125;// output: &quot;hhh&quot;// 证明with引入的作用域甚至还在global域之上
不过呢, 通常很少人会去用with的, 因为它过于吃力不讨好了, 其对性能的影响是没有什么优化空间的, 与其使用with, 不如直接定义全局变量或者变量的简写(有一种with的用法是为了省略书写冗长的变量名)更为方便了.
sort内嵌比较函数:sort()本身作为array类型内置的几个函数之一, 默认通常是按照字母表来排序的, 但是其本身也是支持自定义排序规则的, 只需要我们把规则传入即可:
12345678910// 以数字序列为例var a = [12,3,5,8]a.sort()// output: [12,8,5,3]a.sort(function(a,b)&amp;#123;return a - b;// 返回&amp;lt;0, 则a排在b前面, &amp;gt;0 则b在前面, =0则表示相等;&amp;#125;)// output: [3,5,8,12]
利用这一方法你就可以定制你的排序规则了, 甚至可以按照奇偶性排序都可以做到~ 比如 偶数在前: return a % 2-b % 2; 哈哈
concat,slice,splice这三个函数分别都是对array类型的元素进行母串增减获取子串而出现的, 其中有几点需要注意的:

concat()函数支持数字多参数分别传入, 也支持数组传入的形式, 效果都是一样的, 但是concat()不支持递归解套, 即如果你传入的是多层嵌套的数组, concat()只会解套一次; 此外, concat()的操作是不影响母串的;
slice和splice都可以用于获取子数组使用的, 其区别主要有两点, slice()接受的两个参数都代表的是index, 分别是起始次序到终止元素次序, 取子串时计算首位参数的元素,不计算第二位参数所代表的元素, 而splice则传入的两个参数分别是起始元素次序和要截取元素个数,即同样都是(1,2), 后者代表截取第二个元素起始共计两个元素的子串, 前者则只获取第二个元素; 此外, slice()返回子串而不修改原数组, splice()则会在返回子串的同时修改原数组(原数组为去除子串的结果);
splice()除了可以用获取子串外, 还能用于给母串添加元素. splice()可以接受超过2个参数, 从第三个参数起, 多出来的参数都是作为插入元素的, 执行的顺序则是删减完后当前位置插入, 即splice(2,2,1,3,4)表示的就是删掉第三个元素开始共计两个元素, 然后在同样的位置插入1,3,4三个元素, 同时, splice()也接受数组传入, 但是它不主动进行解套;

除了splice(), 上面的sort()的操作也是针对a数组进行的操作, 其结果也是针对a生效的, 即a的值是会被改变的;
pop,push,shift,unshift除了splice()之外, 我们通常用于直接操作母串增减的就是pop,push,shift,unshift四个了, 下面简单介绍下四者的区别:

pop, push分别代表对母串最后一个元素的进出栈操作, pop是弹出最后一个元素, push则是在最后一个元素的后面继续压入新元素, 同样也支持数组元素压入, 但是不自动解套;
shift, unshift和pop,push基本类似, 不同的地方在于操作的位置和后者相反, 是在栈头的位置, 即首位元素处; shift用于移出首位元素, unshift用于在首位增加元素, 接受数组, 也不自动解套, 同时多参数传入时, 作为整体一次性压入, 即unshift(2,3),压入后为[2,3,...].

这里比较独特的就是unshift多参数的压入问题了, 按我的预期其实是逐个元素压入, 这样顺序就是和传参相反, 但结果确实整体压入, 顺序与传参一致了~
谜题书中第七章介绍说在array中如果直接赋值的index是超限(&amp;gt;2^32-1), 负值或者对应表达式的结果是此类值时, 会自动转为string传入定义, 这就引发了一个问题: 一旦如此定义后, 此变量还是array吗?
我在console中简单的测试了下:
1234567891011121314151617181920var a = [1,2,3]// a.length == 3a[-1.2] = &quot;hehe&quot;a// output: [1,2,3]  where is a[-1.2] ?a[-1.2]// output: &quot;hehe&quot;  WTF???a.length// output: 3 ??console.log(a)// output: [1,2,3,-1.2:'hehe']console.log(a.length)// output: 3a instanceof Array// ouput: Truea[&quot;h&quot;] = &quot;hh&quot;a// output: [1,2,3]console.log(a)// output: [1,2,3,-1.2:&quot;hehe&quot;,h:&quot;hh&quot;]
问题: a依然还是一个Array(亦或者不是?), 但用json定义的方式赋值的那几个值还是有效的, 可获取的, 但是为什么直接print出来的时候没有这些值呢, 甚至长度都不包含定义的这几个指? 为什么console.log()可以打出来呢?
猜测解释: a最初被定义为array, 但是却被json方式传值, 存储到了其内存中, 但是调用a时依然按照array来打印, 所以会自动滤除掉不符合array的几个值(只会按照index来找值). 但是console.log()是打出来其存储内容, 所以就按照其内存存储形式打印出来了.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>JavaScript Coding Style</title><link>http://taoalpha.me/blog/2016/01/09/read-javascript-coding-style/</link><category>read</category><tag>JS,coding style</tag><pubDate>2016-01-10T01:49:12.000Z</pubDate><description>Why and What is Coding StyleCoding style is like the common styles and patterns that are used in your personal codebase or some organizations’ codebase, its purpose is making your code more readable and reusable through the entire developemnt, especially when you work in a team. Everyone can create their own coding style, there is no right or wrong among them, like you prefer 4 spaces than 2 spaces, you like to use camelCase represent the functions and variables,that’s totally fine. 
The benefit of using the same style is obvious, it can save you a lot of time reading and modifying others’ code or even your own code. There are some styles that are pretty popular and agreed by a lot of people and team, like Google Style Guide. Being modified and updated for so many years, I believe these styles would be a better choice to choose rather than create one by yourself.
Javascript Style GuideThere are several popular style guide for javascript, one is the part of the Google Style Guide series:  Google JavaScript Style Guide, another is created by airbnb:Airbnb JavaScript Style Guide, and also there is a Code Conventions for the JavaScript Programming Language created by the author of JavaScript: The Good Parts.
I read them all and summarize the core parts here.
Google JavaScript Style GuideHere I ignore all parts related to the Google Closure Compiler, if you are interested in, take a look at Closure Compiler.
Syntax &amp;amp; Basic Concept
var: never declare a variable without var to save you from global variables;
semicolons: always use semicolons, sometimes the closing brackets are not enough to signal the end of the statement: Javascript never ends a statement if the next token is an infix or bracket operator;
new: Never use wrapper objects for primitive types(like new Boolean(false), return an object!), but can use Boolean(0) to do casting, also for array and object, use literal syntax instead of new; 
prototye: Use prototype to attach methods to an object created via new, initialize other properties within constructor,Current JavaScript engines optimize based on the “shape” of an object, adding a property to an object (including overriding a value set on the prototype) changes the shape and can degrade performance., and NEVER modify prototype of builtins like Object and Array;
delete: Use set to null instead of delete to delete some properties, but if the number of properties of the object matters, use delete;
closure: Be careful to use closure since it might cause memory leak;
eval,with(){}: Just don’t use them;
for-in-loop: Only use it to iterate the key of object/hashmap;
quote: Use single quote &amp;#39;&amp;#39; for strings, use string concatenation if the string is too long;

Naming
CONSTANT_NAME: always use ALL_CAP_SNAKE_CASE represent the constant;
functionName,variableName,methodName: use camelCase represent the functions and variables, methods;
ClassName,EnumNamesLikeThis: use CamelCase represent class or enums;
filenameslikethis.js: use plain lowercase as the name of the files;
_private: private should be named with a trailing underscore;
opt_: Optional function arguments start with opt_;
global: try not to contaminate the global, can use a global object to store all variables you want to use as gloabl scope - prevent some conflicts between global and local;

Comments &amp;amp; JSDocJust remmeber that comments is written for someone who isn’t familiar with the code including youself after a long time!
Here is some resouces about the JSDoc
TipsSome Boolean Expressions1234567891011121314151617Boolean('0') == true'0' != true0 != null0 == []0 == falseBoolean(null) == falsenull != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean(&amp;#123;&amp;#125;) == true&amp;#123;&amp;#125; != true&amp;#123;&amp;#125; != false
Better For Loop1234var paragraphs = document.getElementsByTagName('p');for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) &amp;#123;  doSomething(paragraph);&amp;#125;
BE CONSISTENTAirbnb JavaScript Style GuideI will address some difference between this one and google’s.
Syntax &amp;amp; Basic Concept
const: Alwasy use const on references instead of var, ensure that you can not reassign your reference, Block-scoped;
let: If you must reassign references, use let instead of var, Block-scoped;
reserved words: don’t use reserved words as keys;
object shorthand: use object shorthand for method and value defined in an Object, and also put all shorthands at the beginning of the object declaration;

123456789101112131415161718// methodconst atom = &amp;#123;  value: 1,  addValue(value) &amp;#123;    return atom.value + value;  &amp;#125;,&amp;#125;;// value, if value and key are the same// put all shorthands at the beginning// only quote properties that are invalid identifiersconst obj = &amp;#123;  lukeSkywalker,  foo: 3,  bar: 4,  'data-blah': 5,&amp;#125;;

spreads: Use ... to copy arrays: const itemsCopy = [...items]; 
Array.from(): Use Array.from() convert an array-like object to an array;
destructuring: Use object and array destructuring when accessing and using multiple properties of an object;

123456789101112131415161718192021222324// goodfunction getFullName(user) &amp;#123;  const &amp;#123; firstName, lastName &amp;#125; = user;  return `$&amp;#123;firstName&amp;#125; $&amp;#123;lastName&amp;#125;`;&amp;#125;// bestfunction getFullName(&amp;#123; firstName, lastName &amp;#125;) &amp;#123;  return `$&amp;#123;firstName&amp;#125; $&amp;#123;lastName&amp;#125;`;&amp;#125;// array destructuringconst arr = [1, 2, 3, 4];const [first, second] = arr;// Prefer object destructuring for multiple return values to array destructuring// goodfunction processInput(input) &amp;#123;  // then a miracle occurs  return &amp;#123; left, right, top, bottom &amp;#125;;&amp;#125;// the caller selects only the data they needconst &amp;#123; left, right &amp;#125; = processInput(input);

template strings: When programmatically building up strings, use template strings instead of concatenation;
functions declarations: Use function declarations instead of function expressions, when you must use function expressions (as when passing an anonymous function), use arrow function notation;

1234567891011121314151617181920212223242526272829// badconst foo = function () &amp;#123;&amp;#125;;// goodfunction foo() &amp;#123;&amp;#125;// use arrow functions as function expressions// immediately-invoked function expression (IIFE)(() =&amp;gt; &amp;#123;  console.log('Welcome to the Internet. Please follow me.');&amp;#125;)();// No function declarations should be in a block// badif (currentUser) &amp;#123;  function test() &amp;#123;    console.log('Nope.');  &amp;#125;&amp;#125;// goodlet test;if (currentUser) &amp;#123;  test = () =&amp;gt; &amp;#123;    console.log('Yup.');  &amp;#125;;&amp;#125;

arguments: Don’t use it, use ...args instead;

12345678910function concatenateAll(...args) &amp;#123;  return args.join('');&amp;#125;```  - `default value`: Use default parameter syntax rather than mutating function arguments, and always put default parameters last;``` javascriptfunction handleThings(name, opts = &amp;#123;&amp;#125;) &amp;#123;  // ...&amp;#125;

spacing: put space between function name and the brackets and curly brackets;
parameter: Never mutate parameters, Never reassign parameters;

123456789// badfunction f1(obj) &amp;#123;  obj.key = 1;&amp;#125;;// goodfunction f2(obj) &amp;#123;  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;&amp;#125;;

arrow functions: 
If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement;
and if the expression spans over multiple lines, wrap it in parentheses;
If your function takes a single argument and doesn’t use braces, omit the parentheses;



12345678910111213141516171819// good[1, 2, 3].map(number =&amp;gt; `A string containing the $&amp;#123;number&amp;#125;.`);// bad[1, 2, 3].map(number =&amp;gt; &amp;#123;  const nextNumber = number + 1;  `A string containing the $&amp;#123;nextNumber&amp;#125;.`;&amp;#125;);// good[1, 2, 3].map( (number) =&amp;gt; &amp;#123;  const nextNumber = number + 1;  return `A string containing the $&amp;#123;nextNumber&amp;#125;.`;&amp;#125;);[1, 2, 3].map(number =&amp;gt; (  `As time went by, the string containing the $&amp;#123;number&amp;#125; became much ` +  'longer. So we needed to break it over multiple lines.'));

class: Always use class. Avoid manipulating prototype directly;
extends: Use extends for inheritance;
methods: Methods can return this to help with method chaining;

123456// goodclass PeekableQueue extends Queue &amp;#123;  peek() &amp;#123;    return this._queue[0];  &amp;#125;&amp;#125;

import: Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system, which means don’t use require etc;
Do not use wildcard imports;
And do not export directly from an import;



1234567891011121314// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide';// bad// filename es6.jsexport &amp;#123; es6 as default &amp;#125; from './airbnbStyleGuide';// good// filename es6.jsimport &amp;#123; es6 &amp;#125; from './AirbnbStyleGuide';export default es6;

iterators and generators:
Don’t use iterators. Prefer JavaScript’s higher-order functions like map() and reduce() instead of loops like for-of;
Don’t use generators for now.



123456789101112131415161718const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &amp;#123;  sum += num;&amp;#125;sum === 15;// goodlet sum = 0;numbers.forEach((num) =&amp;gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&amp;gt; total + num, 0);sum === 15;

properties:

Use dot notation when accessing properties;
Use subscript notation [] when accessing properties with a variable;


variables:

Always use const to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that;
Use one const declaration per variable;
Group all your consts and then group all your lets;
Assign variables where you need them, but place them in a reasonable place;


hoisting:

var declarations get hoisted to the top of their scope, their assignment does not; 
const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ);
It’s important to know why typeof is no longer safe;
Anonymous function expressions hoist their variable name, but not the function assignment;
Named function expressions hoist the variable name, not the function name or the function body;
Function declarations hoist their name and the function body;



1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// using const and letfunction example() &amp;#123;  console.log(declaredButNotAssigned); // =&amp;gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned); // =&amp;gt; throws a ReferenceError  const declaredButNotAssigned = true;&amp;#125;// assignment will not be hoistedfunction example() &amp;#123;  console.log(anonymous); // =&amp;gt; undefined  anonymous(); // =&amp;gt; TypeError anonymous is not a function  var anonymous = function () &amp;#123;    console.log('anonymous function expression');  &amp;#125;;&amp;#125;function example() &amp;#123;  console.log(named); // =&amp;gt; undefined  named(); // =&amp;gt; TypeError named is not a function  superPower(); // =&amp;gt; ReferenceError superPower is not defined  var named = function superPower() &amp;#123;    console.log('Flying');  &amp;#125;;&amp;#125;// the same is true when the function name// is the same as the variable name.function example() &amp;#123;  console.log(named); // =&amp;gt; undefined  named(); // =&amp;gt; TypeError named is not a function  var named = function named() &amp;#123;    console.log('named');  &amp;#125;&amp;#125;// BUT! Function declarations hoist their name and the function body.function example() &amp;#123;  superPower(); // =&amp;gt; Flying  function superPower() &amp;#123;    console.log('Flying');  &amp;#125;&amp;#125;

Comparison Operators &amp;amp; Equality:
Use === and !== over == and !=;
Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules:
Objects evaluate to true
Undefined evaluates to false
Null evaluates to false
Booleans evaluate to the value of the boolean
Numbers evaluate to false if +0, -0, or NaN, otherwise true
Strings evaluate to false if an empty string ‘’, otherwise true





Comments
Use /** ... */ for multi-line comments. Include a description, specify types and values for all parameters and return values;
Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block;
Prefixing your comments with FIXME or TODO helps other developers quickly understand if you’re pointing out a problem that needs to be revisited, or if you’re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME – need to figure this out or TODO – need to implement;

12345678910111213/** * make() returns a new element * based on the passed in tag name * * @param &amp;#123;String&amp;#125; tag * @return &amp;#123;Element&amp;#125; element */function make(tag) &amp;#123;  // ...stuff...  return element;&amp;#125;
Spaces
Use soft tabs set to 2 spaces;
Place 1 space before the leading brace;
Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations;
Set off operators with spaces;
End files with a single newline character;
Use indentation when making long method chains. Use a leading dot, which emphasizes that the line is a method call, not a new statement;
Leave a blank line after blocks and before the next statement;
Do not pad your blocks with blank lines;
Do not add spaces inside parentheses;
Do not add spaces inside brackets;
Add spaces inside curly braces;
Avoid having lines of code that are longer than 100 characters (including whitespace);

Commas and Semicolons
Leading commas: NOPE;
Additional trailing comma: Yup;
Always use semicolons;

12345// good (guards against the function becoming an argument when two files with IIFEs are concatenated);(() =&amp;gt; &amp;#123;  const name = 'Skywalker';  return name;&amp;#125;)();
Type Casting &amp;amp; Coercion
Perform type coercion at the beginning of the statement, use String,Number etc instead of other tricky methods;
If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing;
Be careful when using bitshift operations. Numbers are represented as 64-bit values, but Bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits;

12345678910// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &amp;gt;&amp;gt; 0;// be careful2147483649 &amp;gt;&amp;gt; 0 //=&amp;gt; -2147483647
Naming
Avoid single letter names. Be descriptive with your naming;
Use camelCase when naming objects, functions, and instances;
Use PascalCase when naming constructors or classes;
Use a leading underscore _ when naming private properties;
Don’t save references to this. Use arrow functions or Function#bind;
If your file exports a single class, your filename should be exactly the name of the class;
Use camelCase when you export-default a function. Your filename should be identical to your function’s name;
Use PascalCase when you export a singleton / function library / bare object;

1234567891011121314// badfunction foo() &amp;#123;  const that = this;  return function () &amp;#123;    console.log(that);  &amp;#125;;&amp;#125;// goodfunction foo() &amp;#123;  return () =&amp;gt; &amp;#123;    console.log(this);  &amp;#125;;&amp;#125;
Accessors
Accessor functions for properties are not required;
If you do make accessor functions use getVal() and setVal(‘hello’);
If the property is a boolean, use isVal() or hasVal();
It’s okay to create get() and set() functions, but be consistent;

jQuery
Prefix jQuery object variables with a $;
Cache jQuery lookups;
For DOM queries use Cascading $(&amp;#39;.sidebar ul&amp;#39;) or parent &amp;gt; child $(&amp;#39;.sidebar &amp;gt; ul&amp;#39;);
Use find with scoped jQuery object queries;

1234567891011// goodfunction setSidebar() &amp;#123;  const $sidebar = $('.sidebar');  $sidebar.hide();  // ...stuff...  $sidebar.css(&amp;#123;    'background-color': 'pink'  &amp;#125;);&amp;#125;
TestingYou should write testing!!!
Code Conventions for the JavaScript Programming LanguageAll coved by two styles I list above.
SummaryCompared to google’s old style guide, airbnb’s style guide has much more valuable new ES6 styles, if you are an active ES6 users, I strongly suggest you use airbnb’s style !!!
Even you are a solo worker, you should use some common styles, it is a good habit and you should have.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Why Users Aren’t Clicking Your Home Page Carousel?</title><link>http://taoalpha.me/blog/2014/05/03/read-yi-why-users-arent-clicking-your-home-page-carousel/</link><category>read</category><tag>Carousel,HCIBib,UX,UXmovement,关于HCI,翻译文章,译系列</tag><pubDate>2014-05-03T04:00:00.000Z</pubDate><description>首先介绍下什么是carousel: 标准词典翻译为”旋转木马”, 用在网络中, 尤其是网页设计的语境之下, 就是指代的很多网站中使用的多图切换模块, 通常由多张图组成, 但是一次只会显示一张, 图片右下角或者正下方常常有切换指引的远点或者缩略图, 图片左右则有前后箭头, 如此切换的时候会像旋转木马一样一张一张的出现在用户眼前(当然不限于图片, 有的也会用文字作为每一个木马).
=========正文=========网站研究发现在300w的首页中, 只有1%的用户浏览会点击页面上的carousel部分呢. 为什么占据了首页如此大面积的, 而且是很具有视觉优势的元素获得的点击是如此之少呢? 原因可能比较出乎意料, 因为多数carousel都做的很烂…
绝大多数的carousel都包含多张切片, 当用户点击箭头切换时进行旋转展现. 通常第一张会获得多数的点击, 随后的点击比例就会急剧下降. 造成carousel如此的低的点击率的原因其实不是因为carousel本身的这种切换模式, 而是因为carousel的导航实在是太烂了….
carousel中的导航键头通常是没有点击欲望的. 为什们? 因为箭头通常无法表示出用户点击后会获得的信息, 无法给与用户期望. 所以用户通常都会忽视箭头, 把他们自己的注意力放在别的信息之上. 一个箭头只能说明这里还有更多的切片, 这完全不是让用户点击的理由. 所以, 他们很难看到carousel后面的切片, 又怎么产生点击呢? 不仅如此, 用户还常常因为箭头太小太靠近边缘而忽视它. 以这样的设计, 其他的切片能获得高点击才怪呢…
实际上, carousel所需要的只是一个清晰的, 可见的标签导航即可. 标签本身说明了包含的信息, 有意义的描述, 告诉了用户他们想要的. 这会刺激用户去点击, 因为每个标签都告诉了他们点击后能获得什么. 用户就会更有可能点击那些吸引他们的信息. 导航标签本身也应该有足够的宽高并被置于一个更加可见的位置, 而不是像箭头一样很难发现. 重要的不仅是容易看到, 用户还要同时知道它代表了什么.
绝大多数人们可能只会看一下这份网站研究报告的结论, 然后觉得所有的carousel都是非常不利于体验的, 他们以后都不应该使用carousel了. 但实际上, 多数carousel如此的糟糕是因为他们没有很好的导航, 都只是用一个小小的箭头来引导. 箭头本身不能承担任何信息, 但是文本标签可以. 如果你希望更多的用户点击你的carousel, 那么, 就是用标签导航把. 把标签写的清楚, 有意义, 你就会有更多的用户点击你的carousel了.
Links:
UX Movement: Why Users Aren’t Clicking Your Home Page Carousel

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>7条规则助你创造优质UI-上篇</title><link>http://taoalpha.me/blog/2014/11/26/read-7-rules-to-help-you-create-high-quality-ui-part/</link><category>read</category><tag>Design,UI,关于HCI,翻译文章,设计,译系列</tag><pubDate>2014-11-26T05:00:00.000Z</pubDate><description>本文来自Medium, 分为上下两篇, 讲述了在制作UI的时候的7条实用规则, 表示个人喜欢最后一条”steal like an artist”…刚看完”the art of steal”…哈哈

不说废话.. 本文作者特别强调了下文章的适用对象主要有两种:

想要尝试自己设计UI的开发者们想要自己的作品集看起来更优秀或者是想要让自己的UI套装有更好的用户体验, 能卖个好价钱的UX设计师们

同时作者还特别说明了一下,  针对那些技术学校毕业的, 已经是UI设计师或者向着UI设计师前进中的孩纸们, 就可能会觉得本文比较枯燥, 乏味, 甚至是错误了. 作者针对此的建议也是: 请不要犹豫关闭本tab, 拜拜不送.

那么如果你还是本文的受众, 请继续阅读:

作者背景: 作者是一个UX设计师, 没有什么UI技能. 他很喜欢设计UX, 但是没做多久就发现把UI设计好的好处多多啊:

我的作品集如果很糟糕的话, 就会反映出我自己在工作和思维过程中可能同样很糟糕我的那些UX咨询客户们宁愿花钱请一个技艺娴熟的UI设计师做设计而不是向我这样给出一堆手绘草图我会不会突发奇想的去加入一个创业公司呢? 那么最好有这个技能

一般来说UI设计不行的人都会这么给自己找借口: 我的专长是工程(交互等), 我对美学这东西一窍不通. 所以我做出来的东西看起来很丑也是一件很正常的事情.

接着作者介绍了一下自己如何向着美学前进的, 无外乎就是Google, Dribbble, Pinterest到处搜然后从模仿研究伟大作品开始~ 中间作者给出了一个很不错的建议:

  致广大的呆子们: 如果我现在能够说自己在UI上有所成绩, 那么一切都是因为我研究过一些东西-而不是我对于美学和平衡有什么直觉性的天赋.

哈哈, 这也是为什么我喜欢这篇文章的原因: 文章并没有什么深奥的理论和赤裸裸的美感炫耀, 而是非常简单的应用技巧, 让你从一个美盲到一个能够做出不错UI的人.

下面说正题: 规则.

Light comes from the sky (光从上面来)Black and white first (黑白优先)Double your whitespace(留白要多)Learn the methods of overlaying text on images (学习各种在图片上加文字的方法)Make text pop— and un-pop (合理的让文本突出或者不突出)Only use good fonts (只用好看的字体)Steal like an artist (像艺术家一样懂得模仿)

#1  Light comes from the sky

阴影在设计上应用广泛, 而且价值无量, 因为它可以在无形中告诉我们所看到的界面元素是什么. 光产生阴影, 而光从上方向下方照射则是一个非常常规的事情, 以至于一旦我们改变这个规则, 就会显得很诡异, 比如下面这张图片:



正常的上方投射光会使得元素的顶部为亮层, 阴影则出现在下层, 从而形成一种立体感. 这让我们即便是针对二维的屏幕也能产生三维的感知.



上图是作者非常喜欢的一个点击示意图. 单从光方面分析以下里面体现的细节:

按前的按钮底部有明显的暗边 – 因为光没有找到.按前的按钮上部分要比下面略微亮一些 – 这是在模拟一种轻微的弧状凸面, 上部因为反光会更加明亮按前的按钮边缘有非常轻微的阴影 – 在放大的图层中看到的比较明显按下的按钮, 虽然下部依然没有上部亮, 但是整体都变暗了 – 因为按下后, 感觉按钮就被压到平面里面, 阳光就不容易照到了(至于你说我们实际生活中看到的按下的按钮显得更暗, 那是因为我们的手挡住光线所致..)

就这么个小按钮就能够反映出很多的细节. 



上面是iOS 6下的一个实例, 虽然可能有些过时了, 不过单纯从说明问题的角度来说还是可以的.

里面涉及的光照应用就不多说了, 直接看图就能看出些了~



还有向上面这种, 通过明暗来表现一中凹陷堎的效果.

概括来说:

通常为凹进去的元素有:

文本输入域按下的按钮滑轨未选中的单选按钮复选框

通常为凸出的元素有:

未按下的按钮滑块下拉触发按钮卡片单选按钮中的按钮部分弹出框

如果你仔细观察以下, 你就会发现它的应用无处不在.

那么, 对于扁平化设计, 又该怎么说呢?



iOS 7开始, 苹果引入了扁平化设计, 去掉了所有的阴影啊等等拟物化的细节.  就此而言, 作者并不欣赏, 作者虽然也很喜欢简单明了, 但是他认为这种扁平化设计绝非能够盛行不衰的设计风格, 作者认为还是模拟现实的拟物化更加自然.

不过鉴于如今扁平化风行, 所以作者比较推荐半扁平化设计. 其实是在扁平的基础上加入了层级关系, 保留了阴影形成的立体感.



我觉得吧. 这块没什么对错, 扁平化设计有很多好处毋庸置疑, 拟物化设计的自然美感和各种细节都让人着迷. 但是拟物化本身的特点是来源于让你们更自然的使用科技产品, 把生活中的东西搬到电子中去, 但是, 在产品适应人的过程中, 人也在适应着产品, 所以apple盛行的今天, 其形成了扁平化的设计风格, 也是基于用户对于拟物的需求已不那么必要, 很多拟物的元素甚至都消失在历史长河中去了.  光线也不在局限在日光上了, 如今不夜已经不再是个夸张了. 年轻人, 尤其是年轻的消费者喜欢新颖, 喜欢未来感十足的产品, 而扁平化带来的就是这样的感觉.  当然, 也不是只有扁平化能带来这种未来感, 像我, 就更喜欢material design的层级立体平面. anyway, 人类适应了科技, 自然不再需要更多的现实参照物来去运用科技了.

哈哈, 刚写完上面的话就看到作者谈及了material design. MD是一种统一的视觉表现, 核心就是去模拟真实的物理世界(注意! 这里是物理世界哦, 不是现实世界, 所以科技感有了, 立体感也有了).





可以感觉出作者对material design还是比较欣赏的. 作者也承认拟物化(即模仿现实世界)有点过时了, 但是作者相比于纯粹的扁平化, 更欣赏半扁平的那种设计. 这也是纯粹的扁平哦~ 哈哈

#2: Black and White First

在设计初完全使用灰阶作图而不加任何颜色可以让设计更加纯粹, 且暂时不用考虑最复杂的视觉设计元素–颜色, 而聚焦在布局上.

如今到处都在喊”移动居先”, 设计师们也都在响应式设计的路上越走越远… 这都要求你更多的关注页面的布局, 在移动端是什么样, 在大屏上又是怎样.

这种限制其实很好, 因为它有助于帮助我们思考. 我们需要从小屏开始, 这通常比较困难, 但是想清楚了小屏的用法, 那么再去应用到大屏上就会容易很多了.

而 Black and White First则是另一个类似的限制. 如何让一个app显得很高端大气实用, 但是又不实用任何的颜色是一个困难的问题, 在解决了这个之后, 再去以颜色辅助.



使用灰阶可以免除很多颜色的干扰. 毕竟颜色加多了很容易毁掉你的设计的.







灰阶设计完事了, 就要进入第二步: 上色了.

最简单的上色方法是只用单色.





只用一种色的好处是能够非常明显的强化你的亮色元素.

如果一种色不够, 那么你就可以尝试2种色或者多种色但是用同样的饱和度(通过调节同一个颜色的饱和度和亮度, 就可以得到一系列的颜色, 有强有弱, 轻重点和内容跟你一区分.)



#3:  Double your whitespace

留白是门艺术! 真的, 在不加任何样式的html上你就能看到样式给html带来的巨大变化!!!… 毫无美感… 我们需要留白来帮助你更好的布局自己的元素, 不是满满的就都是爱了…



上图是一个music player的设计示意图. 里面就有很多的留白示例, 可以重点关注下左侧菜单栏和顶部的导航栏, 搜索框. 都是大量留白, 让人赏心悦目.

那么, 怎么留白呢?

你可以按照下述的步骤试试看:

在行与行之间加上些空白;在元素与元素之间加上空白;在一组元素与另一组元素之间加上空白;看看哪种有效果, 就用之;

下一篇介绍剩下的四种~
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>简述一次网页浏览行为的过程</title><link>http://taoalpha.me/blog/2014/11/26/read-brief-web-browsing-behavior/</link><category>read</category><tag>request,翻译文章,译系列</tag><pubDate>2014-11-26T12:00:00.000Z</pubDate><description>原文其实是讲述我们应该如何为性能做更好的考虑, 其中简单介绍了一个request从发出到结果展现的整个过程, 尤其是其在移动网络和常规网络的区别非常有趣, 所以特定分享以下.

我们的上网行为, 简单来说就是一个浏览器和一个网络服务器之间的数据交换.  而从我们点了确认/提交/Go之后, 到页面开始进行加载, 这个过程基本就是一个请求啦. 拆解一下呢, 我们初始的请求会带着一些参数从浏览器出发发送到一个DNS服务器上去, 它会把URL解析为一个IP地址来找到我们这个URL指向的主机, 然后又DNS向主机发送请求, 获取指定的主机内容, 再返回给我们的浏览器.



整个过程就是如此了. 这基本是我们常规的设备通过wifi或者有限网络浏览网络的全过程了. 那么对于一个连接到移动网络的设备而言, 会多出一步了: 浏览器首先会把请求发送给信号基站, 由信号基站转发给DNS, 然后开始正常的网络请求循环.  而这个多余的过程, 即便是以3G速度而言, 也需要一定的时间, 相对于网络中以百万分之一毫秒来计算, 这个时间绝对不短. 大致算下来, 移动设备联网过程会比Wifi要慢2s之多.

2s看起来比较短, 但实际上对于连300ms的延迟都能感觉到的用户而言, 2s绝对是个灾难性的影响了. 这也是为什么移动网一直比不上wifi的原因了. 

不过幸运的是, LTE和4G的慢慢普及, 相信这种差别一定会降低很多, 以后的访问速度一定会快很多的.

至于说请求返回浏览器后到页面真正完整展示出来的过程, 其实是浏览器的渲染过程了, 这个很多时候取决于浏览器本身的渲染引擎和机制了. 通常来说, 除了本身的HTML外, 主要有CSS和JS两个资源需要加载, 通常来说, css会优先加载,  在html文档渲染前就会完成加载, 从而不影响HTML的视觉展现, 而JS, 则通常可以后加载. 不过JS和CSS的加载都会影响页面的展示, 通常来说, 两者加载和执行的过程中, 页面是不会渲染展示的, 这一过程称之为Blocking.  当然这个过程你是可以中断的,尤其是中断js的加载很多时候不会影响到页面的视觉效果(前提是js不涉及DOM操作), 这也是为什么有时候你的loading菊花转着转着你叉掉了页面还是会加载出来的原因.



不过, 图片元素通常是不会被blocking的, 浏览器不会等待一个图片元素加载完成后才进行页面渲染~ 所以经常出现页面加载后, 图片没显示完整的现象.

这种blocking的机制主要是为了防止裸露的HTML带给用户的糟糕体验, 毕竟如果css在html之后加载, 那么无样式的html会先渲染展示, 然后样式加载完在reflow, 感觉就很痛苦了… 这种闪一下的现象通常叫做: Flash of unstyled content(FOUC). 所以现在浏览器通常都采取blocking的方式来保证用户看到的页面的视觉效果. 而blocking对js而言主要是为了应对document.write这个函数, 其实根本来说也是为了一次性让用户看到比较完整, 好看的内容. 当然, 现在其实很多人都不推荐大家使用document.write这个函数, 毕竟js经常会导致更多的blocking时间, 但是毕竟有人再用… 而且浏览器又没办法提前判断js中用没用这个函数…

恩, 基本上, 从一个请求发出到页面加载的过程就是这样了~ 如果想要提高性能, 自然也就从这里面涉及的各个方面着手喽~
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>What does it mean to be simple?(译)</title><link>http://taoalpha.me/blog/2013/06/08/read-what-does-it-mean-to-be-simple-translated/</link><category>read</category><tag>HCI,HCIBib,UX,产品学习,翻译,翻译文章</tag><pubDate>2013-06-08T13:00:00.000Z</pubDate><description>什么才意味着真正的简单呢?(What does it mean to be simple?)所有的设计师都在说”简洁性”是多么多么的重要,那么,究竟什么才真正意味着简单呢?多数情况下我我们认为简单意味着更少,通过去掉一些事物来达到简单的目的. 我们以为通过把内容放置在明显位置,可以帮助用户更好的集中注意力,或者采用使用符号列表而不是段落的形式,会有更多的人愿意去阅读;亦或者通过将文本内容缩略到一半可以让内容更清晰. 但是简单并不意味着”更少”.一个更准确的定义应该是”刚刚好”.
唔,我可能过于简单了…
在一些时候,设计需要更多的东西来实现简单.所以,一个更好的定义应该是:”刚刚好可以满足理解以及实现我们的目标”.不采用隐藏或者去除某些东西,我们采用如下的方法让我们的设计变得更加有意义的简单:
    只有一个核心观点(不要多个观点或者一个不完全的观点)    随时间而逐渐增强清晰性(不要被不恰当的细节淹没)    一致性(避免使用不必要的特殊界面和信息)
只有一个核心观点注意力和兴趣是你试图让某人做任何事的首要因素.最好的吸引注意力和建立兴趣的方式是只展现一个核心的观点,全面的阐述这一观点.这将允许用户来做一个二选一的选项:”我感兴趣啊?”.
在介绍某个特性的时候,应当让用户能立刻”看到”自己的操作会产生的任何后果,这将帮助用户更好的理清内容同时对于下一步要做什么有更好的掌控. 只有一个核心目标的原则是贯穿始终的,从全局到每个细小的属性.“除了’Send Message’,没有更好的词语可以描述清楚’Send Message’”.—Des Treynor这是一个非常典型的例子,它的结果非常清楚(就是Send Message).这里其他的版本可能是”Go”或者”Submit Now”,或者仅仅是”Send”.但这些都没有”Send Message”那样清楚,只用两个词就可以让用户非常清楚的理解其含义,从而更轻松的做出选择. 随着转移到更加复杂的一些属性,让其概念清晰易于选择的困难程度呈指数级增长,但是我们的目标应该是一致的:利用一个核心观点指引用户合理的设定他们的预期.如果我们没能成功的做到这一点,那么感知起来的复杂度就会有所增加.
只有一个核心观点包括以下内容:
    二选一的:足够简单只有两个选择…允许人们方便的评估他们同意与否    用朴实的语言来陈述:尽可能的清晰以及明显的表述问题或者选择的机会    不断的重复:每一个界面都应该在适当的位置不断重复恰当的问题或选择的机会.    让预期变得明显:每一个问题或者选择机会的结果都应该可预计;
随时间提升其清晰性在获得人们的兴趣之后,下一步就需要让他们投入时间和精力了.即便当你的用户发现你的应用非常有趣,也依然有很多”摩擦”可能会出现.如果他们被这些阻拦了,那么转化率依然很低.你必须要清晰的没有任何困扰的展示给他们他们可以实现他们的目标.“网络出版:写的太少,无法清楚地表达意思.写的太多,会因为太厚而无法浏览从而有很多内容被跳过.”–Ryan Singer就好比很多对话可以随着时间的进行而变得更清楚更准确,正确的时间出现的正确的细节将会增加最终获得满意结局的机会.去除相关的但是不恰当的细节,将可以帮助用户不断前进而减少被分散的机会.谨记,每一个无法获得有意义的结果的时间和精力的投资都会增加感知的复杂性.
随时间提升清晰性可以采用如下方法:
    清楚的开始和结束–确保界面中如何清楚的做某一件事实非常清楚地.    逐步解密–要做到恰到好处:把用户的焦点只放在那些有主意他们理解当前任务的细节上.    明显的路径–总是提供一个清晰的路径到下一步或者下一层次的细节.
一致性一个新用户和一个老用户是完全不同的两种用户.如果你想要让人们一直停留这里,那么你需要帮助他们,让他们感觉自己掌握了这一应用的每一部分,而且完全没有必要去担心下一个是什么. 每一个特性都需要足够的便捷而让用户感到愉悦以及他们的时间和精力得到了最好的利用.“无论是风中舞动的旗子,空的和挤满人的站台的区别,亦或者是那些暗示着可行的路径的脚印,我们一直寻找着世界上那些明显的标志来提供指引.”–Don Norman你给予他人友好的表情可以带给他们自信,而且可以收获笑容.帮助人们看到那些他们之前看到的内容,基于他们已经知道的事情获得结论.当你确实有一个复杂的问题时,你的界面比较复杂并没有错,但是毫无理由的把用户扔在一个陌生的地方,而且不给于任何指引或者地图,那就是不友好了.
通过以下方法保持一致性:
    巩固惯例–使用相似的处理过程,使用相似的方法.    建立模式–把相似的事物放在相似的地方,这样用户就可以根据直觉来行动了.    偶尔破坏规则–知道什么时候一个界面需要独一无二,实际上可能比你想象中更少一些.
当多就是少的时候目前盛行的观念认为简单就是少…删减再删减.但是简单真的应该针对理解和清晰的目标…我们能做出让用户立刻就明白正在做什么,同时可以非常明确的了解下一步将做什么的设计吗?为了实践实现简单,我们可以坚持只有一个核心观点,随时间提升其清晰性,同时利用一致性帮助用户更高效的使用. 在这种情况下,更多也可能就是更少…通过在适当的时候添加适当的细节,整个处理过程将会变得更加简单易用.简单性促使我们认为它应该是更少的,但是其实它真的应该是”刚刚好”. Edit By MaHua
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>谈谈颜色在市场方面的应用</title><link>http://taoalpha.me/blog/2014/11/27/read-talk-about-application-of-colors-in-the-market/</link><category>read</category><tag>关于HCI,翻译文章,设计,译系列,颜色</tag><pubDate>2014-11-27T08:00:00.000Z</pubDate><description>本文讲述了关于颜色的不同所能带来的不同影响, 相信很多人都认可”颜色和人的感受有着非常紧密的关系”这个事实. 那么颜色能产生多大的影响呢? 又是和产生的影响的对应关系如何呢?先说个趣闻: facebook为什么是蓝色为主色调呢? 其实根据New Yorker, 原因很简单. 就是因为Mark Zuckerberg是一个红绿色盲. 这就导致蓝色是Mark所能识别的最好的色调了. 用Mark自己的话说就是:

  蓝色对我而言是最丰富的了, 我可以看到各种的蓝色.

没什么科学价值? 可能就facebook这个个例来说确实没啥特别的价值, 但是实际上现实生活中还有很多关于颜色是如何影响消费者们的消费决策的实例的. 毕竟视觉可谓是多数人类最常用的接收器了.  甚至可以说决定我们是否尝试某款产品的90%因素都是颜色所致呢.

那么颜色和我们的感知究竟是什么样的对应关系呢?

这里作者聚了4个典型的例子:

黑色

绿色



蓝色



以及在大大小小品牌商标logo中使用的种种颜色:



基于此, 颜色对人类的感受是有着非常明显的影响的, 这一影响尤其是在我们购物时发挥的最为到位. 有一个分析公司 KISSmetrics曾经做过一个非常棒的信息图来描述关于颜色是如何影响我们的购买决策的.

从其中可以看出绿色在购物中使用的最为突出, 因为它最能让人放松.  其次, 黑色也经常用于奢侈品中, 它在背光下表现极为出色. 下面就是这一信息图的全文啦:



既然说了颜色会影响到人们的心情感受, 那么你要如何利用颜色来提升你的市场效果呢?

同样是来自 KISSmetrics, 我们概括来说有以下几点:

针对女性而言

女性爱好色: 蓝色, 紫色, 绿色女性厌恶色: 橘色, 棕色, 灰色

 

针对男性而言

男性爱好色: 蓝色, 绿色, 黑色男性厌恶色: 棕色, 橘色, 紫色

 

也有人曾经做过一个实验去看改变一个按钮的颜色 对于转化率的影响. 他们选用了绿色和红色作为对比.

对绿色呢, 他们初始猜测:

  绿色通常和”自然”,”环境”联系在一起, 在加上在交通灯中的广泛应用, 有一种”Go”或者前进的意味在其中;

对红色呢, 初始认为:

  红色和绿色不同, 通常认为是一种兴奋的, 激情的, 和血, 警告等联系在一起. 而在交通灯中常用来指示停止. 当然, 红色往往很抢眼.

按照上面的分析, 多数人会假设绿色更加友好, 其转化率应该更高猜对.

所以, 他们进行了一个简单的 A/B test, 来测试看看究竟是哪种颜色的转化率更高.



结果呢? 红色按钮的表现比绿色按钮的表现要好上21% 为什么呢? 本文并没有直接给出答案, 大家可以自己思考一下~

作者结合这个故事主要想说的一点是: 无论要做什么样的改变, 都要先从假设开始, 实践是检验真理的唯一标准.  data always beats opinion,no matter what.

最后来个趣味小知识: 为什么超链接是蓝色的呢?

看的时候我恰好看到下文中有个fun story….于是非常恶意的想: 不会又是万维网之父也是个红绿色盲吧…

当然不是… 哈哈. 实际上使用蓝色是为了能够和原本网页背景色的灰色形成最佳的对比.



详细解释如下:

  Tim Berners-Lee,万维网的主要缔造者, 被认为是初始设定链接为蓝色的人.  Mosaic, 这个非常早起的浏览器, 展示网页的时候默认是灰色的背景和黑色的文本. 而同样为深色调, 但是又不至于和黑色混在一起的就是蓝色了. 所以, 为了让链接能够在一堆文本中脱颖而出, 方便阅读, 就默认设定超链接的颜色为蓝色了.

作者最后做的总结其实确实值得深思:

  仅仅简单改变一些非常小的类似颜色这种细节, 就能产生如此巨大的改变,  甚至可以完全改变最后的产出.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>设计心理学系列(1) - 网络心理学</title><link>http://taoalpha.me/blog/2015/05/08/read-design-psychology-1-cyber-psychology/</link><category>read</category><tag>Cyber Psychology,设计心理学</tag><pubDate>2015-05-08T12:00:00.000Z</pubDate><description>什么是网络心理学?网络心理学是随着互联网等新技术出现以及发展而逐渐发展起来的一门新兴科学. 它所研究的领域就是网络与心理学的结合, Cyberpsychology本身由两个词合并而成, 前者Cyber是取自Cybernetics, 代表着对于机械控制和与之通信的研究, 代表着对新兴网络领域的研究, 而心理学则是对人脑和行为学的研究. 两者的集合即表明了Cyberpsychology的研究领域主要集中在了人与新兴机器系统(包含虚拟系统)的心理学研究.
网络心理学简介演化历史Cyberpsychology最开始是集中关注于人在操作机器以及与机器交互的过程中的心理学变化, 后来随着电脑的出现以及普及, 互联网的诞生以及发展, 加上新兴智能机器的出现和发展, 都使得Cyberpsychology的研究重点放到了互联网上面. 而随着虚拟现实技术的出现, Cyberpsychology的研究范围再一次的增广, 可以说, Cyberpsychology的研究范围基本会随着cyberspace的领域增长而延伸.
通常认为John Suler, 来自Rider University的心理学教授, 是Cyberpsychology的奠基人. Suler教授是最早开始关注与网络对人们心理变化带来的影响, 其出版的The Psychology of Cyberspace一书也是被认为最早整合性的Cyberpsychology学术作品.
从1960年代, 计算机开始出现网络系统, 到1980年代世界性互联出现, 领域内专家, 极客作为初始用户. 又过了10年, 随着超链接的出现, 衍生了一个对普通人更友好的万维网. 全球互联网正式诞生.
随着人们对互联网的使用越来越频繁, 开始逐渐有心理学研究人员关注到这一领域, 慢慢促成了Cyberpsychology的诞生. 而随着互联网对人们生活的侵入越发全面, 这一领域也越来越收到人们的重视, 而随着互联网的发展, 新技术的出现, 这一领域也在不断的自我演进. 
很多人都预言未来毫无疑问将会是网络的时代, 而随着智能设备, 智能家居以及虚拟现实的出现, 都让这一预言变的更加可信. 所以研究人与网络的交互过程对人类本身的影响反馈是非常重要而值得的.
参考视频: The Birth of CyberPsychology - 需翻墙
包含方向目前人们对于Cyberpsychology的研究方向都还集中在那些因网络出现而造成的明显影响之中, 尤其是那些负面影响, 目前大体的一些主流热门话题都围绕在以下几个方面:

网络成瘾问题;
网络身份与自我认知问题;
网络关系问题;
网络与现实的表现差别问题;
网络人格/性格问题;
虚拟现实领域;

…
网络心理学的研究知名人士
Dr. John Suler - The founder of the Cyber Psychology
J. &amp;amp; Parker - The author of the Cyberpsychology
Bernard Luskin - Launched the first MA/Ph.D program in Media Psychology

重要期刊
Journal of Computer Mediated Communication
Cyberpsychology: Journal of Psychosocial Research on Cyberspace
Cyberpsychology, Behavior, and Social Networking
Journal of CyberTherapy &amp;amp; Rehabilitation

阅读书目
The Psychology of Cyberspace by John Suler
Cyberpsychology by Alison Attrill
Cyberpsychology: An introduction to Human-Computer Interaction
Cyberspace Romance: The Psychology of Online Relationships
The Psychology of Menu Selection: Designing Cognitive Control at the Human/Computer Interface (Human/Computer Interaction)

参考文献
Wikipedia of Cyberpsychology
The psychology of cyberspace
Cyber Psychology &amp;amp; Cyber Sociology
Cyberpsychology and Vitrual Reality
The first decade of CyberPsychology

2015-05-09 By 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>52WeeksOfUX-第一周(译)</title><link>http://taoalpha.me/blog/2013/06/11/read-first-week-of-52weeksofux-translated/</link><category>read</category><tag>Design,UX,产品学习,翻译文章</tag><pubDate>2013-06-11T12:00:00.000Z</pubDate><description>The First Rule of UX(UX第一定律)“你不得不交流.所有的行为本质都是一种交流.因为行为本身没有一个完全相反的概念(没有反=行为的概念),所以不可能不去交流.(这个因为所以没有看懂啊)”–Paul Watzlawick关于沟通的第一公理.
这是UX的第一条规则.设计师所做的任何事都会对用户体验造成影响.从一个有一天添加的设计元素到一个关键信息的疏忽遗漏,每一个决定都在塑造着我们设计服务的用户的未来模型.
因此,任何一个好的设计师的首要目标都是传达预期的信息…这可以促进用户体验的提升.文案,文本颜色,表格的对齐,导航链文字标题的大小写–即便是没有设计模式,也都是沟通的一部分.
了解了这些,我们可以问这样的一个问题(最好也能回答):”这个元素和我想要向用户传达的信息是相辅呢?还是相悖呢?”而且,通过询问这些,你可以重新定义改善一些细节;一些经常不被注意的细节,而这些通常组成了最终的用户体验.
What makes the user experience?用户体验是由一个用户和你的品牌,公司,组织的全部交互所组成的.这将可能包含于你的软件的交互,与你网站的交互,与你电话服务中心的交互,与广告的交互,以及在他人电脑上指指点点的交互,与一个移动应用的交互,与你Twitter账户的交互,与你通过邮件的交互,可能甚至是面对面的交互.这些交互的总和构成了用户体验.
交互设计师就是在这个时候发挥作用的.他们的一部分指责就是让所有的交互都灵活,包含所有软件,文案,图形,布局,用户流动,物理体验的各个方面.对于一个体验而言,如果一部分极好而另一部分极差,那才是羞耻.内聚力是非常重要的.
用户体验贯穿了很多的实际工作.以建筑为例,如果一个建筑师被雇佣来为一个财力雄厚的客户创造一种很棒的用户体验,他们将不会止步于设计人们的居住环境.他们会花时间花精力去关注周边的绿化,车道的弧线,每个角度的视觉感受..可能甚至是客户可能打招呼的方式以及桌椅摆放的方式.所有的这些触点对于一个大型的系统都是重要的组成部分..而房屋仅仅只是这块大拼图的一片而已.
网页设计师,传统观点中的网页创建者,现在有了更广的领域.因为用户体验设计时的环境比以前变的更广了.所以,我们必须调整我们的设计方法,包含用户体验的方方面面.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Knowledge vs Intelligence</title><link>http://taoalpha.me/blog/2014/11/21/read-knowledge-vs-intelligence/</link><category>read</category><tag>翻译文章,译系列</tag><pubDate>2014-11-21T10:00:00.000Z</pubDate><description>大约一周前, 我在开发我一个小产品的时候遇到了一个很严重的问题. 我花了好几个晚上的时间去解决这个问题, 但是依然没有什么进展, 这让我很沮丧.

之后的一个晚上, 我正在和 Olivier Lacan视讯, 我们讨论了这个问题. 因为他是我的一个非常好的朋友, 所以他建议我把我的桌面分享给他来让他看看. 我正在研究 Laravel一个全新的PHP的框架, 也是Olivier从来没用过的一个框架(当然其实他连PHP都不用的). 但是他很聪明而且是一个很伟大的开发者, 所以我很愉快的接受了他的要求.

我们开始梳理整个代码库, 我带着他过了一遍整个应用和框架,  他则见或提出一些内部系统的尖锐问题. 因为Olivier并不是非常熟悉Laravel, 所以他问的问题就和我不同, 而这些问题则指向了一个有趣的部分, 而这个部分正是我一个人想的时候没有注意到的. 而在一个小时的debug后, 我们找到问题的根源并且解决了它.

我之前曾谈论过有关 “编码交换”的话题, 就是把自己的电脑与他人交换, 然后尝试解决对方的问题–但是这次则是另一个问题. 这是一个类似 传统的 “橡皮鸭”的问题, 不同的是有一个可信任的聪明的朋友.

这里的关键在于知识和智慧之间的区别. 知识是关于技能, 以及经历和从中获取的信息的集合. 智慧则是应用知识的能力.  一个人缺乏某个领域的知识不代表他们不能应用自己的智慧来帮助解决对应的问题.

知识是很好的, 但是它总会随着技术和科技的 兴起没落而渐渐消失掉. 但是智慧则不会. 它跨越了技术和科技之间的壁垒, 这就是最大的区别了.

Source:

Knowledge vs Intelligence
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>How Users Read on the Web(译)</title><link>http://taoalpha.me/blog/2013/06/04/read-how-users-read-on-the-web-translation/</link><category>read</category><tag>HCIBib,产品学习,网页浏览,翻译文章</tag><pubDate>2013-06-04T10:00:00.000Z</pubDate><description>本文主要是针对网页上的文字排版对于用户阅读的影响,列举了三种不同的处理方式以及混合情况下对网页可用性的提升效果.他们从不阅读。
人们极少逐字逐句地阅读网页上的内容，他们只是扫视页面，选取某些字词语句来阅读。 在关于人们如何阅读网站的研究中，我们发现大概79%的测试用户对于任何他们进入的页面都是采用扫视的方式阅读，只有16%的用户 是逐字阅读的。(更新：一个新的研究发现用户在阅读email时比阅读网站更加散漫。)
所以，网页需要提供可以扫视的文本信息，利用：
    高亮关键字(超文本链接是高亮的一种形式，字体和颜色变化也是高亮的形式)    有意义的子标题(不算作很明智的选择)    符号列表    一个段落一个主题(如果用户没有段落中前几个词所吸引的话,那么他们会跳过剩下的所有)    倒金字塔风格,先说结论    相比传统的写作而言,字数至少要减少一半我们发现可信性对于网页用户而言是非常重要的,因为对于网页信息背后的作者以及网页是否可以信任是不清楚的.可信性可以通过高质量的图片/优秀的写作以及向外的超文本连接来提高.外链表现出作者已经做完了该做的,并不担心用户访问别的站点.
用户厌恶”商业感”,通过主观的自我夸赞和宣言(有史以来最经典的)来提升写作风格在当下的网页中已经不再使用了.网页用户非常忙碌的,他们想要得到最直接的结果.还有,如果用户清晰的看到网站在夸大,可信性会一落千丈的.
衡量提高网页写作风格带来的影响
为衡量一些我们已经确认的内容指南所带来的影响,我们制作了想通网站的五个不同的版本(形同的基础信息;不同的措辞;相同的站点导航).接着我们让用户在不同的网站下完成相同的任务.正如下表中所示,易用性在简介版本以及浏览性版本的网站中得到了很明显的提升(58%以及47%的提高).而且当我们将三种 方式整合到一起来提升写作风格,形成一个单一的站点,结果会更加炫目:124%的易用性提升.




网页版本

示例段落

可用性提升

促销对照组 使用的就是常规商业网站使用的风格
Nebraska is filled with internationally recognized attractions that draw large crowds of people every year, without fail. In 1996, some of the most popular places were Fort Robinson State Park (355,000 visitors), Scotts Bluff National Monument (132,166), Arbor Lodge State Historical Park &amp;amp; Museum (100,000), Carhenge (86,598), Stuhr Museum of the Prairie Pioneer (60,002), and Buffalo Bill Ranch State Historical Park (28,446).
0% (by definition)

简洁版本只有对照组的一半字数
In 1996, six of the best-attended attractions in Nebraska were Fort Robinson State Park, Scotts Bluff National Monument, Arbor Lodge State Historical Park &amp;amp; Museum, Carhenge, Stuhr Museum of the Prairie Pioneer, and Buffalo Bill Ranch State Historical Park.
58%

扫描式布局 和对照组文本一致,但采用易于扫视的格式
Nebraska is filled with internationally recognized attractions that draw large crowds of people every year, without fail. In 1996, some of the most popular places were:

Fort Robinson State Park (355,000 visitors)
Scotts Bluff National Monument (132,166)
Arbor Lodge State Historical Park &amp;amp; Museum (100,000)
Carhenge (86,598)
Stuhr Museum of the Prairie Pioneer (60,002)
Buffalo Bill Ranch State Historical Park (28,446).47%客观的语言 利用中立而不是主观自负或者言过其实的语言(其他都和对照组一致)Nebraska has several attractions. In 1996, some of the most-visited places were Fort Robinson State Park (355,000 visitors), Scotts Bluff National Monument (132,166), Arbor Lodge State Historical Park &amp;amp; Museum (100,000), Carhenge (86,598), Stuhr Museum of the Prairie Pioneer (60,002), and Buffalo Bill Ranch State Historical Park (28,446).27%整合版本以上三种写错风格修改的集合.In 1996, six of the most-visited places in Nebraska were:
Fort Robinson State Park
Scotts Bluff National Monument
Arbor Lodge State Historical Park &amp;amp; Museum
Carhenge
Stuhr Museum of the Prairie Pioneer
Buffalo Bill Ranch State Historical Park124%在客观语言版本中可用性获得了27%的提升着实让我们吃惊了.我们期待用户可以喜欢这个版本胜过对照组(实际上也确实是这样的),但是我们认为评价标准对于任意一种语言而言都是一样的.正如预计的那样,我们的四种评价标准(时间错误内存网站结构)都获得了客观风格比原始的促销版本更好一些的结论.我们用以解释这一发现的猜想是促销性语言为用户强加了认知的负担,必须让用户花费精力去过滤夸张的表象从而获得事实. 当人你们在阅读一个以”Nebraska是一个充满了国际公认景点的地方”开头的地方,他们的第一反应是”不,不是的”,并且这一想法将会降低他们使用网站的速度,分散他们的注意力.

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>网页设计简史</title><link>http://taoalpha.me/blog/2014/12/05/read-read-a-brief-history-of-web-design/</link><category>read</category><tag>Design,翻译文章,设计,读系列</tag><pubDate>2014-12-05T09:00:00.000Z</pubDate><description>本文针对网页设计的历史做了简单的介绍, 配上了很多动态图片作为示意, 可以说很简练但是也很完整, 值得一读.

作者最开始应该是对设计和代码实现都比较有兴趣的, 但随着代码越来越复杂, 实现一个设计的方法越来越多, 但是即便这么多的方法, 都不能保证适用于所有浏览器. 于是作者慢慢对代码层失去了兴趣, 专心开始搞设计了~ 所以本文开篇, 作者提出了一个很好的问题:

  设计和代码部分是如何分开的呢? 而且越分越远?

所以相对于设计师该不该学代码的问题, 本文研究的则是设计和代码是如何在网页设计这条路上分道扬镳的呢?

1989–网页设计最黑暗的时期



可以说最开始的网页设计是非常不明朗的, 那个时候屏幕都是黑色背景的命令行状态, 再加上非常有限的屏幕尺寸.  可以说, 那个时候所谓设计能依赖的东西只有那些符号和制表符了… 真可以说那个时候就不存在什么网页设计…

1995 - 网页设计的开端-表格设计



随着可以展示图片的浏览器的诞生, 宣告了网页设计的正式开始. 而在当时, 已经存在于html中的table元素就成为了设计师用来发挥自己设计天赋的绝佳工具. 当时有本著名的书 Creating Killer Sites就是介绍如何用Table布局的. 但是Table的设定本身并不是为了进行页面的设计布局, 而是为了展示结构化的数据, 所以存在了很多的问题, 比如维护这种碎片化的结构是个相当费事的事情… 但是, 因为各种原因, 这种设计方式依然存在流行了很长的一段时间~ 而在这一时期, 切图设计也逐渐变热. 设计师们设计出各种酷炫的布局, 而开发者则将他们拆分成一个个小块然后再拼接在一起. 另一方面, 表格又确实有着一些非常棒的属性: 比如垂直居中. 这些优势和我们后面会说到的grid布局设计极为相像.  但也正因为这种布局结构的麻烦和痛苦, 所以很多开发者们都很不喜欢进行前端编程…

1995-JS的出现



JS可谓是对HTML的很好补充. 比如说, 如果我们需要一个弹出窗口, 想要动态的对某些东西进行排序? 那么JS就是最好的选择了.  问题在于JS是基于网页基础结构之上的, 所以它不能和web资源一起载入, 而需要分开进行载入.  所以有种像是html的补丁一样~

如今我们多数情况下能用CSS实现的基本不用JS实现, 但是当时JS可谓是网页设计的一大救星啊. 即便如今, jQuery此类的JS库依然是前端编程和后端编程(node.js)的热门组件.

1996-设计的黄金时期



为了打破当时网页设计的限制, 出现了一个前所未有的工具, 而使用它, 设计师们的工作变的无比的自由! 任意的形状, 布局, 动画, 交互, 字体, 随便搞. 这个工具就是–Flash. 把需要的资源打包到一起, 然后交给浏览器去展示就行了. 这就意味着只要用户拥有最新的flash插件, 那么只需要等待一段载入时间, 那么它就能呈现出非常绚烂的结果. 这可以说是网页设计的黄金时期, 出现了无数的飞溅式设计, 介绍动画, 以及各式各样的交互效果. 但不幸的是, 它的不够开放或者说对搜索引擎非常不友好以及处理本身耗费的资源过多等特性, 都导致其终将被舍弃. 而随着Apple决定在他们的iPhone上直接抛弃了Flash的支持, Flash就开始走向了衰亡(至少对网页设计来说是的).

1998-CSS



CSS大概和Flash同时期出现的, 作为一个解决设计布局的更好的方法而出现在设计师面前.  基本的想法就是把网页内容层和展示样式层分离开. 所以外观展现和样式类型都由CSS来决定, 而内容则由HTML决定. 第一版的CSS当然远没有如今的这么灵活, 丰富, 但是这还不是当时最大的问题. 当时最重要的问题是各大浏览器的支持率. CSS花费了几年的时间才让很多浏览器开始支持它, 而且最初还有着很多各式各样的问题存在.  而在当时, 一个浏览器更新支持一个新功能, 而其他浏览器还没有支持这种让开发者痛苦至死的事情(即便到如今依然有这个问题…尤其是在国内: IE6,7..永恒的恨啊..)已经开始出现. 

值得说明的是: CSS并不是一种编程语言, 它更像一种声明性语言. 我们可以讨论设计师是不是需要编程, 但是设计师需不需要了解CSS的工作原理则是完全不需要讨论的事情.

2007-移动端的升起-网格布局和框架的时代



在移动端浏览网页对当时的设计师而言是个非常大的挑战. 不说布局, 单就是它引发的内容问题(content-parity)就是个挺麻烦的事情: 在小屏幕下展示时和大屏一样呢? 还是要精简一些呢? 在小屏幕上如何投放那些晃眼的广告呢? 速度也是个问题, 毕竟加载资源过多的话网费就够你喝一壶的了. 首先提出的解决方案是网格布局法. 而经过几次迭代厚, 960 grid system成功的普及开来, 而这种12列的布局方式页逐渐成为设计师们日常使用的布局结构了.  而下一步解决的问题就是常用的各个组件, 比如表格, 导航, 按钮这些元素的复用. 基本的想法是, 制作一个元素的库来存储这些代码. 而最后的胜出者就是如今大名鼎鼎的Bootstrap和Foundation了~  而随着网页和app的界限逐渐消失, 这些框架变的更加流行. 但是所有的设计看起来都是蛮像的, 而设计师如果完全不理解代码工作的原理那么也是无法发现他们的区别的.

2010-响应式设计



Ethan Marcotte决心改变当时的设计方式, 想要用同一套内容但是不同的布局来自动的适应不同的屏幕尺寸(厉害啊!), 于是, 响应式布局就出现了. 从技术上, 还是使用HTML和CSS, 所以倒也不是一个新的技术. 但是如今对响应式依然存在了很多的误解. 对于一个设计师而言, 响应式往往意味着要进行多布局的设计. 对于客户而言, 就是单纯的: 这个网站在手机上也能看的比较舒服. 对开发者而言, 则设计了很多方面, 包括图像的展示, 下载速度, 是否移动居先等等问题. 而这里最大的好处就是内容, 它能够保证网站内容的完整性和一致性. 

其实响应式的问题目前也主要集中在加载层面, 毕竟响应式会导致在手机上也会加载几乎全套的资源, 这必然会导致加载速度受到影响. 而包含了各个尺寸样式的css文件也会导致加载速度的变慢~ 不过! 随着技术手段的提升和网络速度的提高, 这些问题想来也不会是什么大的问题吧.

2010-扁平化时代



为不同布局状态设计是很费力的一件事, 而简化设计流程, 去掉那些烦人的阴影效果以及仿真化的细节, 自然能够让设计变的容易很多. 这就是扁平化设计, 其极大的简化了元素的细节, 重回设计的根本–为内容服务.  而那些酷炫的按钮则被图标取代, 使我们能够使用位图以及icon字体. 有趣的是, 这在一定程度上和网页的起始阶段很像, 不是吗? 果然是回归根本啊…哈哈

2014-光明的未来



网页设计说白了就是设计师制作的视觉效果在浏览器中呈现罢了. 想象以下, 未来设计们可能只需要拖动下元素, 就能够获得一个简洁的代码文件, 而不在需要手写代码, 这多给力啊. 哪怕不能做到那些酷炫的效果, 仅仅单纯的静态页面和简单的交互也是相当不错的事情呢. 再想象以下未来开发者们再也不用担忧浏览器兼容的问题, 而只需要集中精力解决那些真正的问题, 那TM该是多美好的未来啊…

如今技术上已经出现了一些光明未来的曙光: 比如CSS中新引入的一些属性, vh, vw就容许布局上有更好的灵活性. Flexbox则帮助更好的布局, 不再需要那么多的代码, 只用一行就能制作很棒的布局了. 而那些现成的做好的各个组件, 比如注册登录等等, 都让网页设计变的更加容易更加流畅. 
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Google又做了一件大好事:干掉了烦人的识别型验证码!</title><link>http://taoalpha.me/blog/2014/12/04/read-read-google-did-a-good-thing-kill-annoying-type-identification-code/</link><category>read</category><tag>Captcha,reCaptcha,翻译文章,读系列</tag><pubDate>2014-12-04T14:00:00.000Z</pubDate><description>译系列正式转为读系列, 以后都为阅读后自己整理总结成文~ 吸收知识哈哈
伟大的Google又做了一件大好事啊!! 它干掉了烦人的识别型验证码!!! 本文简单介绍了一下这一新的验证码.

对于验证码, 大家都不会陌生, 无论你是否经常上网, 是否买过东西, 是否看过网络视频, 你一定遇到过验证码!!! 而如今最为常见的几种验证码形式分别是:

Captcha(Completely Automated Public Turing test to tell Computers and Humans Apart): 图片识别, 通过识别一些或模糊或清晰的图片中的文字信息来达到验证”我不是机器人”的效果;reCAPTCHA: 同样来自Google, 用Captcha的方式做有意义的事情. 其和Captcha的表现形式基本是一致的, 只不过里面的图片不再是预设好的人工生成的那种故意扭曲或者加干扰后的图片, 而是Google的图书扫描项目中那些OCR无法识别的单词(多数是手写体或者不够清晰), 这样你每次输入验证码, 还能帮助Google的Books做的更好哦~(至于如果它自己都不识别, 那么怎么判断输入是否正确, 则是因为通常reCaptcha会提供两个词组, 一个是已知的, 一个是未知的, 所以呢, 在已知的正确的情况下, 未知的正确性就有了一定的保证, 而结合大量的输入, 那么最中获得的结果的正确概率就越高:所以, 面对一些很少有人输入过的验证码, 其实你很有可能输错了部分, 但也通过了~哈); 而继图书项目后, Google又在reCaptcha项目中加入了Google街景的路牌, 街道名识别~ 所以有时候你会遇到那种拍的很模糊的数字图~Puzzle CAPTCHA: 在识别类验证码之后, 又出现了这种拼图类的验证码, 操作方式有很多, 有的是图片切分打乱, 需要你重新排列成完整的图片, 有的则是有一块图片从整个图片中脱离出来, 需要你移动回去这种~ 这种有时候也叫做Draggable Captcha~Quiz Captcha: 这种则属于问答类的验证码了, 有的时候是一些显而易见的数学计算题或者找规律题, 有的时候则是一些基本常识, 还有些时候甚至是当前往网站名称这类有着明显答案提示的问题~

当然, 除了上述的这些, 还有着很多的验证码类型, 但是无论怎样, 为了实现区分人和机器的目的, 都是需要一定操作成本的, 这也是为什么大家很讨厌验证码的原因~

但是! Google这次新的reCaptcha:No CAPTCHA reCAPTCHA, 就改变了这一点, 它完全干掉了现有的这种繁琐的验证码, 取而代之的是一个简单的checkbox!!! 你只要勾选了这个”我不是机器人”边上的checkbox, 就算是通过了验证~ 似乎感觉这不是进步而是退步? 这样怎么能够实现Captcha的区分人和机器人的目的呢?

其实这个简单的checkbox里面有着非常复杂的机制, 它会通过你验证码勾选前后的整个表现来判断是否是一个机器人, 一旦有所怀疑, 甚至可以选择变回旧有的那种图形或者其他传统类型的验证码来再次确认. 这些都是基于 人工智能方面很深入的研究和成果.

目前这种新的Captcha的API已经开放给很多大客户了, 最近在开始接受网站主们的申请了~ 而那些大客户的反馈来看, 其效果是非常不错的: 核心的anti-spam质量虽然文章中没说, 但应该不错, 文章中重点提到了这个新Captcha的一个优点就是可以让用户更快的登录访问网站.

有兴趣的可以前往Google reCaptcha了解更多详情~
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Introduction To Usability(译)</title><link>http://taoalpha.me/blog/2013/06/13/read-introduction-to-usability-translated/</link><category>read</category><tag>UX,Usability,产品学习,翻译文章</tag><pubDate>2013-06-13T09:00:00.000Z</pubDate><description>Introduction To UsabilitySummary 如何定义可用性?如何,什么时间,什么地方来提升?为什么你要关注可用性?这是一个关于核心的可用性概念的介绍以及回答一些基本的问题.
What–Definition Of Usability
可用性是一个表征质量的属性,用以描述用户界面在使用性上的难易程度.”Usability”这个词本身也有用以提升设计过程中易用性的方法的含义.
可用性主要通过以下5个部分的特点组成:
    易学性:对于用户而言,第一次使用时完成基础任务的难易程度?    高效性:一旦用户学会了之后,他们完成任务的效率有多高?    记忆性:当用户在一段时间的不用后再次返回时,他们重新熟练的容易性如何?    错误率:用户会犯多少错误,这些错误的严重程度如何,以及他们从这些错误中脱身的难易程度?    满意度:用户使用这一设计的满意度如何?此外还有很多重要的品质属性.其中比较关键的一个就是实用性,表征的是设计的功能性:它所做的都是用户所需的吗?
可用性和实用性都是同等重要的,而且它们一起决定了设计是否有用:如果某物很容易但却不是你想要的也是没啥意义的. 虽然对于幻想那种可以做任何你想做的事情的系统也不见得是好的,但是如果你的交互界面很难用的话,你是不可能做到这一点的.为了研究一个设计的实用性,你可以用提升易用性同样的研究方法.
    Definition: Utility—它是否提供了你所需要的功能;    Definition: Usability–这些功能用起来的难度和满意度如何.    Definition: Useful = Usability + UtilityWhy Usability is Important(为什么可用性这么重要)
在网络上,可用性是一个必须要考虑的生存条件.如果一个网站非常难用,人们就会离开.如果一个公司的主页不能描述清楚公司提供的产品或者服务,用户可以做什么等,人们也会离开.如果用户在一个网站迷路了,他们就会离开.如果一个网站的信息很难阅读或者无法回答用户的关键问题,他们也会离开. 注意到一个模式了吗?根本不存在这样的情况:用户费劲的阅读说明书或者花费很多时间去理解一个界面.外面还有无数的网站等待用户去选择,离开是用户在感到难用时的第一选择.
电子商务的第一条定律就是如果用户无法找到产品,他们就无法购买这个产品.
对于企业内部网络,可用性就是一个关乎员工生产力的事情了.用户如果花费太多的时间在内部网络或者纠结于思考那些困难的指令,那么也就等同于在浪费着你付给他们工作的薪水了.
目前最佳的财政预算是将设计项目预算的10%留给可用性上.平均来讲,这些大概是一个网站期望的质量标准的2倍左右,而且大概是一个内部网络质量标准花费的两倍略低一些.对于软件或者实际的物理商品,强调设计过程的易用性,所致的提升效果会相对较小,但是依然很显著.
对于内部的设计项目,应该考虑将培训预算砍掉一半,而将易用性方面的预算加倍,以及加倍做事的员工的时薪.对于外部的设计,则应该考虑加倍销售的预算以及注册用户和用户引导的预算,同时加倍那些对你的设计项目有提升动机的预期计划.
How to Improve Usability(如何提升易用性)
在研究易用性上有很多方法,但是最主要最基础最有用的就是用户测试了,它包含了以下三个部分:
    找到一些典型的用户,比如电子商务网站的消费者或者内部网络的员工(在后者的情况下,他们应该是在你们部门之外工作的);    让用户实施一些有代表性的任务;    观察用户做了什么,那些地方成功了,哪些地方他们遇到了问题,而且闭上你的嘴,而让用户讲出他们想说的;逐一分别的测试用户,让他们独立解决任何问题是很重要的,.如果你帮助他们或者把他们的注意力指引向屏幕的任何部分,你都让实验结果受到了污染;
为确定一个设计最重要的易用性问题,测试5个用户就基本足够.预期去运行一个大型的,昂贵的项目研究,还不如使用这些资源进行一个小规模的测试,并且逐一重新审视你的设计,这样你才能在确定问题后修正你的易用性瑕疵.迭代设计是一个而方法来提升你的体验质量.你和用户测试的版本和界面设计越多,效果越好.
用户测试和焦点小组是不同的,焦点小组是一种相对较差的方式来评估设计的易用性.焦点小组常用于市场调研,但是为了评价交互设计,你必须足够近的观察一个用户利用你的设计界面去完成一个任务.通过聆听用户所说的会有误导:你必须去亲自观察他们真正做的是什么.
When to Work on Usability(什么时候注意易用性)
易用性在设计过程的每一步中都占据一定的地位.对于多个研究的需要也是我推荐把个人独立的研究尽快而又便宜的完成的原因之一:
    在开始一个新的设计之前,测试旧有的设计来确定其中好的部分,这样你就可以保留这些部分并加以强化,同时知道哪些对用户造成困扰的部分.    除非你在一个内部网络中工作,测试你竞争者的设计可以廉价的获取到一组相对较好的设计界面,而且这些都和你的设计有着很多共同的特性.(如果你工作于一个内部网络,那么可以通过阅读内部的设计年刊来学习其他的设计).    针对用户在他们的日常生活中是如何表现的做一个实地的考察;    对一个或者更多的新设计注意制作纸质原型并加以测试.你投资在这些设计的时间越少,效果越好,因为你需要根据测试结果来修改他们(就是不用花费太多的时间去做特别精致的原型)    通过多次迭代后,对最优秀的那个设计不断修改来完善它,逐渐的从低质量的原型到高质量的电子原型展示.每一次迭代都需要测试.    观察那些和建立可用性规则先关的设计,无论是你早期的研究还是公开的研究.    一旦你决定了并且开始着手最终的设计,再次测试一次.一些微小的可用性问题经常在实施的时候出现.不要抵制用户测试,除非你已经有了一个完成的设计了.如果你已经有了一个成品,那么再去修复绝大多数测试没有覆盖到的关键问题就会变得不可能了.像这一类的问题大多是比较偏向结构方面的,而修复他们将会需要对主要部分的重构.
想要获得一个高质量的用户体验唯一的方法就是在设计的早期就开始用户测试,并一直持续的在接下来的每一步实施它.
Where to Test(在哪里测试)
如果你每周至少实施一次用户测试,那么专门建立一个可用性实验室就有必要的了.但对绝大多数公司,在一个会议室或者办公室里进行一次测试就已经不错了,只要你关上门隔开干扰就可以了.重点在于你要有真实的用户,并且可以在他们测试的过程中陪坐一旁.你唯一需要的设备就是一个笔记本.
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Reloading Python Modules</title><link>http://taoalpha.me/blog/2015/02/16/read-reloading-python-modules/</link><category>read</category><tag>coding,python,应用推荐与技巧,翻译文章</tag><pubDate>2015-02-16T13:00:00.000Z</pubDate><description>Reloading Python Modules是一篇10年的老文了. 不过正好最近有看到Python中reload的相关介绍, 推荐了本文, 特地译来加深记忆以及分享给大家:

Python众多优点中的一个就是可以对代码模块进行重载. 这就允许了开发者即便在Python的编译器运行状态下也可以修改Python代码了. 通常来说,  只需要把对应要重载的模块对象传入 imp.reload()函数中即可(python 2.x中是通过直接reload()来实现). 

不过这里面还有几个潜在的复杂问题.

如果一个模块中引入了重载模块的一些symbols, 那么这些symbols不会自动重载. 比如, 我们有一个包含了常量 INTERVAL = 5的A模块, 而模块B则引入了这一常量, 比如通过(from A import INTERVAL). 那么如果我们修改INTERVAL = 10, 然后重载A模块的话, 在B模块中的INTERVAL以及所有基于INTERVAL的值都不会自动更新的.

解决这一问题的办法就是我们要把B模块也重载一些. 但是要注意的是一定要在A模块重载完后重载B, 不然的话, B还是不能按照更新后的A来执行.

PyUnit则通过引入了一个 rollbackimporter的方式来处理这类问题. 它会通过重写python的全局引入 import而将引入规则”rolls back”到之前的状态.  这一方法在让编译器还原到前一测试点上非常便捷, 但是却不能算是一个解决实时代码重载的好方法, 因为那些为加载的模块还是不能自动的重载.

下述介绍了一个很好的模块重载解决方法, 目的是让这一过程更加自动化, 更加透明以及可靠.

Recording Module Dependencies

在重载前一定要清楚各个模块之间依赖关系, 这样才能很好的设计重载的顺序. 理想的方法是建立一个模块之间的依赖关系图谱. 这可以通过引入一个自定义的import, 并且在程序常规代码部分引入它来实现.

import builtins


12345678910111213141516171819202122232425262728_baseimport = builtins.__import___dependencies = dict()_parent = Nonedef _import(name, globals=None, locals=None, fromlist=None, level=-1):    # Track our current parent module.  This is used to find our current    # place in the dependency graph.    global _parent    parent = _parent    _parent = name    # Perform the actual import using the base import function.    m = _baseimport(name, globals, locals, fromlist, level)    # If we have a parent (i.e. this is a nested import) and this is a    # reloadable (source-based) module, we append ourself to our parent's    # dependency list.    if parent is not None and hasattr(m, '__file__'):        l = _dependencies.setdefault(parent, &amp;amp;lt;input type=checkbox&amp;amp;gt;)        l.append(m)    # Lastly, we always restore our global _parent pointer.    _parent = parent    return mbuiltins.__import__ = _import&amp;lt;/code&amp;gt;
这里把内置的import函数(在_baseimport类中)做了简单的修改. 它能够跟踪当前的母模块(依赖模块), 也就是进行import操作的模块. 而最顶层的模块自然是没有依赖模块的.

而一旦一个模块被成功的引入后, 它就会自动的加入到依赖模块的依赖列表中去. 你可能注意到上述代码中只是关注了那些基于文件的模块 内置的那些扩展则都被忽略了, 这是因为内置的模块是不能够被重载的.

这就给我们了一个完整的模块依赖关系链, 我们就能够轻松的获取到某个模块相关的所有依赖模块了:


1234def get_dependencies(m):    &quot;&quot;&quot;Get the dependency list for the given imported module.&quot;&quot;&quot;    return _dependencies.get(m.__name__, None)&amp;lt;/code&amp;gt;
Reloading Modules

在知道了相关的依赖模块关系后, 我么就可以建立一个依赖模块重载路线了:


1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import impdef _reload(m, visited):    &quot;&quot;&quot;Internal module reloading routine.&quot;&quot;&quot;    name = m.__name__    # Start by adding this module to our set of visited modules.  We use    # this set to avoid running into infinite recursion while walking the    # module dependency graph.    visited.add(m)    # Start by reloading all of our dependencies in reverse order.  Note    # that we recursively call ourself to perform the nested reloads.    deps = _dependencies.get(name, None)    if deps is not None:        for dep in reversed(deps):            if dep not in visited:                _reload(dep, visited)    # Clear this module's list of dependencies.  Some import statements    # may have been removed.  We'll rebuild the dependency list as part    # of the reload operation below.    try:        del _dependencies[name]    except KeyError:        pass    # Because we're triggering a reload and not an import, the module    # itself won't run through our _import hook.  In order for this    # module's dependencies (which will pass through the _import hook) to    # be associated with this module, we need to set our parent pointer    # beforehand.    global _parent    _parent = name    # Perform the reload operation.    imp.reload(m)    # Reset our parent pointer.    _parent = Nonedef reload(m):    &quot;&quot;&quot;Reload an existing module.    Any known dependencies of the module will also be reloaded.&quot;&quot;&quot;    _reload(m, set())&amp;lt;/code&amp;gt;
上述reload()函数通过递归方式去按照相反顺序依次reload所有和这一模块相关的模块, 而最后再reload以下自身. 它通过visited属性的设置来避免出现无限死循环. 同时在reload的时候它会自动重建模块的依赖关系, 来确保他们能精确的反映出模块的更新状态.

Custom Reloading Behavior

有时候reload模块的时候可能需要执行一些其他的操作或者逻辑. 比如, 重新初始化一些预加载的状态. 而为了支持这一点, 我们需要让我们的reload函数去寻找一个模块级函数reload(). 这一函数可以在一个成功的重载后被调用, 且能保留重载前的状态.

这种情况下, 我们就不能简单的直接调用imp.reload()了:


12345678910# If the module has a __reload__(d) function, we'll call it with a# copy of the original module's dictionary after it's been reloaded.callback = getattr(m, '__reload__', None)if callback is not None:    d = _deepcopy_module_dict(m)    imp.reload(m)    callback(d)else:    imp.reload(m)&amp;lt;/code&amp;gt;
其中_deepcopy_module_dict()的作用是帮助我们避免deepcopy()一些不支持或者不需要的数据.


12345678910111213def _deepcopy_module_dict(m):    &quot;&quot;&quot;Make a deep copy of a module's dictionary.&quot;&quot;&quot;    import copy    # We can't deepcopy() everything in the module's dictionary because    # some items, such as '__builtins__', aren't deepcopy()-able.    # To work around that, we start by making a shallow copy of the    # dictionary, giving us a way to remove keys before performing the    # deep copy.    d = vars(m).copy()    del d['__builtins__']    return copy.deepcopy(d)&amp;lt;/code&amp;gt;
Monitoring Module Changes

对于重载而言, 能够自动检测模块的变化而进行自动重载那是最好不过了. 那么, 实际上我们确实有很多方式来检测一个文件的变化情况. 这里使用的是一个后台线程以及 stat()这个系统函数的调用来检测文件上一次修改时间, 从而确定其更新状态. 一旦检测到一个文件被更新, 那么就会把这一文件名加入到一个 thread-safe queue


1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import os, sys, timeimport queue, threading_win = (sys.platform == 'win32')class ModuleMonitor(threading.Thread):    &quot;&quot;&quot;Monitor module source file changes&quot;&quot;&quot;    def __init__(self, interval=1):        threading.Thread.__init__(self)        self.daemon = True        self.mtimes = &amp;#123;&amp;#125;        self.queue = queue.Queue()        self.interval = interval    def run(self):        while True:            self._scan()            time.sleep(self.interval)    def _scan(self):        # We're only interested in file-based modules (not C extensions).        modules = [m.__file__ for m in sys.modules.values()                if '__file__' in m.__dict__]        for filename in modules:            # We're only interested in the source .py files.            if filename.endswith('.pyc') or filename.endswith('.pyo'):                filename = filename[:-1]            # stat() the file.  This might fail if the module is part            # of a bundle (.egg).  We simply skip those modules because            # they're not really reloadable anyway.            try:                stat = os.stat(filename)            except OSError:                continue            # Check the modification time.  We need to adjust on Windows.            mtime = stat.st_mtime            if _win32:                mtime -= stat.st_ctime            # Check if we've seen this file before.  We don't need to do            # anything for new files.            if filename in self.mtimes:                # If this file's mtime has changed, queue it for reload.                if mtime != self.mtimes[filename]:                    self.queue.put(filename)            # Record this filename's current mtime.            self.mtimes[filename] = mtime&amp;lt;/code&amp;gt;
此外还可以通过调用原生操作系统的相关函数, 比如 Win32 Directory Change Notification之类的函数.

加上我们的reloader()部分:


1234567891011121314151617181920212223242526import impimport reloaderclass Reloader(object):    def __init__(self):        self.monitor = ModuleMonitor()        self.monitor.start()    def poll(self):        filenames = set()        while not self.monitor.queue.empty():            try:                filenames.add(self.monitor.queue.get_nowait())            except queue.Empty:                break        if filenames:            self._reload(filenames)    def _reload(self, filenames):        modules = [m for m in sys.modules.values()                if getattr(m, '__file__', None) in filenames]        for mod in modules:            reloader.reload(mod)&amp;lt;/code&amp;gt;
在这一模型中, reloader需要循环执行来检测文件的状态, 从而能够计时的响应. 最简单的则是:


12345r = Reloader()while True:    r.poll()    time.sleep(1)&amp;lt;/code&amp;gt;
想要看源代码的可以前往:  complete source code 本身代码也发布到Python Package Index中, 名称为  reloader
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Teenage Usability(译)-为青少年而设计</title><link>http://taoalpha.me/blog/2013/06/12/read-teenage-usability-translated-designed-for-young-people/</link><category>read</category><tag>UX,产品学习,翻译文章,设计,青少年</tag><pubDate>2013-06-12T05:00:00.000Z</pubDate><description>Teenage Usability:Designing Teen-Targeted WebsitesSummary: 青少年往往会对自己的网络技能过渡自信,但实际上他们表现的比成年还要差劲.更弱的阅读水平,没有耐心,而且尚未发展成熟的研究技能,都减少了青少年完成任务的成功率以及对于简单可靠的网站的需要.
青少年们都是兴奋的.技术已经和青少年的生活密切的结合到一起了,此时为他们创造更多有用而且有益的网站变得更加关键了.在当下这个下一件最重要的事情就是点击鼠标,而短信息打断活动已经成为一种默认的规则而不是偶尔发生的例外的时代,网站架设者们必须清晰的理解青少年们想要什么,如何让他们留在你的网站上.
为了理解伴随着科技和互联网成长起来的一代人的期望,我们设计了经验性的可用性研究,针对真实的青少年对象,来寻找可以指导关于网站如何提升以满足青少年的能力和偏好.
我们的研究拒绝了很多刻板印象,包含以下这类的青少年:
    只是为了通过网络的图片和媒体获得娱乐的;    非常精通技术的科技控;    手机控,用手机做任何事,而且    希望所有事物都能社交化的;青少年不是那些有选择性放弃的浏览网络的技术控们.而且他们并不喜欢充满了炫目的,闪烁的图片的网站.青少年大都比较一致,千篇一律的只喜欢那些大胆新奇的事物.他们经常毫不惧怕技术风险的浏览着网络,而且经常会连接到某种形式的媒体之中.虽然这些都是部分正确的,但是这些都是过于简单的,而且让这些来指引你的设计可能会导致非常灾难性的后果.
青少年们使用网络的设备是非常多样的,而且会依据不同的环境而有所不同.在我们的研究中,我们主要关注于网页的可用性.主要是从桌面电脑或者笔记本的角度来说. 我们同样也观察了移动网站的可用性,以及青少年是如何使用移动设备的.虽然青少年在发短信,上facebook等事情上花费了无穷无尽的时间,我们并没有关注于此,因为我们的目标是归纳出可以作为主流网站的设计指导的标准,而不是帮助建立下一个Facebook.
关于本研究
我们归纳出了111条能吸引青少年并把他们留在你的网站上的可用性指导原则.这些推荐的规则都是基于多种方法的观察研究之上.共计84名用户,年龄范围在13-17岁之间的参与者,分为两轮参与了本次研究:38名请少人在原始研究(8年前),而46名青少年在新的研究中.我们把我们的发现按照下述的三个方法分成三部分:
    可用性测试:我们和参与者逐一进行测试,并且给与他们一定的任务来完成,让他们在操作的过程中说出他们的想法.为了让整个场景尽可能的有效,我们按照每个参与的青少年的真实兴趣尽量的模拟了真实世界的场景.    实地考察:我们在青少年的家里以及学校观察他们.在他们访问网站期间,我们没有实现给予他们预定的任务,而只是观察他们平常的时候使用网络的方式.    采访测试对象以及焦点小组:为了获得更进一步的关于他们体验的意见和态度,我们询问参与者,由他们提供了一些示例细节,关于他们是如何以及什么时候使用网络的,以及他们认为哪些网站是有用而有趣的.我们同时还请求青少年们给了我们关于如何让网站更有吸引力的建议.采访既会发生在可用性测试前,也会发生在可用性测试之后,同样也会在焦点组中进行.我们在US,Australia的城市和乡村,从富裕的城镇到平穷的乡村都进行了研究.我们测试对象由大致相等的男生女生组成,就152个包含了一个很大范围的网站测试集进行测试,测试集包含:
    学校资源(加州州立大学,BBC学院,SparkNotes)    旅游,艺术以及娱乐类(Lonely Planet等)    健康类(Australia Drug Foundation)    信息参考类(Nature)    新闻类(CNN)    娱乐和游戏类(MTV等)    电子商务类(Apple)    企业官网(Samsung)    政府网站(NASA)    非盈利机构网站(The Insite,World Food Programme)从这些样例中可以发现,我们测试的网站中既有面向青少年的专业网站,也有一些主流网站,其受众的一部分是青少年.
Teen Motivation For Using Websites(青少年使用网络的动力)
青少年使用网络的理由很多样,其中包含娱乐.通常来说,他们会有比较明确的目标,即便是那个目标只能获得他们持续10分钟的注意力.
虽然他们上网的目的和成年人可能不一样,但是青少年在主要的方式上还是和成年人一致的:两组人都希望网站足够简单易用,可以让他们很快的完成既定目标.想成年人那样,青少年们也大多是面向目标的类型,而且很少无目的的浏览网页.这也是为什么网站的易用性对于他们的重要性和其他用户组一样的原因了.
我们的研究报告指出,青少年们使用网站用于:
    学校的安排    爱好或者其他特殊的兴趣(包含学习新的技能以及参与有趣的活动)    娱乐(包含音乐和游戏)    新闻(包含体育类,时事类的以及娱乐类的)    学习一些新的话题    和朋友聊天    购物即便当青少年没有在网站上做任何实际的买卖,他们也会访问这些网站,并且在其中寻找商品建立自己的心愿单,针对于那些有支付信用卡能力的成年人.
好消息和坏消息
好消息:青少年在导航网站以及找到他们想要的方面变得更加成功了.青少年的成功率大约提升了16%,按照现在的和8年前的相比,相当于每年增长2个百分点.这相比于成年人在过去的10年里平均每年1.7个百分点的增长还是有微弱的优势.
注意:成功率反应的是任务完成的学生比例.任何小于100%的百分比都代表了一个网站设计上的失败或者商业上的损失.

究竟是青少年变得更优秀了呢?还是网站变的更优秀了呢?可能两者都有吧.我们观察到了青少年许多和8年前的研究中一样的坏习惯.因此,新研究中青少年良好的表现至少有部分是来自于网站设计本身的提升的. 即便如此,虽然我们8年前的研究对象都是一些重度的互联网使用者,但今天的青少年们有了更多的时间投注到更庞大的互联网中,去使用它,这也导致了更多的机会去磨练他们的浏览技巧.
坏消息:青少年们并没有人们想象中的那么无敌.虽然青少年在网络上会感觉很自信,但是他们也会犯错误,而且经常轻易的就会放弃.行动敏捷的青少年们相比成年人有更少的谨慎而且经常轻易的下判断,这些都导致更小的成功.实际上,我们得到的成功率只有71%,而成年人则获得了83%的成功率.
青少年们表现的比成年人差主要是以下三个原因:
    尚不熟练的阅读技巧;    缺少复杂的研究策略;    低到不可思议的耐心;为了提升你的网站对青少年的易用性,你必须考虑以上三个因素.
通过不同网站类别,青少年在电子商务网站获得最好的成功,这类网站经常有着标准的设计方式,而且需要很少的阅读技巧.青少年们对那些提供紧凑的内容和弱小的导航的大网站而言是一个巨大的挑战.政府网站,非营利组织网站以及学校网站等都是这种低可用性的代表.
不管可用性的提升,我们在前些年以及最新的观察中发现了用户纠结于同样的问题:由于合并一些属性以及设计方法而造成的问题.因此,无论是传统的还是新的指导原则都必须考虑技术和人都是在持续进化的,我们最新的报告包含了总计110条指导原则,相比于最初版本的61条还是增加了不少.
许多指导原则同样适用于普通的用户.对于青少年,这些原则显得更加重要因为易用性表现出了巨大的门槛效应.
Write Well(优秀的文章)
为那些没有耐心的用户而写.再没有比满满一屏幕混乱的文本更让年轻的用户感到痛苦而放弃了.青少年们更容易变得无聊,分散以及挫败感.青少年不喜欢在网络上阅读太多东西.他们在学校里已经读的够多了.同样的,许多青少年的阅读技能并不完美,尤其是那些相对更年幼的青少年们.那些更容易浏览或者视觉上更明显的阐述概念的网站更受到青少年的偏爱,尤其是相比于那些有着紧凑文本的网站.
应用适当的网络书写和排版技术对于和青少年沟通是非常关键的.在小而有意义的块中显示内容,并加以足够的空白/小块可以帮助学生更好的获取信息以及找到他们上次被短信或者电话打断时读到的地方,而且这种打断几乎还是不可避免的.
通过选择合适的词语来帮助青少年理解以及获取他们的注意力.使用那些青少年可以理解的词语.句子以及段落要足够短.青少年通常在阅读和理解技巧上要略逊于成年人.如果你的网站面向的用户比较广,那么就用6年级的阅读水平(或者更低)作为书写的参考标准.在这一水平的书写,可以帮助几乎所有的用户,无论是年轻的还是年老的,都可以快速的理解你的内容.
研究过程中,还有一个令人惊喜的发现:青少年和成年人都不喜欢那些太小的字体.我们经常提醒使用小字体的网站,因为它们太小而可能对老年人有负面影响(甚至人过了40岁,视力就开始下降了).我们一贯假设小字体占据主导是因为多数网页设计师都是年轻人,都还有着近乎完美的视力,所以当我们发现小字体对我们的青少年用户也会产生一些问题,引起一些负面的评价时,我们非常惊讶.虽然他们的视力明锐,但在阅读太小的文字时,他们更容易快速跳过或者更容易的被分散注意力.
Avoid Boring Content–and Entertainment Overload(避免无趣的内容,以及过度娱乐)
青少年经常抱怨他们浏览的网站过于无趣.枯燥的内容对于那些想要留住青少年的网站而言就是死神之吻.然而,并不是所有的内容都需要有很炫的交互的.虽然青少年们对于美感有较高的评价,但是它们对于表现混乱,包含无意义的媒体的网站也是敬谢不敏的.
注意不要过度使用交互属性,因为你在为青少年进行设计.多媒体可以吸引也可以激怒青少年,完全取决于它是否有用.对于青少年而言,最佳的上网体验是那些可以交给他们一些新东西或者那些让他们关注于某个目标的网站.
什么才是好的?以下的这些交互属性都是不错的,因为他们让青少年更好的做事情而不是简单的坐下来阅读:
    在线小测验;    提供反馈意见或者提问的表;    在线投票;    游戏;    分享图片或者故事的功能;    信息板;    可以提供建议或者给出建议的论坛;    创建一个网站或者添加内容的功能;这些交互的功能都让青少年们在互联网上留下了自己的痕迹或者用某种方式表现了他们自己,有些很微小,有些则很突出.
网站类型对于用户的期待值是有影响的.比如说,青少年会期待在电子商务网站或者品牌网站中看到专业,而在信息类站点上则希望看到简单而且经过润色的内容;对于后者,用一种礼貌的方式展现有趣的内容会比用新的复杂的功能体验起来更加有吸引力.青少年可以自如的学习以及感到被吸引.
Make It Snappy(让网站变的时髦)
一个加载速度很慢的网站会是一个很好的破坏者.无论你做什么,首先先确保你的网站载入速度够快.慢,迟缓的网站对于任何人都是一种沮丧的体验,但是它们对于期待瞬间满足的青少年而言尤其如此.
每次在你开发新的超酷的插件前好好再想想.如果它很慢,那还是算了吧.青少年们不会有耐心等待它的.因为青少年经常使用的是旧的,二手的计算机,有时候还有着比较慢的网络连接,那些酷炫的特性可能不会很好的展现.青少年喜欢子啊网站上做事情,他们不喜欢看那些很慢的网站或者看起来很炫但是表现的很迟缓的网站.
Don’t Talk Down To Teens(不要轻视青少年)
避免任何听起来可能有优越感或者幼稚的话语.恰当的语调可能促使你的成功,也有可能造成你的失败.青少年们多和那些同龄人创造的故事有关,所以你的网站应该提供那些真实的故事,图片以及来自其他青少年的真实例子.
我们研究中一些网站试图在一个层面上同时服务于儿童和青少年,通常都是让标题看起来像是孩子气的感觉.这其实是一个自掘坟墓的行为,”kid”这个词正好引起青少年的厌恶.青少年对于他们刚赢得的地位有着很强的自豪感,他们不希望过于幼稚的内容—这是面向青少年用户的网站避免过于动画风格或者显眼的色彩主题的又一原因.我们推荐位青少年和儿童提供不同的部分,并分别加以”kids””Teens”的标题.
Let Teens Control The Social Aspects(让青少年控制社交的方面)
让分享变的容易但不强迫分享.青少年们的社会交际通常都依赖于科技,但是他们并不希望无时无刻都处在社交的环节中.他们希望能够控制他们分享的内容以及如何分享.那些强迫青少年去注册然后自动将他们的注册信息公开的网站违反了信任的原则.父母以及老师教育青少年在年轻的时候保护自己的隐私,其中一条就是要避免那些恼人的网站.
当提供分享的功能时,确保包含邮件.不像大学生,青少年经常喜欢使用电子邮件来分享内容,因为他们更注重保护自己的社交账号,而且更谨慎的决定什么人可以看到他们的活动状态.
Design For Smaller Screens and Poor Ergonomics(为那些小屏幕和弱小的工效学而设计)
许多学生在尴尬的时候都会使用移动设备来上网,而这些笔记本,平板以及手机等,都有着比较小的屏幕.随着移动设备的发展,就需要你在设计一个网站的时候选择一种不会损害到易用性的方式.因此,即便是对商业用户屏幕在越来越大,青少年也极少能拥有自己的高端台式电脑.
青少年经常使用带触控板的笔记本,这让交互对于精确性的需求有了要求,比如下拉菜单,拖拽行为,以及小按钮–操作很困难.翻转效果或者狭小的点击区域等设计元素往往会造成问题,如果他们到处都在使用的话.小号文本和紧凑的文本让阅读变的困难.整合所有的功效性低的元素,你就有了一个针对各类错误和苦事的处方了.
媒体所描绘的青少年都是那种非常熟练的计算机操作者.而实际上,青少年对于利用认知能力整合信息是过度自信的,也就意味着他们经常轻易的放弃,然后责怪网站的设计.他们不会责怪自己,他们责怪你.
Age Group Difference(年龄不同的差异)
下表总结了在为少年,青少年,大学生以及成年人而进行的设计方法的主要相似点和差别.其中,关于儿童的发现是基于3-12岁的用户的;而关于大学生的发现则是基于18-24岁的用户的.

    Smile:代表喜欢,感兴趣,收到吸引,或者用户可以非常轻松的适应它    Middle:用户可能对于其中的一些方面比较看好,但是大量使用可能会出现问题    Dislike:用户不喜欢,甚至不愿意做,或者觉得很难操作很明显,在不同的年龄组中有着非常明显的差异.其中对于青少年而言,易用性的最高水平在于设计直接命中了他们的需求和行为,这一点和儿童以及成年人都有所不同.从表中还可以看到,无论是对交互设计还是对那些更明显的因素,比如话题以及内容风格,这一点都是没错的.
更多的信息和完整的青少年网站设计可用性指导原则,可见我们的全部研究报告. Edit By MaHua
</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>为什么以及如何应用&quot;persona&quot;</title><link>http://taoalpha.me/blog/2015/06/11/read-things-related-to-persona/</link><category>read</category><tag>UX,User Test,persona</tag><pubDate>2015-06-11T10:00:00.000Z</pubDate><description>来源介绍UX BOOTH一直是我很喜欢的一个UX站之一, 不止喜欢其文章, 更喜欢其设计的简洁明了, 重点突出~ 一个好的UX站首先自己的网站设计一定要足够优秀, 毕竟自己的瓜不甜, 如何叫人种瓜呢?
Creating Personas是UX BOOTH最近的一篇文章, 主要讲的内容也是和persona相关的, 对于任何一个产品而言, 找对你的面向对象, 目标用户是你成功的首要因素之一. 所以读完本文后, 特来分享到此.
什么是persona首先介绍下persona, persona一词应用到UX领域最早是Alan Cooper在他的The Inmates Are Running the Asylum一书中引入的, 是表示Cooper为了解决设计问题而引入的虚拟用户. 这些虚拟用户本身也都是基于研究数据的. 从那之后, persona就成为了很多”以用户为中心的设计”或者”面向大众设计”等原则的核心思路之一, 逐渐取代了早期的”移情式角色扮演法”.
简单来说, persona就是基于研究数据而建立其的用户抽象模型. 在设计过程将其作为用户来看待, 从而让设计,甚至开发过程都变的更具实际意义, 更加就事论事.
通常会将persona分为三种:

Marketing personas: 主要关注与用户的基本属性, 购买动机以及消费的倾向等等; 通常会对用户的行为做出基本的解释, 但并不关注或深究其背后的原因, 通常适用于为特定产品选择合适的消费者;
Design personas: 与关注商业方面的marketing personas不同, design personas主要关注用户的预期, 目标, 所作出的行为以及其所遇到的痛点等等; 这些personas的建立都是基于具体的研究和真实的用户数据. 这种persona的主要目的是阐述用户为什么这么做的, 借此来将用户引入到整个产品的设计, 开发和服务的各个环节之中. 通常会贯穿整个产品周期, 时刻借此提醒不要便宜目标用户, 始终将核心关注到用户的需求之中去而不是自己的需求上去;
Proto personas: 这算是一个不标准的Design personas, 因为通常一个完善的design personas是非常耗费资源的, 很多时候可能没有那么多的时间,经历,经济来去建立一个design persona, 这时候我们可以利用他人的研究资料以及团队本身对服务用户的了解, 建立一个不那么严格的design persona, 即proto persona. 需要注意的是, 即便不够标准, proto persona也一定是基于有效的研究数据建立的.

为什么要使用persona说完了什么是persona, 想来大家对为什么要用persona也有了一定的认识. 无非就是以下几点:

通过具体的用户模型, 我们就能将用户需求贯穿产品始终, 时刻提醒我们关注的核心和重点;
让用户由抽象繁杂变的清晰明了, 更加容易做到以用户为核心的设计;
更加容易区分核心任务和非核心任务;
更加容易激发灵感;…

如何使用persona说了这些persona的好处, 我们该如何使用persona呢? 先说说不用persona可能带来的坏处吧, 除了上述那些好处都没了外:

我们很容易被个别用户所引导, 从而不断的更改设计和需求方案;
团队很容易出现理解上的偏差, 很容易出现自我代入的思维方式;
很容易陷入到边缘需求之中去;

那么如何使用呢?

根据研究资料, 用户调查, 抽象出典型用户模型;
团队沟通要完善, 确保每个人都对建立的persona有足够清晰统一的认识;
需求要以persona为评判对象, 以用户核心需求作为第一要务;
在产品的各个环节都要随时保持对persona的对比验证, 确保始终走在以用户为核心的设计之路上;

简单? 哈哈, 其实这里的核心都在与那个用户模型, 好的用户模型才能带来实际的好益处, 那么如何评判一个好的用户模型呢?

好的persona一定是反映出了研究中的某种模式;
好的persona一定是关注当前的, 而不是着眼于未来的;
好的persona都是非常现实的, 没有那么多的理想主义;
好的persona都代表着一个颇有难度的设计对象;
好的persona能够帮助你了解用户的使用情景, 行为, 态度, 需求, 痛点以及其目标和动机;

哈哈, 挺虚的? 可以看看Chris Kelly 收集到pinterest的一些personas的例子~ 也许你会有更加清晰的认识哦~
结语第一次接触到persona这个词是12年在TX实习的时候, 因为要针对伦敦奥运会做一个微博活动平台, 当时就需要我们针对微博运营人员的调研而建立一个persona, 从而更好的整合大家的需求, 以解决共同需求为主要目的. 当时觉得persona其实就是个用户需求代表, 现在来看, persona更准确说应该是个带着用户主要共同需求的虚拟人物.
而且通常来说, persona只有和scenario结合的时候才有价值, 而往往一个product下有不止一个persona, 更有无数scenario. 拥有一个完善的persona, 就相当于有一个更好的代入对象, 我们都可以更好的找到一个用户的角度去观察和思考在某个情景下的用户目标, 行为和预期等等, 从而让产品设计的更加贴近用户, 更加自然的与用户交互了.
参考资料:
Persona - Wiki
Chris Kelley’s Board of Personas
Using Proto-Personas for Executive Alignment
Clear look at personas - smashing magazine

</description><source>TaoAlpha</source><author>TaoALpha</author></item><item> <title>Success happens overnight(译)--很好的解释&quot;一夜成名&quot;的真相</title><link>http://taoalpha.me/blog/2013/06/11/read-success-happens-overnight-translated-a-good-explanation-overnight-truth/</link><category>read</category><tag>HCIBib,产品学习,翻译文章</tag><pubDate>2013-06-11T09:00:00.000Z</pubDate><description>From UXMYTH{Myth # 32} Success happens overnight–成功总是发生在一夜之间的苹果iPod的出现几乎立刻就把MP3播放器市场整了个天翻地覆,不是吗?亚马逊 也几乎是一下子改变了整个书类的销售方式,不是吗?好吧,世界上它们并没有那么夸张…虽然外界看起来好像是这样的.
事实上,即便是对于互联网企业,也往往需要多年的努力才能获得一夜成名. 多年的辛苦工作,学习,试验以及一路上无数的失败.有时候甚至还要追逐一个几乎所有人都不喜欢的项目,比如当初随着Gmail开发的”Crazy Javascript stuff”.


那些看起来很写意的成功也往往花费了很长的时间去实现的.
    Amazon:亚马逊成立于1994年,但是直到1996年才增加了书评的功能.一开始他们主要努力于获取用户.他们一直到1998年才增加了CDs类的商品,而直到2001年它们甚至都没有获得利润.而这一点很容易被人忽略,从而以为它们在此之前就获得了成功…    Twitter:Twitter的创始人Biz Stone在创立Twitter之前,已经在Blog,移动和社交等领域从事产品工作长达八年之久.他自己说:”时机,耐心,花费十年努力才最终让你似乎一夜成名”.    Apple iPod:iPod的一夜成名背后有着三年的努力付出.”第一款的iPod是在2001年发布的,在一年内,苹果就改进了它的功效性而发布了第二版.但是直到2004年的第四版才开始出现脱销的盛况.”    37signals:当我们五年前开始Basecamp的时候,我想我们只有不到2000人订阅我们的RSS.即便算上那些时不时只是过来看一下的用户也只多了几千人.所以猜测我们初始的用户不到5000人还是蛮合理的.从今天来看,它的规模是非常小的.但是当初那些用户也是我们花费了多年的时间建立起来的.    Gmail:我们是在2001年8月开始Gmail项目的.在很长的一段时间里,几乎所有人都不喜欢它…有不少的一些人认为我们应该关闭这个项目,或者重启这个项目,并将它作为一个企业级产品,再加上本地客户端软件,而不是所谓的crazy Javascript stuff.甚至到2004年4月1日,也就是开启2年半后,许多Google内部的人都预测它最终将走向灭亡…    AngryBirds:愤怒的小鸟是一款非常成功的手机游戏.但是Rovio本身在做到这一点之前已经经历过30多款手机游戏了…    FedEx:Frederick W.Smith在1965年的时候想到了这个快递寄送服务的主意,在1973年的时候成立了FedEx,当时第一天只有7个包裹,而在事业初期的26个月里,它就损失了2900万美金,但是仅仅到70年代末它就获得了成功.    The Beatles:披头士似乎是在1964年在Ed sullivan的表演中,突然出现并引爆了整个世界.但是它们其实从1957年就开始在Liverpool和Hamburg的小酒吧中玩音乐了,而且在他们获得了广大影响力的早期,它们第一个关键意义的成功,Sgt Peppers是在1967年发布的.    …或者看下Tiger Woods:虽然他是世界上最年轻的获得大师赛冠军的高尔夫选手,他也是花费了他整个人生在练习的.”他是一个少年天才,在两岁前就开始接触高尔夫了.”还有更多的一些关于一夜成名的看法:
    一夜成名的概念对于任何希望长期并稳定可持续发展的企业而言都是一种误导甚至非常有害的.无论是何种商业,巨大的成功都是花费了多年的努力汗水才建立起来的,而且很少有反例(即很少有不劳而获的).”Spotify的联合创始人Daniel Ek说道.”一夜成名的背后往往有着长时间的努力积累.简单的总结就是:更努力的工作,把一件事做到更好,做得更快,让自己变得更加强壮,比之前更好,一小时接着一小时的,我们的工作从来没有结束的时候.”    Seth Godin认为”一直以来,一些人说服自己去相信只有一种成功值得拥有,那就是’一夜成名’,那种如果你不在第一周内达到巅峰,那么你就等同于失败了.那种如果你的交互界面没有完美到跳出界面本身,或者你的新店没有在开张的时候门口就排了5000人的队,那么你就都已经输了”.    Barrie Bergman曾在他的ChangeThis宣言中这样写道”个人来说,我从来没遇到过一夜成名的好事.我曾经遇到过那些在很长的时间里都做得好好的人,只是突然被发现了而已.然后所有人都假设这些人都是无名氏,就那么突然一夜成名了.”    “一夜成名真的也就是一夜而已.” Jonathan Fields.当然,YouTube算是一个例外了.不过想想即便是他们也花费了五年的时间才开始盈利.
</description><source>TaoAlpha</source><author>TaoALpha</author></item></channel></rss>