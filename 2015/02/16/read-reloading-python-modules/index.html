<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Reloading Python Modules | TaoAlpha's Blog</title><meta name="description" content="Here is my new blog based on hexo."><meta name="viewport" content="width=device-width, initial-scale=1"><!-- open graph part--><meta property="og:image" content="http://taoalpha.me/images/newblog.jpg"><meta property="og:description" content="TaoAlpha's hexo Blog"><meta property="og:type" content="website"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/default.css"></head><body class="blogpost"><aside class="home-menu"><nav class="home-icon-con upside"></nav><a href="/blog/" class="home-menu-icon brand active">涛</a><a href="/blog/tipme" class="home-menu-icon"><i class="fa fa-1x fa-gratipay"></i></a><a href="javascript:$('.searchbox').focus().css('border', '4px dashed #666');setTimeout(function(){$('.searchbox').focus().css('border', 'none').css('border-bottom', '1px solid #ccc')},1000);" class="home-menu-icon"><i class="fa fa-1x fa-search"></i></a><a href="/blog/puzzle" class="home-menu-icon"><i class="fa fa-1x fa-puzzle-piece"></i></a><a href="javascript:;" title="Contact Me" class="home-menu-icon follow">+</a><div class="home-contact"><a href="http://facebook.com/zzgary/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/facebook-32.png" alt="facebook"></a><a href="http://github.com/taoalpha/" target="something"><img src="https://cdn1.iconfinder.com/data/icons/social-shade-rounded-rects/512/github-32.png" alt="github"></a><a href="http://taoalpha.me" target="something"><img src="https://cdn3.iconfinder.com/data/icons/colore-sociale/32/mewally_32x32.png" alt="portfolio"></a><a href="http://douban.com/people/129154019" target="something"><img src="http://img3.douban.com/favicon.ico" alt="douban"></a></div><nav class="home-icon-con downside"><a href="#contribution" class="home-menu-icon makecontribution"><i class="fa fa-pencil fa-1x"></i></a><a id="togglemusic" href="javascript:;" class="home-menu-icon"><i class="fa fa-music fa-1x"></i></a></nav><div id="musicbar"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="40" src=""></iframe></div></aside><div id="contribution" class="hide"><span class="close"></span><input id="sender_mail" type="email" placeholder="Give me your email"><textarea id="contributionContent" name="contribution" cols="30" rows="10" placeholder="Thanks for your contribution!  Now tell me what you want to say: feedback ? advice ? contributions ? Whatever you want ^_^.  I will look at it as soon as I receive it and reply you asap.  "></textarea><input id="sendToMe" type="submit"></div><article id="content"><section class="entry"><h1 class="entry-title"><a href="http://taoalpha.me/blog/2015/02/16/read-reloading-python-modules/" title="Reloading Python Modules">Reloading Python Modules</a></h1><div class="meta-top"><a href="http://taoalpha.me"><div style="display:inline-block;" class="avatar"><img src="https://avatars3.githubusercontent.com/u/4335753?v=3&amp;s=40" alt="100"></div><span>TaoAlpha</span></a><span>2015-02-16</span><span class="wordage">7969字</span><span class="readspeed">23 分钟读完</span></div><p><a href="http://www.indelible.org/ink/python-reloading/" target="_blank" rel="external">Reloading Python Modules</a>是一篇10年的老文了. 不过正好最近有看到Python中reload的相关介绍, 推荐了本文, 特地译来加深记忆以及分享给大家:</p>

<p>Python众多优点中的一个就是可以对代码模块进行重载. 这就允许了开发者即便在Python的编译器运行状态下也可以修改Python代码了. 通常来说,  只需要把对应要重载的模块对象传入 <a href="http://docs.python.org/3.1/library/imp.html#imp.reload" target="_blank" rel="external">imp.reload()函数</a>中即可(python 2.x中是通过直接<a href="http://docs.python.org/2.6/library/functions.html#reload" target="_blank" rel="external">reload()</a>来实现). </p>

<p>不过这里面还有几个潜在的复杂问题.</p>

<p>如果一个模块中引入了重载模块的一些symbols, 那么这些symbols不会自动重载. 比如, 我们有一个包含了常量 INTERVAL = 5的A模块, 而模块B则引入了这一常量, 比如通过(from A import INTERVAL). 那么如果我们修改INTERVAL = 10, 然后重载A模块的话, 在B模块中的INTERVAL以及所有基于INTERVAL的值都不会自动更新的.</p>

<p>解决这一问题的办法就是我们要把B模块也重载一些. 但是要注意的是一定要在A模块重载完后重载B, 不然的话, B还是不能按照更新后的A来执行.</p>

<p><a href="http://pyunit.sourceforge.net/" target="_blank" rel="external">PyUnit</a>则通过引入了一个 <a href="http://pyunit.sourceforge.net/notes/reloading.html" target="_blank" rel="external">rollback<br>importer</a>的方式来处理这类问题. 它会通过重写python的全局引入 <strong>import</strong>而将引入规则”rolls back”到之前的状态.  这一方法在让编译器还原到前一测试点上非常便捷, 但是却不能算是一个解决实时代码重载的好方法, 因为那些为加载的模块还是不能自动的重载.</p>

<p>下述介绍了一个很好的模块重载解决方法, 目的是让这一过程更加自动化, 更加透明以及可靠.</p>

<h4>Recording Module Dependencies</h4>

<p>在重载前一定要清楚各个模块之间依赖关系, 这样才能很好的设计重载的顺序. 理想的方法是建立一个模块之间的依赖关系图谱. 这可以通过引入一个自定义的import, 并且在程序常规代码部分引入它来实现.</p>

<p>import builtins</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">_baseimport = builtins.__import__</span><br><span class="line">_dependencies = dict()</span><br><span class="line">_parent = None</span><br><span class="line"></span><br><span class="line">def _import(name, globals=None, locals=None, fromlist=None, level=-1):</span><br><span class="line">    # Track our current parent module.  This is used to find our current</span><br><span class="line">    # place in the dependency graph.</span><br><span class="line">    global _parent</span><br><span class="line">    parent = _parent</span><br><span class="line">    _parent = name</span><br><span class="line"></span><br><span class="line">    # Perform the actual import using the base import function.</span><br><span class="line">    m = _baseimport(name, globals, locals, fromlist, level)</span><br><span class="line"></span><br><span class="line">    # If we have a parent (i.e. this is a nested import) and this is a</span><br><span class="line">    # reloadable (source-based) module, we append ourself to our parent's</span><br><span class="line">    # dependency list.</span><br><span class="line">    if parent is not None and hasattr(m, '__file__'):</span><br><span class="line">        l = _dependencies.setdefault(parent, &amp;lt;input type=checkbox&amp;gt;)</span><br><span class="line">        l.append(m)</span><br><span class="line"></span><br><span class="line">    # Lastly, we always restore our global _parent pointer.</span><br><span class="line">    _parent = parent</span><br><span class="line"></span><br><span class="line">    return m</span><br><span class="line"></span><br><span class="line">builtins.__import__ = _import</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>这里把内置的<strong>import</strong>函数(在_baseimport类中)做了简单的修改. 它能够跟踪当前的母模块(依赖模块), 也就是进行import操作的模块. 而最顶层的模块自然是没有依赖模块的.</p>

<p>而一旦一个模块被成功的引入后, 它就会自动的加入到依赖模块的依赖列表中去. 你可能注意到上述代码中只是关注了那些基于文件的模块 内置的那些扩展则都被忽略了, 这是因为内置的模块是不能够被重载的.</p>

<p>这就给我们了一个完整的模块依赖关系链, 我们就能够轻松的获取到某个模块相关的所有依赖模块了:</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def get_dependencies(m):</span><br><span class="line">    """Get the dependency list for the given imported module."""</span><br><span class="line">    return _dependencies.get(m.__name__, None)</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<h4>Reloading Modules</h4>

<p>在知道了相关的依赖模块关系后, 我么就可以建立一个依赖模块重载路线了:</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import imp</span><br><span class="line"></span><br><span class="line">def _reload(m, visited):</span><br><span class="line">    """Internal module reloading routine."""</span><br><span class="line">    name = m.__name__</span><br><span class="line"></span><br><span class="line">    # Start by adding this module to our set of visited modules.  We use</span><br><span class="line">    # this set to avoid running into infinite recursion while walking the</span><br><span class="line">    # module dependency graph.</span><br><span class="line">    visited.add(m)</span><br><span class="line"></span><br><span class="line">    # Start by reloading all of our dependencies in reverse order.  Note</span><br><span class="line">    # that we recursively call ourself to perform the nested reloads.</span><br><span class="line">    deps = _dependencies.get(name, None)</span><br><span class="line">    if deps is not None:</span><br><span class="line">        for dep in reversed(deps):</span><br><span class="line">            if dep not in visited:</span><br><span class="line">                _reload(dep, visited)</span><br><span class="line"></span><br><span class="line">    # Clear this module's list of dependencies.  Some import statements</span><br><span class="line">    # may have been removed.  We'll rebuild the dependency list as part</span><br><span class="line">    # of the reload operation below.</span><br><span class="line">    try:</span><br><span class="line">        del _dependencies[name]</span><br><span class="line">    except KeyError:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    # Because we're triggering a reload and not an import, the module</span><br><span class="line">    # itself won't run through our _import hook.  In order for this</span><br><span class="line">    # module's dependencies (which will pass through the _import hook) to</span><br><span class="line">    # be associated with this module, we need to set our parent pointer</span><br><span class="line">    # beforehand.</span><br><span class="line">    global _parent</span><br><span class="line">    _parent = name</span><br><span class="line"></span><br><span class="line">    # Perform the reload operation.</span><br><span class="line">    imp.reload(m)</span><br><span class="line"></span><br><span class="line">    # Reset our parent pointer.</span><br><span class="line">    _parent = None</span><br><span class="line"></span><br><span class="line">def reload(m):</span><br><span class="line">    """Reload an existing module.</span><br><span class="line"></span><br><span class="line">    Any known dependencies of the module will also be reloaded."""</span><br><span class="line">    _reload(m, set())</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>上述reload()函数通过递归方式去按照相反顺序依次reload所有和这一模块相关的模块, 而最后再reload以下自身. 它通过<strong>visited</strong>属性的设置来避免出现无限死循环. 同时在reload的时候它会自动重建模块的依赖关系, 来确保他们能精确的反映出模块的更新状态.</p>

<h4>Custom Reloading Behavior</h4>

<p>有时候reload模块的时候可能需要执行一些其他的操作或者逻辑. 比如, 重新初始化一些预加载的状态. 而为了支持这一点, 我们需要让我们的reload函数去寻找一个模块级函数<strong>reload</strong>(). 这一函数可以在一个成功的重载后被调用, 且能保留重载前的状态.</p>

<p>这种情况下, 我们就不能简单的直接调用imp.reload()了:</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># If the module has a __reload__(d) function, we'll call it with a</span><br><span class="line"># copy of the original module's dictionary after it's been reloaded.</span><br><span class="line">callback = getattr(m, '__reload__', None)</span><br><span class="line">if callback is not None:</span><br><span class="line">    d = _deepcopy_module_dict(m)</span><br><span class="line">    imp.reload(m)</span><br><span class="line">    callback(d)</span><br><span class="line">else:</span><br><span class="line">    imp.reload(m)</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>_deepcopy_module_dict()</code>的作用是帮助我们避免<code>deepcopy()</code>一些不支持或者不需要的数据.</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def _deepcopy_module_dict(m):</span><br><span class="line">    """Make a deep copy of a module's dictionary."""</span><br><span class="line">    import copy</span><br><span class="line"></span><br><span class="line">    # We can't deepcopy() everything in the module's dictionary because</span><br><span class="line">    # some items, such as '__builtins__', aren't deepcopy()-able.</span><br><span class="line">    # To work around that, we start by making a shallow copy of the</span><br><span class="line">    # dictionary, giving us a way to remove keys before performing the</span><br><span class="line">    # deep copy.</span><br><span class="line">    d = vars(m).copy()</span><br><span class="line">    del d['__builtins__']</span><br><span class="line">    return copy.deepcopy(d)</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<h4>Monitoring Module Changes</h4>

<p>对于重载而言, 能够自动检测模块的变化而进行自动重载那是最好不过了. 那么, 实际上我们确实有很多方式来检测一个文件的变化情况. 这里使用的是一个后台线程以及 <a href="http://docs.python.org/library/os.html#os.stat" target="_blank" rel="external">stat()</a>这个系统函数的调用来检测文件上一次修改时间, 从而确定其更新状态. 一旦检测到一个文件被更新, 那么就会把这一文件名加入到一个 <a href="http://docs.python.org/library/queue.html" target="_blank" rel="external">thread-safe queue</a></p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import os, sys, time</span><br><span class="line">import queue, threading</span><br><span class="line"></span><br><span class="line">_win = (sys.platform == 'win32')</span><br><span class="line"></span><br><span class="line">class ModuleMonitor(threading.Thread):</span><br><span class="line">    """Monitor module source file changes"""</span><br><span class="line"></span><br><span class="line">    def __init__(self, interval=1):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.daemon = True</span><br><span class="line">        self.mtimes = &#123;&#125;</span><br><span class="line">        self.queue = queue.Queue()</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            self._scan()</span><br><span class="line">            time.sleep(self.interval)</span><br><span class="line"></span><br><span class="line">    def _scan(self):</span><br><span class="line">        # We're only interested in file-based modules (not C extensions).</span><br><span class="line">        modules = [m.__file__ for m in sys.modules.values()</span><br><span class="line">                if '__file__' in m.__dict__]</span><br><span class="line"></span><br><span class="line">        for filename in modules:</span><br><span class="line">            # We're only interested in the source .py files.</span><br><span class="line">            if filename.endswith('.pyc') or filename.endswith('.pyo'):</span><br><span class="line">                filename = filename[:-1]</span><br><span class="line"></span><br><span class="line">            # stat() the file.  This might fail if the module is part</span><br><span class="line">            # of a bundle (.egg).  We simply skip those modules because</span><br><span class="line">            # they're not really reloadable anyway.</span><br><span class="line">            try:</span><br><span class="line">                stat = os.stat(filename)</span><br><span class="line">            except OSError:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            # Check the modification time.  We need to adjust on Windows.</span><br><span class="line">            mtime = stat.st_mtime</span><br><span class="line">            if _win32:</span><br><span class="line">                mtime -= stat.st_ctime</span><br><span class="line"></span><br><span class="line">            # Check if we've seen this file before.  We don't need to do</span><br><span class="line">            # anything for new files.</span><br><span class="line">            if filename in self.mtimes:</span><br><span class="line">                # If this file's mtime has changed, queue it for reload.</span><br><span class="line">                if mtime != self.mtimes[filename]:</span><br><span class="line">                    self.queue.put(filename)</span><br><span class="line"></span><br><span class="line">            # Record this filename's current mtime.</span><br><span class="line">            self.mtimes[filename] = mtime</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>此外还可以通过调用原生操作系统的相关函数, 比如 <a href="http://msdn.microsoft.com/en-us/library/aa365261%28VS.85%29.aspx" target="_blank" rel="external">Win32 Directory Change Notification</a>之类的函数.</p>

<p>加上我们的reloader()部分:</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import imp</span><br><span class="line">import reloader</span><br><span class="line"></span><br><span class="line">class Reloader(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.monitor = ModuleMonitor()</span><br><span class="line">        self.monitor.start()</span><br><span class="line"></span><br><span class="line">    def poll(self):</span><br><span class="line">        filenames = set()</span><br><span class="line">        while not self.monitor.queue.empty():</span><br><span class="line">            try:</span><br><span class="line">                filenames.add(self.monitor.queue.get_nowait())</span><br><span class="line">            except queue.Empty:</span><br><span class="line">                break</span><br><span class="line">        if filenames:</span><br><span class="line">            self._reload(filenames)</span><br><span class="line"></span><br><span class="line">    def _reload(self, filenames):</span><br><span class="line">        modules = [m for m in sys.modules.values()</span><br><span class="line">                if getattr(m, '__file__', None) in filenames]</span><br><span class="line"></span><br><span class="line">        for mod in modules:</span><br><span class="line">            reloader.reload(mod)</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>在这一模型中, reloader需要循环执行来检测文件的状态, 从而能够计时的响应. 最简单的则是:</p>


<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = Reloader()</span><br><span class="line">while True:</span><br><span class="line">    r.poll()</span><br><span class="line">    time.sleep(1)</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>
<p>想要看源代码的可以前往:  <a href="https://github.com/jparise/python-reloader" target="_blank" rel="external">complete source code</a> 本身代码也发布到Python Package Index中, 名称为  <a href="http://pypi.python.org/pypi/reloader/" target="_blank" rel="external">reloader</a></p>
<aside class="tipme special"><a href="/blog/tipme" class="tipme">If you like my work, buy me a soda or send me a book ! ^_^</a></aside></section><aside class="sidenav"><input type="text" placeholder="Enter to search" class="st-default-search-input searchbox"></aside><div class="relatedposts sidenav"><h2>Related Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2015/03/08/read-what-is-pythonic/">What is Pythonic?</a></li><li><a href="http://taoalpha.me/blog/2014/12/05/read-read-a-brief-history-of-web-design/">网页设计简史</a></li><li><a href="http://taoalpha.me/blog/2014/12/04/read-read-google-did-a-good-thing-kill-annoying-type-identification-code/">Google又做了一件大好事:干掉了烦人的识别型验证码!</a></li><li><a href="http://taoalpha.me/blog/2014/11/27/read-talk-about-application-of-colors-in-the-market/">谈谈颜色在市场方面的应用</a></li><li><a href="http://taoalpha.me/blog/2014/11/26/read-brief-web-browsing-behavior/">简述一次网页浏览行为的过程</a></li></ul></div><aside class="sidenav"><div class="recentposts"><h2>Recent Posts:</h2><ul class="article-list"><li><a href="http://taoalpha.me/blog/2016/01/05/oj-oj-leetcode-sort-2/">OJ LeetCode Sort 2</a></li><li><a href="http://taoalpha.me/blog/2015/12/26/Close-old-website-and-related-services/">Close old website and related services</a></li><li><a href="http://taoalpha.me/blog/2015/12/26/Summary-of-the-year/">Summary of the year</a></li><li><a href="http://taoalpha.me/blog/2015/12/26/blog-migration/">Blog Migration from jekyll to hexo</a></li><li><a href="http://taoalpha.me/blog/2015/12/07/tech-my-first-cli-tool-with-nodejs/">First CLI tool with NodeJS</a></li></ul></div></aside><div class="comments"><div data-thread-key="2015/02/16/read-reloading-python-modules/" data-title="Reloading Python Modules" data-url="http://taoalpha.me/blog/2015/02/16/read-reloading-python-modules/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"taoalpha"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><div class="notification fail hidden"></div><!-- jquery--><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46725017-2",'auto');ga('send','pageview');</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
_st('install','CUMLELEvkSRAFuVehSCm','2.0.0');</script><!-- main functions--><script src="/blog/js/functions.js"></script><script src="/blog/js/default.js"></script><script src="/blog/js/post.js"></script></body></html>